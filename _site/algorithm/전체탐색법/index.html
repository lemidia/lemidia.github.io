<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.17.2 by Michael Rose
  Copyright 2013-2019 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>전체탐색법(Brute force) - Code Factory</title>
<meta name="description" content="주어진 문제에서 해가 될 수 있는 모든 가능성을 검사하는 방법. ">


  <meta name="author" content="Gyeong">


<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Code Factory">
<meta property="og:title" content="전체탐색법(Brute force)">
<meta property="og:url" content="http://localhost:4000/algorithm/%EC%A0%84%EC%B2%B4%ED%83%90%EC%83%89%EB%B2%95/">


  <meta property="og:description" content="주어진 문제에서 해가 될 수 있는 모든 가능성을 검사하는 방법. ">



  <meta property="og:image" content="http://localhost:4000/assets/images/headerLogo2.jpg">





  <meta property="article:published_time" content="2019-04-18T00:00:00+09:00">



  <meta property="article:modified_time" content="2019-05-10T22:06:00+09:00">



  

  


<link rel="canonical" href="http://localhost:4000/algorithm/%EC%A0%84%EC%B2%B4%ED%83%90%EC%83%89%EB%B2%95/">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": "Gyeong",
      "url": "http://localhost:4000/"
    
  }
</script>






<!-- end _includes/seo.html -->


<link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Code Factory Feed">

<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">

<!--[if IE]>
  <style>
    /* old IE unsupported flexbox fixes */
    .greedy-nav .site-title {
      padding-right: 3em;
    }
    .greedy-nav button {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
    }
  </style>
<![endif]-->



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->
<link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
<link rel="manifest" href="/icons/site.webmanifest">
<link rel="mask-icon" href="/icons/safari-pinned-tab.svg" color="#5bbad5">
<link rel="shortcut icon" href="/icons/favicon.ico">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="msapplication-config" content="/icons/browserconfig.xml">
<meta name="theme-color" content="#ffffff">
<!-- end custom head snippets -->

<script data-ad-client="ca-pub-8663880613144845" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <!-- mathjax -->
    
      <script type="text/x-mathjax-config">
MathJax.Hub.Config({
    TeX: {
      equationNumbers: {
        autoNumber: "AMS"
      }
    },
    tex2jax: {
    inlineMath: [ ['$', '$'] ],
    displayMath: [ ['$$', '$$'] ],
    processEscapes: true,
  }
});
MathJax.Hub.Register.MessageHook("Math Processing Error",function (message) {
	  alert("Math Processing Error: "+message[1]);
	});
MathJax.Hub.Register.MessageHook("TeX Jax - parse error",function (message) {
	  alert("Math Processing Error: "+message[1]);
	});
</script>
<script type="text/javascript" async
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
    
  </head>

  <body class="layout--single">
    <nav class="skip-links">
  <h2 class="screen-reader-text">Skip links</h2>
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
          <a class="site-logo" href="/"><img src="/assets/images/logo4.png" alt=""></a>
        
        <a class="site-title" href="/">
          Code Factory
          <span class="site-subtitle">Inspiration of Computer science</span>
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="/categories/" >Categories</a>
            </li><li class="masthead__menu-item">
              <a href="/categories/algorithm/" >Algorithm</a>
            </li><li class="masthead__menu-item">
              <a href="/categories/datastructure/" >Data Structure</a>
            </li><li class="masthead__menu-item">
              <a href="/categories/development/" >Development</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16">
            <path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path>
          </svg>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      
  











<div class="page__hero--overlay"
  style=" background-image: linear-gradient(rgba(0, 0, 0, 0.3), rgba(0, 0, 0, 0.3)), url('/assets/images/headerLogo2.jpg');"
>
  
    <div class="wrapper">
      <h1 id="page-title" class="page__title" itemprop="headline">
        
          전체탐색법(Brute force)

        
      </h1>
      
        <p class="page__lead">주어진 문제에서 해가 될 수 있는 모든 가능성을 검사하는 방법.
</p>
      
      
        <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  35 minute read

</p>
      
      
      
    </div>
  
  
    <span class="page__hero-caption">Photo credit: <a href="https://unsplash.com"><strong>Unsplash</strong></a>
</span>
  
</div>





<div id="main" role="main">
  
  <div class="sidebar sticky">
  


<div itemscope itemtype="https://schema.org/Person">

  
    <div class="author__avatar">
      

      
        <img src="/assets/images/gyeong.jpeg" alt="Gyeong" itemprop="image">
      
    </div>
  

  <div class="author__content">
    
      <h3 class="author__name" itemprop="name">Gyeong</h3>
    
    
      <div class="author__bio" itemprop="description">
        <p>It is in the moment of decisions that your destiny is shaped.</p>

      </div>
    
  </div>

  <div class="author__urls-wrapper">
    <button class="btn btn--inverse">Follow</button>
    <ul class="author__urls social-icons">
      
        <li itemprop="homeLocation" itemscope itemtype="https://schema.org/Place">
          <i class="fas fa-fw fa-map-marker-alt" aria-hidden="true"></i> <span itemprop="name">Republic Of Korea</span>
        </li>
      

      
        
          
            <li><a href="mailto:poiu2186@gmail.com" rel="nofollow noopener noreferrer"><i class="fas fa-fw fa-envelope-square" aria-hidden="true"></i> Email</a></li>
          
        
          
            <li><a href="https://github.com/lemidia" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
          
        
          
            <li><a href="https://www.acmicpc.net/user/lemidia" rel="nofollow noopener noreferrer"><i class="fas fa-fw fa-link" aria-hidden="true"></i> Online Judge</a></li>
          
        
          
        
          
        
          
            <li><a href="https://www.instagram.com/gyeong_it/" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-instagram" aria-hidden="true"></i> Instagram</a></li>
          
        
      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs" rel="nofollow noopener noreferrer">
      <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>

  
  </div>


  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="전체탐색법(Brute force)">
    <meta itemprop="description" content="주어진 문제에서 해가 될 수 있는 모든 가능성을 검사하는 방법.">
    <meta itemprop="datePublished" content="2019-04-18T00:00:00+09:00">
    <meta itemprop="dateModified" content="2019-05-10T22:06:00+09:00">

    <div class="page__inner-wrap">
      

      <section class="page__content" itemprop="text">
        
          <aside class="sidebar__right sticky">
            <nav class="toc">
              
                <header><h4 class="nav__title"><i class="fas fa-file-alt"></i> On this page</h4></header>
                <ul class="toc__menu">
  <li><a href="#전체탐색법">전체탐색법</a>
    <ul>
      <li><a href="#선형구조와-비선형구조의-전체탐색">선형구조와 비선형구조의 전체탐색</a></li>
      <li><a href="#선형-구조에서의-전체탐색">선형 구조에서의 전체탐색</a>
        <ul>
          <li><a href="#약수의-합">약수의 합</a></li>
          <li><a href="#최댓값">최댓값</a></li>
          <li><a href="#고기잡이">고기잡이</a></li>
        </ul>
      </li>
      <li><a href="#비선형-구조에서의-전체탐색">비선형 구조에서의 전체탐색</a>
        <ul>
          <li><a href="#계단-오르기">계단 오르기</a></li>
          <li><a href="#거스름-돈">거스름 돈</a></li>
          <li><a href="#연구활동-가는-길">연구활동 가는 길</a></li>
          <li><a href="#references">References</a></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

              
            </nav>
            <!-- devinlife comment : right-sidebar ads -->
            <nav class="toc-custom">
              
                <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- lemidia2 -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-8663880613144845"
     data-ad-slot="5185585092"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
              
            </nav>
          </aside>
        
        <h1 id="전체탐색법">전체탐색법</h1>

<p>전체탐색법은 모든 문제해결의 기초가 되는 가장 중요한 설계법 중 하나라고 할 수 있다. 주어진 문제에서 해가 될 수 있는 모든 가능성을 검사하여 해를 구하기 때문에 항상 정확한 해를 구할 수 있다는 점이 장점이다. 하지만 탐색해야할 내용이 너무 많으면 문제에서 제시한 시간 이내에 해결할 수 없다는 점을 유의해야 한다.</p>

<p>하지만 전체탐색을 기반으로 한 다양한 응용들이 있으며, 이러한 응용들을 통하여 탐색 해야할 공간을 배제해 나가면서 시간을 줄일 수 있는 다양한 방법들이 존재하기 때문에 잘 응용하면 많은 문제를 해결할 수 있는 강력한 도구가 될 수 있다. 따라서 전체탐색법을 잘 익혀두면 다른 알고리즘 설계법을 학습하는데 많은 도움이 된다.</p>

<p>전체탐색법은 선형구조의 탐색, 비선형구조의 탐색을 기반으로 하여 문제를 해결한다.</p>

<h2 id="선형구조와-비선형구조의-전체탐색">선형구조와 비선형구조의 전체탐색</h2>

<p>선형구조의 전체탐색은 반복문을 이용하여 접근할 수 있다.<br />
1차 원 뿐만 아니라 2차원 이상의 다차원 구조에 대해서도 선형구조로 탐색할 수 있다.</p>

<p>비선형구조의 전체탐색은 문제해결의 가장 기본이 되는 알고리즘 설계법인 백트래킹을 이용한다.<br />
백트래킹 기법은 재귀함수를 이용하여 간단하게 구현할 수 있고, 다양한 문제를 해결하는데 많이 응용되는 방법이므로 반드시 익혀둘 필요가 있다.</p>

<p>주어진 문제들을 통하여 선형구조, 비선형구조의 전체탐색법을 익힐 수 있도록 하자.</p>

<h2 id="선형-구조에서의-전체탐색">선형 구조에서의 전체탐색</h2>

<h3 id="약수의-합">약수의 합</h3>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>한 정수 n을 입력받아서 n의 모든 약수의 합을 구하는 프로그램을 작성하시오.  

예를 들어 10의 약수는 1, 2, 5, 10이므로 이 값들의 합인 18이 10의 약수의 합이 된다.  

입력  
첫 번째 줄에 정수 n이 입력된다. (단, 1 &lt;= n &lt;= 100,000)  

출력  
n의 약수의 합을 출력한다.
-------------------
입력 예
10

출력 예
18
</code></pre></div></div>

<p>이 문제는 기본적으로 수학적인 아이디어를 이용하여 해결할 수 있는 문제이지만 이 단 원에서는 전체탐색법을 다루는 단원이므로 전체탐색법으로 해결해보자.</p>

<p>일단 n을 입력받으면 1부터 n까지의 모든 수를 차례로 반복문을 이용하여 선형으로 탐색하면서 n의 약수들을 검사한다. 만약 현재 탐색 중인 수가 n의 약수라면 누적하여 구할 수 있다. 이렇게 구한다면 계산량은 O(n)이 된다. 이 문제에서는 n의 최댓값이 100,000이므로 충분히 해결할 수 있는 문제가 된다.</p>

<p>어떤 수 x가 n의 약수라면 다음 조건을 이용해 구할 수 있다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>n % x == 0
</code></pre></div></div>

<p>이를 이용하여 문제를 해결한 소스코드는 다음과 같다.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
</span><span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">solve</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">ans</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span>
        <span class="k">if</span><span class="p">(</span><span class="n">n</span><span class="o">%</span><span class="n">i</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">ans</span><span class="o">+=</span><span class="n">i</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">solve</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이문제는 이와 같은 방법으로 쉽게 해결할 수 있으나, n이 10억 이상의 값으로 커질 때는 다른 방법을 생각해야 한다.<br />
아마 다른 포스트에서 다루게 될 것이므로 한 번 생각해보자.</p>

<h3 id="최댓값">최댓값</h3>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>다음과 같이 9×9 격자판에 쓰여진 81개의 자연수가 주어질 때, 이들 중 최댓 값을 찾고  
그 최댓값이 몇 행 몇 열에 위치한 수인지 구하는 프로그램을 작성하시오.  

예를 들어, 다음과 같이 81개의 수가 주어질 경우에는 이들 중 최댓값은 90이고, 이 값은 5행 7열에 위치한다.

  열 1  2  3  4  5  6  7  8  9
행
1    3 23 85 34 17 74 25 52 65
2   10  7 39 42 88 52 14 72 63
3   87 42 18 78 53 45 18 84 53
4   34 28 64 85 12 16 75 36 55
5   21 77 45 35 28 75 90 76  1
6   25 87 65 15 28 11 37 28 74
7   65 27 75 41  7 89 78 64 39
8   47 47 70 45 23 65  3 41 44
9   87 13 82 38 31 12 29 29 80

입력  
첫째 줄부터 아홉째 줄까지 한 줄에 아홉 개씩 자연수가 주어진다. 주어지는 자연 수는 100보다 작다.

출력  
첫째 줄에 최댓값을 출력하고, 둘째 줄에 최댓값이 위치한 행 번호와 열 번호를 빈칸을 사이에 두고 차례로 출력한다.  
최댓값이 두 개 이상인 경우 그 중 한 곳의 위치를 출력한다.
----------------------------
입력 예  
3 23 85 34 17 74 25 52 65
10 7 39 42 88 52 14 72 63
87 42 18 78 53 45 18 84 53
34 28 64 85 12 16 75 36 55
21 77 45 35 28 75 90 76 1
25 87 65 15 28 11 37 28 74
65 27 75 41 7 89 78 64 39
47 47 70 45 23 65 3 41 44
87 13 82 38 31 12 29 29 80

출력 예
90 57

</code></pre></div></div>

<p>이 문제는 2차원 구조를 선형으로 모두 탐색하면 쉽게 해결할 수 있는 문제이다.<br />
2차원 구조는 행 우선으로 탐색하는 방법과 열 우선으로 탐색하는 방법이 있는데, 이 문제는 어떤 방법으로 탐색해도 관계없으며, 일반적으로는 행 우선 탐색을 많이 사용한다.</p>

<p>다음은 행 우선을 반복문으로 구현한 소스코드이다.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">row</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">row</span><span class="o">&lt;</span><span class="mi">5</span><span class="p">;</span> <span class="n">row</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">col</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">col</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">;</span> <span class="n">col</span><span class="o">++</span><span class="p">)</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"[%d, %d]"</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">);</span>
    <span class="n">uts</span><span class="p">(</span><span class="s">""</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이제 문제를 해결하는 방법에 대해서 알아보자.</p>

<p>탐색하기 전 먼저 해를 저장할 변수인 ans를 0으로 초기화한다. 여기서 주의할 점은 각 원소들 중 음수값이 존재할 경우 최댓값을 구하기 위해 ans를 0으로 초기화하면 안 된다는 점이다. 이 문제는 음수값이 존재하지 않기 때문에 ans를 0으로 초기화하고 문제를 해결한다.</p>

<p>참고로 어떤 변수에 값을 초기화하는 몇 가지 방법을 소개한다. 일단 int형의 최댓값은 0x7fffffff(2,147,483,647)이며, 최솟값은 0x80000000(-2,147,483,648)이다. 엄밀하게 최대, 최소를 지정할 때 이 값을 이용하면 되며, 16진법을 이용하면 쉽게 처리할 수 있다.</p>

<p>여기서 주의할 점은 위 값들을 설정한 후 값을 증가시키거나 감소시키면 오버플로 (overflow)로 인하여 답이 잘못될 수 있다.<br />
예를 들어 다음 명령을 보자.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="mh">0x7fffffff</span><span class="p">;</span>
<span class="n">max</span><span class="o">=</span><span class="n">max</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
</code></pre></div></div>

<p>위 예의 경우에 max값이 최댓값이었는데, 여기서 1을 증가하면 오버플로가 발생하 여 max값은 음수가 된다.<br />
따라서 이런 점을 방지하기 위하여 적어도 2배 정도라 하더 라도 오버플로가 발생하지 않도록 처리하는 경우가 많다.<br />
이럴 때는 주로 최댓값을 987654321 등의 자릿수도 쉽게 알 수 있고 2배를 하더라도 정수 범위에 있는 수 등을 활용하는 경우가 많다.  문제에 따라서는 탐색하고자 하는 데이터 중에서 임의의 한 값 을 최댓값 또는 최솟값으로 결정하는 방법도 있다.</p>

<p>위 문제를 해결하는 소스코드는 다음과 같다.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
</span><span class="kt">int</span> <span class="n">A</span><span class="p">[</span><span class="mi">10</span><span class="p">][</span><span class="mi">10</span><span class="p">],</span> <span class="n">ans</span><span class="p">,</span> <span class="n">mi</span><span class="p">,</span> <span class="n">mj</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">input</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">9</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="mi">9</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
        <span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]);</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">solve</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">9</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="mi">9</span> <span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
            <span class="k">if</span><span class="p">(</span><span class="n">ans</span> <span class="o">&lt;</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">])</span> <span class="p">{</span>
                <span class="n">ans</span><span class="o">=</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
                <span class="n">mi</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">mj</span><span class="o">=</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">input</span><span class="p">();</span>
    <span class="n">solve</span><span class="p">();</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">%d %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ans</span><span class="p">,</span> <span class="n">mi</span><span class="p">,</span> <span class="n">mj</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>가장 일반적으로 해결할 수 있는 방법이고 이 경우 계산량은 O(row x column)이 된다.<br />
이를 보다 효율적으로 바꾸기 위해서, 입력받으면서 바로 처리할 수도 있으며, ans, mi, mj를 모 두 쓰지 않고 mi, mj만 가지고 처리하는 방법을 소개한다.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
</span><span class="kt">int</span> <span class="n">A</span><span class="p">[</span><span class="mi">10</span><span class="p">][</span><span class="mi">10</span><span class="p">],</span> <span class="n">mi</span><span class="p">,</span> <span class="n">mj</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">input_solve</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">9</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="mi">9</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]);</span>
            <span class="k">if</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">mi</span><span class="p">][</span><span class="n">mj</span><span class="p">]</span><span class="o">&lt;</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">])</span>
                <span class="n">mi</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">mj</span><span class="o">=</span><span class="n">j</span><span class="p">;</span>
        <span class="p">}</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">%d %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">A</span><span class="p">[</span><span class="n">mi</span><span class="p">][</span><span class="n">mj</span><span class="p">],</span> <span class="n">mi</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">mj</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="고기잡이">고기잡이</h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>우리나라 최고의 어부 정올이가 이번에 네모네모 배 고기잡이 대회에 참가한다.  

이 대회에는 3개의 라운드가 있는데, 첫 번째 라운드는 1차원 형태로 표현될 수 있는 작은 연못에서
길쭉한 그물을 던져서 최대한 많은 고기를 잡는 것이 목적이다.  

1라운드의 예를 들면 연못의 크기가 1*6이고 물고기의 위치와 가치가 다음과 같다고 하자.  

1 0 2 0 4 3

여기서 그물의 크기는 1*3이라고 할 때, 잡을 수 있는 방법은
(1 0 2), (0 2 0), (2 0 4), (0 4 3)의 4가지 방법이 있다.  

이 중 가장 이득을 보는 방법은 마지막 방법 0 + 4 + 3 = 7이다.
따라서 주어진 경우의 최대 이득은 7이 된다.
정올이는 최대한 가치가 큰 물고기를 잡아서 우승하고 싶어 한다.  

연못의 폭과 각 칸에 있는 물고기의 가치, 그물의 가로의 길이와 세로의 길이가 주어질 때,
잡을 수 있는 물고기의 최대이득을 구하는 프로그램을 작성하시오.  

입력
첫 번째 줄에 연못의 폭 N이 입력된다. ( N &lt;= 100 인 자연수 )
두 번째 줄에 그물의 폭 W가 입력된다. ( W &lt;= N 인 자연수 )
세 번째 줄 W개의 물고기의 가치가 공백으로 구분되어 주어진다. 각 물고기의 가
치는 7이하의 자연수이다. 0일 경우에는 물고기가 없다는 의미이다.

출력
잡을 수 있는 물고기의 최대 가치를 출력한다.
---------------------------------
입력 예
6
3
1 0 2 0 4 3 

출력 예
7
</code></pre></div></div>

<p>이 문제는 전체탐색법을 이용하여 간단하게 해결할 수 있다.<br />
폭이 n인 연못에서 폭이 w인 그물을 던졌을 때 최대 이득을 얻을 수 있는 구간을 찾는 문제이다.<br />
가장 단순한 방 법으로 n개의 주어진 수들 중 연속된 w개의 수들을 탐색하여 합을 구한 다음 최댓값을 갱신하는 방법으로 접근할 수 있다.<br />
먼저 첫 번째 데이터부터 탐색하여 w개의 합을 구한 다음 최댓값을 갱신하고, 두 번째 데이터부터 탐색하여 w개의 합을 구하여 최댓값을 갱신한다. 이런 방법으로 모든 구간을 전체탐색법으로 확인할 수 있다.</p>

<p>입출력 예의 경우 다음과 같은 과정으로 해를 구해나간다.</p>

<p><img src="/assets/images/creativealgorithm23.png" alt="Alt text" width="600px" height="300px" /></p>

<p>위의 과정을 보면 탐색을 시작하는 지점이 0번으로부터 시작하여 1씩 증가하는 것을 알 수 있으며, 시작점을 지정하면 그물의 폭인 w만큼 탐색을 진행한다. 따라서 마지막 탐색 의 시작 지점은 n - w + 1 이 된다. 핵심 탐색 부분을 구현하면 다음과 같다.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="err">‐</span><span class="n">W</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">W</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%d "</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">);</span>
    <span class="n">puts</span><span class="p">(</span><span class="s">""</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>n = 8 이고 w = 5 일 때, 위 탐색방법의 출력결과는 결과는 다음과 같다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0 1 2 3 4
1 2 3 4 5
2 3 4 5 6
3 4 5 6 7
</code></pre></div></div>

<p>즉, [0, 4] 구간, [1, 5]구간, [2, 6]구간, [3, 7]구간으로 모두 4번을 검사한다.</p>

<p>위 소스코드에서 n - w + 1 을 생각하기 어려운 경우에는 배열을 좀 더 크게 잡은 후 다음과 같이 작성해도 관계없다.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">W</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%d "</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">);</span>
    <span class="n">puts</span><span class="p">(</span><span class="s">""</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>위와 같이 작성하면 생각하기 쉽기 때문에 빠른 시간에 코딩이 가능하다. 위의 코드의 출력결과는 다음과 같다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0 1 2 3 4
1 2 3 4 5 
2 3 4 5 6
3 4 5 6 7
4 5 6 7 8 
5 6 7 8 9
6 7 8 9 10 
7 8 9 10 11
</code></pre></div></div>

<p>위의 아이디어 들을 이용하여 문제를 해결한 소스코드는 다음과 같다.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
</span><span class="kt">int</span> <span class="n">data</span><span class="p">[</span><span class="mi">101</span><span class="p">],</span> <span class="n">N</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">scanf</span><span class="p">(</span><span class="s">"%d%d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">N</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">W</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="n">data</span><span class="o">+</span><span class="n">i</span><span class="p">);</span>

    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="o">+</span><span class="n">W</span><span class="err">‐</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">sum</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">W</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
            <span class="n">sum</span><span class="o">+=</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">];</span>
        <span class="k">if</span><span class="p">(</span><span class="n">sum</span><span class="o">&gt;</span><span class="n">ans</span><span class="p">)</span> <span class="n">ans</span><span class="o">=</span><span class="n">sum</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="n">ans</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이 알고리즘의 계산량은 1~N의 각 위치에 대해서 W만큼 탐색을 하므로 O(NW)가 됨 을 알 수 있다.<br />
문제에서 제시한 N의 최대치가 100,000이 입력되고 그물의 크기가 적당히 크면 수행시 간이 많이 걸리므로 좀 더 효율적인 알고리즘이 필요하다.</p>

<h2 id="비선형-구조에서의-전체탐색">비선형 구조에서의 전체탐색</h2>

<h3 id="계단-오르기">계단 오르기</h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>길동이는 n개의 단으로 구성된 계단을 오르려고 한다.  
길동이는 계단을 오를 때 기분에 따라서 한 번에 1단 또는 2단을 올라갈 수 있다.  
계단의 크기 n이 주어질 때, 길동이가 이 계단을 올라갈 수 있는 모든 경우의 수를  
구하는 프로그램을 작성하시오.  

만약 계단이 3개라면 길동이는 1, 1, 1로 올라가는 법과 1, 2로 올라가는 법, 2, 1로 
올라가는 법의 3가지 서로 다른 방법이 있다.  
-----------------------------------------
입력
계단의 수 n이 입력된다(단 n은 20보다 작은 자연수).  

출력
길동이가 계단을 오르는 모든 방법의 수를 출력한다.

입력 예         출력 예
3              3
 
</code></pre></div></div>

<p>이 문제도 비선형구조로 전체탐색을 하여 해를 구할 수 있다.<br />
현재 상태에서 1칸 또는 2 칸을 올라갈 수 있으므로, 탐색구조를 다음과 같이 설정할 수 있다.</p>

<p>단, 주의할 점은 정확 하게 n칸에 도착했을 때만 한 가지 경우로 처리해야한다는 점이다.<br />
예를 들어 도착점까지 한 칸 남았을 경우에는 2칸을 올라갈 수 없다.</p>

<p><img src="/assets/images/creativealgorithm24.png" alt="Alt text" width="600px" height="300px" /></p>

<p>위의 탐색 과정으로 5칸의 계단을 오르는 과정을 보면 다음과 같다.</p>

<p><img src="/assets/images/creativealgorithm25.png" alt="Alt text" width="600px" height="300px" /></p>

<p>위와 같은 트리를 구성하면서 전체탐색을 하면 n은 5일 때, 방법은 8임을 알 수 있다.<br />
이와 같은 구조의 탐색을 소스코드로 구현하면 다음과 같다.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">ans</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">solve</span><span class="p">(</span><span class="kt">int</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">v</span><span class="o">&gt;</span><span class="n">n</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span> <span class="c1">// --- (a)</span>
    <span class="k">if</span><span class="p">(</span><span class="n">v</span><span class="o">==</span><span class="n">n</span><span class="p">){</span> <span class="c1">// 현재 n칸이면 </span>
        <span class="n">ans</span><span class="o">++</span><span class="p">;</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">solve</span><span class="p">(</span><span class="n">v</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// 1칸 오르기</span>
    <span class="n">solve</span><span class="p">(</span><span class="n">v</span><span class="o">+</span><span class="mi">2</span><span class="p">);</span> <span class="c1">// 2칸 오르기</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">);</span> 
    <span class="n">solve</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> 
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ans</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p class="notice--warning"><strong>Warning:</strong> (a)행의 조건은 마지막 계단을 넘어가는 경우를 처리한다. 이 구문이 없으면 무한 재귀에 빠지게 된다.</p>

<h3 id="거스름-돈">거스름 돈</h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>여러분은 실력을 인정받아 전 세계적으로 사용할 수 있는 자동판매기용 프로그램의  
개발을 의뢰받았다. 거스름돈에 사용될 동전의 수를 최소화하는 것이다. 

입력으로 거슬러 줘야할 돈의 액수와 그 나라에서 이용하는 동전의 가짓수  
그리고 동전의 종류가 들어오면 여러 가지 방법들 중 가장 적은 동전의 수를 구하는  
프로그램을 작성하시오.

-----------------------------------------
입력
첫 번째 줄에는 거슬러 줘야할 돈의 액수 m이 입력된다.  
( 10 &lt;= m &lt;= 10,000 )  
다음 줄에는 그 나라에서 사용되는 동전의 종류의 수 n이 입력된다.  
( 1 &lt;= n &lt;= 10 )  
마지막 줄에는 동전의 수만큼의 동전 액수가 오름차순으로 입력된다.  
( 10 &lt;= 액수 &lt;= m )  

출력
최소의 동전의 수를 출력한다.  

입력 예
730
5
10 50 100 500 1250

출력 예
6
</code></pre></div></div>

<p>이 문제는 매우 잘 알려진 유명한 문제 중 하나로 다양한 방법으로 해결할 수 있는 대표적인 문제이다. 이 단원에서는 전체탐색법을 기반으로 하여 해결하는 방법에 대해서 소개한다. 대부분의 문제들에서도 마찬가지지만 문제를 전체탐색으로 구조화하는 방법에 따라 해법의 계산량이 달라질 수 있다.</p>

<p>이 문제에서는 2가지 서로 다른 구조화로 해결하는 방법을 소개한다. 먼저 첫 번째 방법은 문제의 상태를 지금까지 지불한 액수로 설정하고, 서로 다른 동전 1개를 이용하여 지불하는 경우를 간선으로 생각할 수 있다.</p>

<p>이 방법으로 구조화하는 방법은 다음 그림과 같다. 이 때 $x$의 값은 지금까지 지불한 액수이며 사용 가능한 동전은 4가지 종류로 10원, 50원, 100원, 500원일 때를 가정한 것이다.</p>

<p><img src="/assets/images/creativealgorithm26.png" alt="Alt text" width="600px" height="300px" /></p>

<p>처음에 0원으로 출발하여 각 동전을 지불해 나가며, 지불할 금액과 일치할 때의 깊이가 지불한 동전의 개수이므로, 지불할 금액과 일치하는 최소 깊이를 구하는 문제가 된다. 만약 지불할 금액과 일치했거나 금액을 초과했을 경우에는 백트랙하면서 탐색을 진행하도록 코드를 작성하면 된다.</p>

<p>지불해야할 금액이 120원이고, 사용가능한 동전이 30원, 50원, 60원, 100원일 때의 전체 탐색구조는 다음과 같다. 먼저 처음 깊이 1까지의 구조이다.</p>

<p><img src="/assets/images/creativealgorithm27.png" alt="Alt text" width="600px" height="300px" /></p>

<p>다음은 30원 이하의 정점들의 전체적인 구조이다. 파란색 정점은 120원 지불에 성공한 것을 나타낸다.</p>

<p><img src="/assets/images/creativealgorithm28.png" alt="Alt text" width="600px" height="300px" /></p>

<p>계속해서 50원과 60원 정점의 전체 탐색구조를 나타낸다. 100원 이하에서는 더 이상의 탐색이 불가능하다.</p>

<p><img src="/assets/images/creativealgorithm29.png" alt="Alt text" width="600px" height="300px" /></p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include&lt;stdio.h&gt;
</span><span class="kt">int</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">coin</span><span class="p">[</span><span class="mi">10</span><span class="p">],</span> <span class="n">ans</span><span class="o">=</span><span class="mi">987654321</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">solve</span><span class="p">(</span><span class="kt">int</span> <span class="n">mon</span><span class="p">,</span> <span class="kt">int</span> <span class="n">d</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">mon</span><span class="o">&gt;</span><span class="n">m</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">mon</span><span class="o">==</span><span class="n">m</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="n">d</span><span class="o">&lt;</span><span class="n">ans</span><span class="p">)</span> <span class="n">ans</span><span class="o">=</span><span class="n">d</span><span class="p">;</span> 
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">solve</span><span class="p">(</span> <span class="n">mon</span><span class="o">+</span><span class="n">coin</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">d</span><span class="o">+</span><span class="mi">1</span> <span class="p">);</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">scanf</span><span class="p">(</span><span class="s">"%d %d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span>
        <span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="n">coin</span><span class="o">+</span><span class="n">i</span><span class="p">);</span> 
    <span class="n">solve</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> 
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ans</span><span class="p">);</span> 
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>위 프로그램에서의 solve()함수는 다음과 같은 상태를 표현하고 있다.</p>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>solve(mon, d) = “d개의 동전으로 mon원을 사용한 상태”
</code></pre></div></div>

<p>이 방법은 정확하게 해를 구할 수는 있으나 이론상으로 최대 금액이 10,000원이고 최소 액수가 10원이므로 최대 깊이가 1,000까지 갈 수 있기 때문에 시간 내에 해결할 수 없다.</p>

<p>시간을 줄이기 위한 다양한 방법이 있지만, 이번에는 다른 구조를 이용하여 해결할 수 있는 방법을 소개한다. 탐색구조를 어떻게 설계하느냐에 따라서 해법의 계산량이 달라질 수 있다는 것을 알고, 문제를 해결할 때, 탐색구조를 어떻게 구성해야하는지 먼저 고민하는 것이 중요하다.</p>

<p>이번에 소개하는 구조는 이전과는 달리 같은 깊이에서는 같은 동전으로만 지불하는 방법으로 구조를 구성한다. 한 깊이에서 간선의 수는 해당 깊이의 동전을 0개로부터 해당 금액을 최대한 지불할 수 있는 최대한의 수로 설정하여 진행한다. 다음 그림을 통하여 자세히 알아보자. 동전은 30원, 50원, 60원, 100원이다.</p>

<p><img src="/assets/images/creativealgorithm30.png" alt="Alt text" width="600px" height="300px" /></p>

<p>실제 지불할 금액은 120원, 지불가능한 동전의 수는 50원, 60원, 100원일 때의 경우 전체 구조는 다음과 같다.</p>

<p><img src="/assets/images/creativealgorithm31.png" alt="Alt text" width="600px" height="300px" /></p>

<p>이 방법으로 구현한 소스코드는 다음과 같다.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">coin</span><span class="p">[</span><span class="mi">10</span><span class="p">],</span> <span class="n">ans</span><span class="o">=</span><span class="mi">987654321</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">solve</span><span class="p">(</span><span class="kt">int</span> <span class="n">mon</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cnt</span><span class="p">)</span> <span class="p">{</span> 
    <span class="k">if</span><span class="p">(</span><span class="n">mon</span><span class="o">==</span><span class="n">m</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="n">ans</span><span class="o">&gt;</span><span class="n">cnt</span><span class="p">)</span> <span class="n">ans</span><span class="o">=</span><span class="n">cnt</span><span class="p">;</span>
        <span class="k">return</span><span class="p">;</span> <span class="c1">// 백트랙</span>
    <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="n">k</span><span class="o">==</span><span class="n">n</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span> <span class="c1">// 더 이상 깊이 진행 X, 백트랙</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">mon</span><span class="o">+</span><span class="n">coin</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="c1">// 조건 만족하지 않을 시 백트랙</span>
        <span class="n">solve</span><span class="p">(</span><span class="n">mon</span><span class="o">+</span><span class="n">coin</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">cnt</span><span class="o">+</span><span class="n">i</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">scanf</span><span class="p">(</span><span class="s">"%d %d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">);</span> 
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> 
        <span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="n">coin</span><span class="o">+</span><span class="n">i</span><span class="p">);</span>
    <span class="n">solve</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ans</span><span class="p">);</span> 
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>위 프로그램에서의 solve()함수는 다음과 같은 상태를 표현하고 있다.</p>

<p><code class="highlighter-rouge">solve(mon, k, cnt )= “k번째 이하의 동전을 cnt개 사용하여 mon원을 거슬러 준 상태”</code></p>

<p>이 방법은 앞에서 시도했던 방법보다 속도가 획기적으로 빨라진다. 그 이유는 전체 상태를 그려보면 앞의 방법보다 이번에 구조화한 방법의 정점의 수가 훨씬 적기 때문이다. 이와 같이 구조를 어떻게 설계하느냐에 따라 알고리즘의 계산량이 달라지기 때문에, 문제를 해결할 때 먼저 최적의 구조를 설계하는 것이 중요하다.</p>

<h3 id="연구활동-가는-길">연구활동 가는 길</h3>

<p><img src="/assets/images/creativealgorithm18.png" alt="Alt text" width="600px" height="300px" /></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*위의 그래프를 참고하여 문제를 풀어보자*

정올이는 GSHS에서 연구활동 교수님을 뵈러 A대학교를 가려고 한다.
출발점과 도착점을 포함하여 경유하는 지역 n개, 한 지역에서 다른 지역으로 가는 방법이 총 m 개이며 
GSHS는 지역 1이고 A대학교는 지역 n이라고 할 때 대학까지 최소 비용을 구하시오.

단, n은 10 이하, m은 30 이하, 그리고 한 지역에서 다른 지역으로 
가는 데에 필요한 비용은 모두 200 이하 양의 정수이며
한 지역에서 다른 지역으로 가는 어떠한 방법이 존재하면 
같은 방법과 비용을 통해 역방향으로 갈 수 있다.

위의 그래프는 예를 보여준다.
(단, 정점 a -&gt; 정점 b로의 간선이 여러 개 있을 수 있으 며, 자기 자신으로 가는 정점을 가질 수도 있다.)

최소 비용이 드는 경로 : 1→3→5→7, 최소 비용 : 69+59+21=149

입력
첫 번째 줄에는 정점의 수 n과 간선의 수 m이 공백으로 구분되어 입력된다.
다음 줄부터 m개의 줄에 걸쳐서 두 정점의 번호와 가중치가 입력된다. (자기 간선, 멀티 간선이 있을 수 있다.)

출력
대학까지 가는 데 드는 최소 비용을 출력한다. 만약 갈 수 없다면 “-1”을 출력.

----------------------------
입력 예 
7 11
1 2 47
1 3 69
2 4 57
2 5 124
3 4 37
3 5 59
3 6 86
4 6 27
4 7 94
5 7 21
6 7 40

출력 예
149

</code></pre></div></div>

<p>이 문제는 그래프 상의 최단경로를 구하는 매우 유명한 문제이다.<br />
이 문제를 해결하는 알고리즘은 여러가지가 알려져 있지만, 어려운 알고리즘을 모르더라도 전체탐색법을 통하여 해결할 수 있다.</p>

<p>이 문제는 그래프 구조이므로 비선형탐색법으로 해를 구할 수 있다.<br />
먼저 출발정점에서 깊이우선탐색을 이용하여 출발점으로부터 도착점까지 가능한 모든 경로에 대해서 구해본다.</p>

<p>하나의 경로를 구할 때마다 해를 갱신하면서 최종적으로 가장 적합한 해를 출력한다.<br />
주어진 예를 통하여 전체탐색하는 과정을 간단하게 살펴보자.</p>

<p><img src="/assets/images/creativealgorithm19.png" alt="Alt text" width="700px" height="700px" /></p>

<p><img src="/assets/images/creativealgorithm20.png" alt="Alt text" width="700px" height="1000px" /></p>

<p><img src="/assets/images/creativealgorithm21.png" alt="Alt text" width="700px" height="900px" /></p>

<p class="notice--warning"><strong>Warning:</strong>  중간에 몇개의 과정이 생략되었음에 유의</p>

<p><img src="/assets/images/creativealgorithm22.png" alt="Alt text" width="700px" height="700px" /></p>

<p>따라서 위의 경우 전체탐색법으로 탐색한 결과 최소 이동거리는 149가 됨을 알 수 있다.<br />
위의 과정과 같은 방법으로 코딩한 결과는 다음과 같다.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include&lt;stdio.h&gt;
</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">G</span><span class="p">[</span><span class="mi">11</span><span class="p">][</span><span class="mi">11</span><span class="p">],</span> <span class="n">sol</span> <span class="o">=</span> <span class="mh">0x7fffffff</span><span class="p">,</span> <span class="n">chk</span><span class="p">[</span><span class="mi">11</span><span class="p">];</span>
<span class="kt">void</span> <span class="nf">solve</span><span class="p">(</span><span class="kt">int</span> <span class="n">V</span><span class="p">,</span> <span class="kt">int</span> <span class="n">W</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">V</span><span class="o">==</span><span class="n">n</span><span class="p">){</span> <span class="c1">// 도착 여부를 확인하여 현재 정점이 도착점이라면</span>
        <span class="k">if</span><span class="p">(</span><span class="n">W</span><span class="o">&lt;</span><span class="n">sol</span><span class="p">)</span> <span class="n">sol</span><span class="o">=</span><span class="n">W</span><span class="p">;</span> <span class="c1">// 더 좋은 해가 있으면 해를 갱신</span>
            <span class="k">return</span><span class="p">;</span> <span class="c1">// 백트랙</span>
    <span class="p">}</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">chk</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">G</span><span class="p">[</span><span class="n">V</span><span class="p">][</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
            <span class="n">chk</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// 다음 정점으로 진행할 때 다음 방문할 정점을 체크</span>
            <span class="n">solve</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">W</span><span class="o">+</span><span class="n">G</span><span class="p">[</span><span class="n">V</span><span class="p">][</span><span class="n">i</span><span class="p">]);</span> <span class="c1">// 다음 정점으로 진행</span>
            <span class="n">chk</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="c1">// 백트랙해서 돌아오면 체크를 해제</span>
        <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">scanf</span><span class="p">(</span><span class="s">"%d %d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">s</span><span class="p">,</span><span class="n">e</span><span class="p">,</span><span class="n">w</span><span class="p">;</span>
        <span class="n">scanf</span><span class="p">(</span><span class="s">"%d %d %d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">e</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">w</span><span class="p">);</span>
        <span class="n">G</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">e</span><span class="p">]</span><span class="o">=</span><span class="n">G</span><span class="p">[</span><span class="n">e</span><span class="p">][</span><span class="n">s</span><span class="p">]</span><span class="o">=</span><span class="n">w</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">solve</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">sol</span><span class="o">==</span><span class="mh">0x7fffffff</span> <span class="o">?</span> <span class="err">‐</span><span class="mi">1</span><span class="o">:</span><span class="n">sol</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이 문제의 경우 정점과 간선의 수가 많지 않으므로 인접행렬로도 충분히 처리가 가능하기 때문에 인접행렬로 처리한다.<br />
solve(a, b)는 현재 a정점까지 방문한 상태로 이동거리가 b라고 정의하고 있으며, chk배 열이 현재까지 방문한 정점들의 정보를 가지고 있다.<br />
다음 정점으로 진행할 때 <code class="highlighter-rouge">chk[i]=1</code> 같이 chk배열에 다음 방문할 정점을 체크하고 만약 백트랙해서 돌아온다면, <code class="highlighter-rouge">chk[i]=0</code> 같이 체크를 해제하며 전체탐색을 진행한다.</p>

<p><code class="highlighter-rouge">if(V==n)</code> 부분에서 도착 여부를 확인하여 현재 정점이 도착점이라면, 지금까지의 이동 거리와 현재 까지 구한 해를 비교하여 더 좋은 해가 있으면 해를 갱신한다. 이와 같이 작성할 경우 도시의 수가 n개라고 할 때 O(n!)의 계산이 필요하다.</p>

<p>다른 포스트에서 탐색배제를 이용하여 계산복잡도를 향상해본다.</p>

<h3 id="references">References</h3>

<ul>
  <li>문제해결을 위한 창의적 알고리즘</li>
</ul>

        
      </section>

      <footer class="page__meta">
        
        
  


  
  
  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> Tags: </strong>
    <span itemprop="keywords">
    
      
      
      <a href="/tags/#bfs" class="page__taxonomy-item" rel="tag">BFS</a><span class="sep">, </span>
    
      
      
      <a href="/tags/#brute-force" class="page__taxonomy-item" rel="tag">Brute force</a><span class="sep">, </span>
    
      
      
      <a href="/tags/#data-structure" class="page__taxonomy-item" rel="tag">Data structure</a><span class="sep">, </span>
    
      
      
      <a href="/tags/#dfs" class="page__taxonomy-item" rel="tag">DFS</a><span class="sep">, </span>
    
      
      
      <a href="/tags/#programming" class="page__taxonomy-item" rel="tag">programming</a>
    
    </span>
  </p>




  


  
  
  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> Categories: </strong>
    <span itemprop="keywords">
    
      
      
      <a href="/categories/#algorithm" class="page__taxonomy-item" rel="tag">Algorithm</a>
    
    </span>
  </p>


        
          <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time datetime="2019-05-10">May 10, 2019</time></p>
        
      </footer>

      <section class="page__share">
  
    <h4 class="page__share-title">Share on</h4>
  

  <a href="https://twitter.com/intent/tweet?text=%EC%A0%84%EC%B2%B4%ED%83%90%EC%83%89%EB%B2%95%28Brute+force%29%20http%3A%2F%2Flocalhost%3A4000%2Falgorithm%2F%25EC%25A0%2584%25EC%25B2%25B4%25ED%2583%2590%25EC%2583%2589%25EB%25B2%2595%2F" class="btn btn--twitter" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Twitter"><i class="fab fa-fw fa-twitter" aria-hidden="true"></i><span> Twitter</span></a>

  <a href="https://www.facebook.com/sharer/sharer.php?u=http%3A%2F%2Flocalhost%3A4000%2Falgorithm%2F%25EC%25A0%2584%25EC%25B2%25B4%25ED%2583%2590%25EC%2583%2589%25EB%25B2%2595%2F" class="btn btn--facebook" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Facebook"><i class="fab fa-fw fa-facebook" aria-hidden="true"></i><span> Facebook</span></a>

  <a href="https://www.linkedin.com/shareArticle?mini=true&url=http%3A%2F%2Flocalhost%3A4000%2Falgorithm%2F%25EC%25A0%2584%25EC%25B2%25B4%25ED%2583%2590%25EC%2583%2589%25EB%25B2%2595%2F" class="btn btn--linkedin" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on LinkedIn"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i><span> LinkedIn</span></a>
</section>


      
  <nav class="pagination">
    
      <a href="/algorithm/eratosthenes-sieve/" class="pagination--pager" title="에라토스테네스의 체(Eratosthenes’s Sieve)
">Previous</a>
    
    
      <a href="/algorithm/%ED%83%90%EC%83%89%EA%B3%B5%EA%B0%84%EC%9D%98-%EB%B0%B0%EC%A0%9C/" class="pagination--pager" title="탐색공간의 배제(Exclusion of Search Space)
">Next</a>
    
  </nav>

    </div>

    
  </article>

  
  
    <div class="page__related">
      <h4 class="page__related-title">You may also enjoy</h4>
      <div class="grid__wrapper">
        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
      <div class="archive__item-teaser">
        <img src=
          
            "/assets/images/withoutunionbylank.png"
          
          alt="">
      </div>
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/data%20structure/unionfind/" rel="permalink">유니온 파인드(Union Find, Disjoint Set)
</a>
      
    </h2>
    <!--
       devinlife comments :
         아키이브 싱글 페이지(ex. 카테고리)에 각 포스트 제목 밑에 Updated 시간 표기
         기존에는 read_time이 표기. read_time -> date 변경

    
      <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  6 minute read

</p>
    
    -->
    
       <p class="page__meta"><i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i> May 14 2019</p>
    
    <p class="archive__item-excerpt" itemprop="description">중복되지 않는 부분집합들의 원소 정보를 조작하고 저장하는 자료구조
</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
      <div class="archive__item-teaser">
        <img src=
          
            "/assets/images/creativealgorithm33.png"
          
          alt="">
      </div>
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/algorithm/%ED%83%90%EC%83%89%EA%B3%B5%EA%B0%84%EC%9D%98-%EB%B0%B0%EC%A0%9C/" rel="permalink">탐색공간의 배제(Exclusion of Search Space)
</a>
      
    </h2>
    <!--
       devinlife comments :
         아키이브 싱글 페이지(ex. 카테고리)에 각 포스트 제목 밑에 Updated 시간 표기
         기존에는 read_time이 표기. read_time -> date 변경

    
      <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  14 minute read

</p>
    
    -->
    
       <p class="page__meta"><i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i> April 21 2019</p>
    
    <p class="archive__item-excerpt" itemprop="description">전체탐색에서 불필요한 공간을 탐색하지 않음으로써 알고리즘의 효율을 향상하는 방법
</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
      <div class="archive__item-teaser">
        <img src=
          
            "/assets/images/Sieve_of_Eratosthenes_animation.gif"
          
          alt="">
      </div>
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/algorithm/eratosthenes-sieve/" rel="permalink">에라토스테네스의 체(Eratosthenes’s Sieve)
</a>
      
    </h2>
    <!--
       devinlife comments :
         아키이브 싱글 페이지(ex. 카테고리)에 각 포스트 제목 밑에 Updated 시간 표기
         기존에는 read_time이 표기. read_time -> date 변경

    
      <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  4 minute read

</p>
    
    -->
    
       <p class="page__meta"><i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i> April 16 2019</p>
    
    <p class="archive__item-excerpt" itemprop="description">소수의 여부를 보다 효율적으로 알 수 있는 알고리즘
</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
      <div class="archive__item-teaser">
        <img src=
          
            "/assets/images/creativealgorithm1.png"
          
          alt="">
      </div>
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/algorithm/%EB%B9%84%EC%84%A0%ED%98%95%EA%B5%AC%EC%A1%B0%EC%9D%98-%ED%83%90%EC%83%89/" rel="permalink">비선형 구조와 탐색(Non-linear Structure and Search)
</a>
      
    </h2>
    <!--
       devinlife comments :
         아키이브 싱글 페이지(ex. 카테고리)에 각 포스트 제목 밑에 Updated 시간 표기
         기존에는 read_time이 표기. read_time -> date 변경

    
      <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  12 minute read

</p>
    
    -->
    
       <p class="page__meta"><i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i> April 15 2019</p>
    
    <p class="archive__item-excerpt" itemprop="description">비선형 구조가 무엇이고 이를 어떻게 탐색할 수 있는지 알아본다.
</p>
  </article>
</div>

        
      </div>
    </div>
  
  
</div>

    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <!-- <START> google ads added by lemidia -->
    <div>
      <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
      <!-- lemidia -->
      <ins class="adsbygoogle"
          style="display:block"
          data-ad-client="ca-pub-8663880613144845"
          data-ad-slot="6829839254"
          data-ad-format="auto"
          data-full-width-responsive="true"></ins>
      <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
      </script>
    </div>
    <!-- <END> google ads added by lemidia -->

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-title">
  <div>
    <img src="/assets/images/logo4.png" alt="">
  </div>
  <div>
    <p><Strong>Code Factory</strong></p><span>Inspiration of Computer science</span>
  </div>
</div>

<div class="page__footer-follow">
  <ul class="social-icons">
    
      <li><strong>Follow:</strong></li>
    

    
      
        
      
        
      
        
          <li><a href="https://github.com/lemidia" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
        
      
        
      
        
          <li><a href="https://www.instagram.com/gyeong_it/" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-instagram" aria-hidden="true"></i> Instagram</a></li>
        
      
    

    <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2020 Gyeong. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.
Hosted by Github Pages.  Made with <img src="/assets/images/love.svg" alt=""> by Gyeong</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>
  <script src="https://kit.fontawesome.com/4eee35f757.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>




    
  <script>
    var disqus_config = function () {
      this.page.url = "http://localhost:4000/algorithm/%EC%A0%84%EC%B2%B4%ED%83%90%EC%83%89%EB%B2%95/";  /* Replace PAGE_URL with your page's canonical URL variable */
      this.page.identifier = "/algorithm/전체탐색법"; /* Replace PAGE_IDENTIFIER with your page's unique identifier variable */
    };
    (function() { /* DON'T EDIT BELOW THIS LINE */
      var d = document, s = d.createElement('script');
      s.src = 'https://lemidia-github-io.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  </script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>


  





  </body>
</html>
