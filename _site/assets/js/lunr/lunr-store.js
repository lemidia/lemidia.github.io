var store = [{
        "title": "Recursion",
        "excerpt":"Recursion  컴퓨터 과학에서의 Recursion은 어떤 문제가 그 문제의 더 작은 사례의 해결에 의존해 해결되는 방법론이다. 재귀적인 문제는 반복적인 방법으로도 풀어질 수 있는데 그렇게 되기 위해선 런 타임 이전에 더 작은 사례를 식별하고 인덱스화 해야한다. 컴퓨터 과학 그리고 프로그래밍에서 Recursion은 함수가 자기 코드(own code) 안에서 자기 자신을 호출함으로 재귀적인 문제를 해결한다. Recursion은 많은 종류의 문제에서 적용될 수 있고 컴퓨터 과학에서의 중요한 이론이므로 잘 알아둘 필요가 있다.   대부분의 프로그래밍 언어는 함수가 자기 코드(own code) 안에서 자기 자신을 호출하는 방식으로 재귀를 지원한다. 함수적 프로그래밍 언어는 반복적인 구조를 정의하지 않으므로 오직 재귀적인 방법에만 의존해 문제를 해결한다.   함수안에서 자기 자신을 반복적으로 호출하는 재귀적인 방식을 사용하면 콜스택의 크기가 계속 커져 모든 호출과 연관된 입력 크기의 합과 같아질 수 있고, 이는 반복적인 방법으로 쉽게 해결이 가능한 문제의 경우 재귀를 적용했을 때의 효율성이 떨어진다는 것을 말한다. 또한 재귀적인 방법을 적용할 때 다소 큰 문제에 대해서는 tail call 같은 최적화 기술을 사용하는 것이 필수적이다.   Recursive functions   컴퓨터 과학에서 어떤 문제를  일반적인 방법 중의 하나는 분할 정복(Divide and conquer)이라는 것을 사용하는 것이다. 분할 정복은 어떤 문제를 같은 타입의 더 작은 문제들로 분할해 이를 해결하고 다시 합쳐 원래의 문제를 해결하는 방법론을 말한다. 여기서, 재귀 함수(Recursive functions)를 이용하면 분할 정복을 보다 쉽게 적용할 수 있게된다. 문제에 따라서는 해당 문제의 더 작은 사례들이 겹칠 수가 있어 같은 문제를 반복적으로 풀지않고, 계산 시간을 절약하기 위해 더 작은 문제들의 솔루션을 저장한 동적표 또는 룩업 테이블(Dynamic table or look up table)을 구성하는데, 이를 함께 적용한 방법을 이를 동적 프로그래밍 또는 메모이제이션(dynamic programming or memoization)이라 부른다.   일반적으로 재귀 함수(Recursive functions)는 단순히 조건에 따라 값을 반환하는 하나 이상의 기본 또는 기저 사례들(base cases)과 자기 자신을 호출하는 하나 이상의 재귀 사례들(Recursive cases)로 구성된다. 팩토리얼을 계산을 예로 들면, 입력 값 n이 0 일때는 0! = 1의 단순히 1을 반환하는 기저 사례, 입력 값 n이 0 보다 클 때는 n! = n(n − 1)!의 재귀 사례로 구성할 수 있다.   unsigned int factorial(unsigned int n) {     if (n == 0) {         return 1;     } else {         return n * factorial(n - 1);     } }   재귀 함수에서의 재귀 사례는 보다 큰 입력을 단순한 입력으로 분해하는 것으로 볼 수 있다. 잘 설계된 재귀 함수에서의 각 재귀 호출은 입력 문제를 보다 단순한 사례로 분해하고 결국에는 기본 사례에 도달하게 한다. 주의할 점은 기본 사례를 잘못 만들거나 생략하면(missing) 재귀 함수는 무한 루프(infinity loop)에 빠질 수 있다.   Single recursion and multiple recursion   재귀 함수가 단순히 하나의 자기 호출(single self-reference)을 가지고 있다면 이것을 단일 재귀(Single recursion), 여러개의 자기 호출(multiple self-references)을 가지고 있다면 다중 재귀(multiple recursion)라고 한다. 단일 재귀를 사용한 예로는 선형 탐색의 리스트 순회, 팩토리얼 계산이 있다. 이것들은 모두 하나의 재귀 사례로 행해질 수 있는 계산들이다.   다음은 단일 재귀의 리스트 순회 코드이다.   public static void listTraversal(listNode node) { \t// 현재 노드가 null이면 리턴 \tif (node == null) { \t  return; \t} \t// 현재 노드의 데이터를 출력한다. \tSystem.out.print(root.data + \" \"); \t// 재귀적으로 현재 노드의 다음 노드를 탐색한다. \tlistTraversal(node.next); }  현재 노드가 null인지 체크해 재귀를 끝내는 기본 사례와 다음 노드로의 탐색을 진행하는 단일 재귀 호출로 구성되어 있음을 볼 수 있다.     다중 재귀를 사용한 예로는 깊이우선탐색 방식의 트리 순회를 들 수 있다. 대표적인 깊이우선탐색 방식의 트리 순회는 전위 순회, 중위 순회, 후위순회가 있으며 이들 모두는 2개의 다중 재귀 사례를 가지고 있다.   다음은 트리 순회의 한 가지인 중위 순회의 코드이다.   inorder 함수는 1개의 기본 사례와 2개의 재귀 사례로 구성되어 있음을 볼 수 있다.  // Recursive function to perform in-order traversal of the tree public static void inorder(TreeNode root) { \t// 현재 노드가 null이면 리턴 \tif (root == null) { \t\treturn; \t} \t// 재귀적으로 왼쪽 서브트리를 탐색한다. \tinorder(root.left); \t// 현재 노드의 데이터를 출력한다. (방문) \tSystem.out.print(root.data + \" \"); \t// 재귀적으로 오른쪽 서브트리를 탐색한다. \tinorder(root.right); }   단일 재귀는 대체로 다중 재귀보다 효율적이고, 일반적으로 선형 시간에 동작하고 상수적 메모리 공간을 요구하는 반복적인 계산 방법으로 대체될 수 있다. 그에 반해 다중 재귀는 지수적 시간 복잡도와 공간을 요구하고 명시적인 스택 없이는 반복적인 방법으로 대체될 수 없다.   다중 재귀나 반복적인 방법은 문제에 따라서 단일 재귀로 바뀔 수 있는데 피보나치 순열이 그 예이다. 피보나치 순열을 이전의 값들을 두 개의 다중 재귀를 표현하여 계산하는 것은 연속적인 두 값을 이용하여 나이브(naive)하게 반복적인 방법으로 대체될 수 있고, 이는 다시 연속적인 두 값을 단일 재귀의 매개변수로 넣음으로써 단일 재귀 방법으로 대체될 수 있다. 하지만 여기서의 단일 재귀는 일반 재귀 때 처럼 문제를 작은 사례로 분해하여 기본 사례로 가는 것이 아니라 처음부터 값을 추적해 나가는데, 이것을 역 재귀(corecursion)라고 부른다.   Recursive programs   Factorial   재귀의 전형적인 예로 팩토리얼 계산을 들 수 있다.   Recursive procedures  function factorial is:  input: integer n such that n &gt;= 0  output: [n × (n-1) × (n-2) × … × 1]      1. if n is 0, return 1     2. otherwise, return [ n × factorial(n-1) ]  end factorial    위 팩토리얼을 계산하는 함수를 fact(n)로 보고 n을 매개 값으로 보면 n이 4일 때는 다음과 같이 계산이 된다.   fact(4) = 4 * fact(3)         = 4 * (3 * fact(2))         = 4 * (3 * (2 * fact(1)))         = 4 * (3 * (2 * (1 * fact(0))))         = 4 * (3 * (2 * (1 * 1)))         = 4 * (3 * (2 * 1))         = 4 * (3 * 2)         = 4 * 6         = 24    재귀 함수는 루프 구조(looping construct)와 상수적 O(1)공간을 요구하는 변수를 사용함으로써 재귀를 사용하지 않고 아래와 같이 반복적인 방법(iterative)으로 표현할 수 있다.   Iterative procedures  function factorial is:  input: integer n such that n &gt;= 0  output: [n × (n-1) × (n-2) × … × 1]      1. create new variable called running_total with a value of 1      2. begin loop           1. if n is 0, exit loop           2. set running_total to (running_total × n)           3. decrement n           4. repeat loop      3. return running_total  end factorial   Greatest common divisor   두 정수의 최대 공약수(GCD, Greatest common divisor)를 계산하는 유클리디언 알고리즘도 다음과 같이 재귀를 이용하여 표현될 수 있다.   Recursive procedures  function gcd is: input: integer x, integer y such that x &gt; 0 and y &gt;= 0      1. if y is 0, return x     2. otherwise, return [ gcd( y, (remainder of x/y) ) ]  end gcd   x = 111 이고 y = 259 일 때의 위 함수를 적용하여 다음과 같이 계산된다.  gcd(111, 259)   = gcd(259, 111 % 259)                 = gcd(259, 111)                 = gcd(111, 259 % 111)                 = gcd(111, 37)                 = gcd(37, 111 % 37)                 = gcd(37, 0)                 = 37     마찬가지로 반복적인 방법으로 표현될 수 있다.   Iterative procedures  function gcd is:  input: integer x, integer y such that x &gt;= y and y &gt;= 0      1. create new variable called remainder      2. begin loop           1. if y is zero, exit loop           2. set remainder to the remainder of x/y           3. set x to y           4. set y to remainder           5. repeat loop      3. return x  end gcd   Binary search   이진 탐색은 사전에 미리 정렬이 완료된 배열이나 리스트에서 특정 값을 찾는 탐색 방법으로써 탐색의 매 단계마다 입력 배열의 반틈을 반복적으로 검색해 나간다. 입력 배열의 중간 지점을 선택해 찾고자 하는 데이터와 비교하고 찾았다면 그 값을 리턴한다. 아니라면, 중간 지점의 데이터가 찾고자 하는 데이터보다 작다면 중간 지점의 오른쪽 배열 반틈을, 중간 지점의 데이터가 찾고자 하는 데이터보다 크다면 중간 지점의 왼쪽 배열 반틈을 다시 검색해 나간다.   재귀의 속성이 이진 탐색에서 활용될 수 있는데, 매 탐색의 단계마다 입력 배열의 반틈을 반복적으로 탐색해 나가기 때문이다. 탐색의 매 단계마다 이전 배열로 부터 만들어진 새로운 배열에 대해 이진 탐색을 하는데 있어 재귀 함수를 적용할 수 있다. 이진 탐색은 탐색의 매 단계 마다 문제의 크기를 반틈씩 나누므로 로그적$O(logn)$ 성능을 보인다.   다음은 재귀를 적용한 이진 탐색 코드이다.  /*   Call binary_search with proper initial conditions.    INPUT:     data is an array of integers SORTED in ASCENDING order,     toFind is the integer to search for,     count is the total number of elements in the array    OUTPUT:     result of binary_search   */  int search(int *data, int toFind, int count)  {     //  Start = 0 (beginning index)     //  End = count - 1 (top index)     return binary_search(data, toFind, 0, count-1);  }   /*    Binary Search Algorithm.     INPUT:         data is a array of integers SORTED in ASCENDING order,         toFind is the integer to search for,         start is the minimum array index,         end is the maximum array index    OUTPUT:         position of the integer toFind within array data,         -1 if not found  */  int binary_search(int *data, int toFind, int start, int end)  {     //Get the midpoint.     int mid = start + (end - start)/2;   //Integer division      //Stop condition.     if (start &gt; end)        return -1;     else if (data[mid] == toFind)        //Found?        return mid;     else if (data[mid] &gt; toFind)         //Data is greater than toFind, search lower half        return binary_search(data, toFind, start, mid-1);     else                                 //Data is less than toFind, search upper half        return binary_search(data, toFind, mid+1, end);  }   References      Recursion   Recursion (Computer science)   Functional programming  ","categories": ["Algorithm"],
        "tags": ["Recursive","Computer science","Mathematics"],
        "url": "http://localhost:4000/algorithm/recursion/",
        "teaser":null},{
        "title": "스패닝 트리와 최소 스패닝 트리(Minimum Spanning Tree)",
        "excerpt":"들어가기 전에: 먼저 스패닝 트리가 무엇인지 알아보자.   스패닝 트리(Spanning tree)   G: 그래프  T: 스패닝 트리  V: 모든 정점의 개수  E: 모든 간선의 개수   라고 하자.   그래프 이론에서 어떤 비방향 그래프 G가 있다고 하면, 그 비방향 그래프 G의 스패닝 트리 T는 이렇게 정의된다.   Definition  그래프 G의 모든 정점을 연결하면서 가능한 최소의 간선 개수로 이루어지는 트리(또는 서브 그래프). (트리이므로 사이클은 포함하지 않아야 한다.)   이에 따라, 그래프 G의 스패닝 트리 T는 그래프 G의 모든 정점의 수 V개를 가지며, 간선의 개수는 V-1개를 가진다.   트리란?: 여기서 트리는 사이클을 가지지 않는 비방향 연결 그래프를 말한다.   아래 그림은 그래프 G의 스패닝 트리 T를 나타낸 것이다.      빨간점은 스패닝 트리 T의 정점, 파란선은 스패닝 트리 T의 간선을 나타낸다.   그림에서 보이는 것과 같이 스패닝 트리 T는 그래프 G의 모든 정점을 연결하고 있고, 스패닝 트리 T를 구성하는 간선의 개수는 최소가 되고 있다.  또한 사이클을 포함하지 않는다.   위 그래프 G의 정점의 개수를 V개라 하면, 스패닝 트리 T는 정점의 개수가 V개 즉, 16개 간선의 수는 V-1개 즉, 15개로 이루어져 있다.   일반적으로, 그래프는 아래 그림처럼 여러개의 스패닝 트리를 가질 수 있다.      하지만 그래프 G가 연결 그래프가 아니라면 스패닝 트리를 가질 수 없다.   만약 그래프 G의 모든 간선이 그래프 G의 스패닝 트리 T의 간선과 동일하다면, 그래프 G는 트리이고 또한 스패닝 트리 T라고 할 수 있다. (이것은 그래프 G가 유일한 스패닝 트리를 가질 수 있음을 의미한다.)   그래프 G의 스패닝 트리는 이렇게도 정의 될 수 있다.   사이클을 포함하지 않는 그래프 G의 간선의 최대 집합 혹은 그래프 G의 모든 정점을 연결하는 그래프 G의 간선의 최소 집합.   Fundamental cycles   스패닝 트리를 포함하는 그래프G의 간선들 중에서 스패닝 트리를 구성하지 않는 간선을 하나만 추가하면 사이클이 생긴다. 이러한 사이클을 Fundamental cycles이라 부른다.   스패닝 트리에 포함되지 않는 그래프의 각 간선들 마다 고유한 Fundamental cycles이 존재한다. 따라서, 스패닝 트리에 포함되지 않는 그래프의 각 간선들과 Fundamental cycles은 1:1 관계라고 볼 수 있다.   정점 V개의 연결 그래프는 V-1개의 간선을 가진 스패닝 트리를 가질 것이고 이는, 간선의 개수가 E개의 연결 그래프의 어떤 한 스패닝 트리는 E-V+1개의 Fundamental cycles을 가지게 된다.   요약: V: 그래프 G의 정점 개수, E: 그래프 G의 간선 개수라 한다면   스패닝 트리에 포함되지 않는 그래프 G의 간선들 = E - (V-1) = E - V + 1.  Fundamental cycles과 스패닝 트리에 포함되지 않는 그래프 G의 간선들은 1:1 관계이므로  Fundamental cycles = E - V + 1.   Fundamental cut sets   연결된 그래프 G에서, 그래프 G를 이루는 간선들 중 어느 간선들의 삭제가 그래프 G를 비연결 그래프로 만들게하는데 그 간선들의 집합을 cut sets이라 한다. cut sets은 그래프 G를 항상 두개의 그래프로 나눈다.   아래 그림은 그래프 G의 cut sets을 보여준다.      스패닝 트리는 그 트리를 이루는 간선들 중 하나의 간선만 삭제하면, 스패닝 트리를 이루는 정점들은 서로 다른 두개의 정점들 집합으로 분리된다. 따라서, 스패닝 트리를 이루는 모든 간선들은 cut sets이라고 볼 수 있다.   이러한, 스패닝 트리의 하나의 간선(가지)만을 포함하는 cut sets을 Fundamental cut sets이라고 한다.   최소 스패닝 트리(Minimum spanning tree)   위의 스패닝 트리를 이해했다면 최소 스패닝 트리의 개념은 간단하다.   그래프 G의 스패닝 트리 중에서 그 스패닝 트리를 구성하는 간선들의 가중치의 합이 최소가 되는 트리를 최소 스패닝 트리라고 한다.   다음 그래프 G의 그림을 보자.      굵은 검은선과 검은 정점들은 그래프G 최소 스패닝 트리를 나타내고, 회색 실선은 스패닝 트리에 포함되지 않는 그래프의 간선들을 나타낸다.   이처럼, 위 그림에서의 스패닝 트리는 여러가지가 있겠지만, 위 그림에서 표시된 스패닝 트리가 간선들의 가중치 합이 최소가 되게 하고 있다. (간선과 가중치의 구성에 따라 여러개의 최소 스패닝 트리가 나올 수 있다.)   컴퓨터 과학에서 이러한 그래프가 주어지면 최소 스패닝 트리를 구하는 알고리즘은 대표적으로 프림 알고리즘, 크루스칼 알고리즘 두 가지가 있다.   References    Spanning Tree - Wikipedia  Cut sets  ","categories": ["Data Structure"],
        "tags": ["Spanning Tree","Tree"],
        "url": "http://localhost:4000/data%20structure/spanning-tree/",
        "teaser":"http://localhost:4000/assets/images/spanning-tree-minimum.png"},{
        "title": "이분 탐색(Binary Search)",
        "excerpt":"이분 탐색(Binary Search)   컴퓨터 과학(Computer science)에서 이분 탐색(Binary Search)은 정렬된 배열(Sorted array)에서 찾고자 하는 값의 존재 유무나 위치를 찾는 알고리즘이다. 이분 탐색은 찾고자 하는 값을 배열의 중간 원소와 비교한다. 두 개의 값이 같지 않다면, 찾고자 하는 값이 놓여있지 않다고 판단되는 배열의 반은 탐색 범위에서 제외되고 나머지 반을 다시 탐색한다. 이것을 찾고자 하는 값이 나올 때까지 반복하는데, 탐색 공간이 빈 공간(크기가 0)이 되어 탐색이 끝나게 되면 해당 배열에서 찾고자 하는 값이 없다는 것을 의미한다.   탐색을 수행할 배열의 원소 개수가 $n$개일 때 이분 탐색은 복잡도 면에서 최악의 경우 $O(logn)$의 로그적 시간에 동작한다. 앞에서 부터 순서대로 하나씩 탐색하는 순차 혹은 선형 탐색(linear search)과 비교하면 작은 크기의 배열을 제외할 시 이분 탐색이 더 빠르다고 할 수 있다. 순차 탐색은 탐색에 있어 배열의 원소 순서에 제약이 없지만 이분 탐색은 원소의 정렬이 완료된 배열에서 탐색이 가능하다.   Algorithm   가장 일반적인 알고리즘을 보자.   배열은 오름차순으로 정렬되어 있다고 가정하고 시작한다. 먼저 찾고자 하는 값을 배열의 중간 위치의 원소 값과 비교한다. 찾고자 하는 값이 중간 위치의 원소 값과 일치하면 그 중간 원소의 위치를 반환하고 알고리즘을 끝낸다. 찾고자 하는 값이 중간 원소의 값보다 작다면 중간 원소를 기준으로 오른쪽의 값들은 찾고자 하는 값들보다 크므로 탐색을 수행할 필요가 없다. 따라서 왼쪽 반에 대해서 이분 탐색을 수행한다. 찾고자 하는 값이 중간 원소의 값보다 그다면 중간 원소를 기준으로 왼쪽의 값들은 찾고자 하는 값들보다 작으므로 탐색을 수행할 필요가 없다. 따라서 오른쪽 반에 대해서 이분 탐색을 수행한다. 이것을 원하는 값을 찾을 때 까지 수행한다. 탐색을 수행하다가 탐색 범위의 크기가 0이 되면 배열에서 찾고자 하는 값이 없다는 것을 의미한다.   Procedure   $n$개의 원소로 이루어진 $A_0,A_1,A_2,…,A_{n-1}$ 배열 $A$가 주어지고 원소들은 오름차순 $A_0 \\leq A_1 \\leq A_2 \\leq … \\leq A_{n-1}$ 으로 정렬되어 있다. 그리고 찾고자 하는 값 $T$가 주어진다.   다음의 절차로 배열 $A$에서 값 $T$를 찾는다.           배열의 맨 처음 인덱스를 가리키는 $L$을 $0$으로 배열의 맨 끝 인덱스를 가리키는 $R$을 $n-1$로 놓는다.            $L \\gt R$ 이면 탐색 공간의 크기가 0이 되고 배열에서 찾고자 하는 값이 없다는 것을 의미하므로 알고리즘을 종료한다.            배열의 중간 인덱스 원소를 가리키는 $m$을 $\\lfloor\\frac{L + R}{2}\\rfloor$로 놓는다. $\\lfloor x \\rfloor$, floor 기호는 $x$ 값 보다 크거나 같은 수 중 가장 작은 정수를 의미한다. 예) $\\lfloor\\frac{1+2}{2}\\rfloor$ = 1이다.            $A_m \\lt T$이면 $L$을 $m+1$로 놓고 2번으로 간다.            $A_m \\gt T$이면 $R$을 $m-1$로 놓고 2번으로 간다.            $A_m = T$ 이면 $m$을 반환하고 알고리즘을 종료한다.       다음은 위 절차에 대한 의사코드이다.   function binary_search(A, n, T) is     L := 0     R := n − 1     while L ≤ R do         m := floor((L + R) / 2)         if A[m] &lt; T then             L := m + 1         else if A[m] &gt; T then             R := m - 1         else:             return m     return unsuccessful   Alternative procedure   위에서 알아본 방법에서는 탐색의 매 반복 마다 중간 값 원소와 $T$를 비교하는 구문이 있다면, 이번 방법에서는 $L = R$이 같을 때에만 값이 같은지 체크를 수행한다. 이 방법은 위의 방법에 비해 비교 구문을 하나 제거하였기에 루프에서 빠른 비교를 가능하게 하지만 평균 상황에서 한 번의 반복을 더 요구한다.   다음의 절차로 배열 $A$에서 값 $T$를 찾는다.           배열의 맨 처음 인덱스를 가리키는 $L$을 $0$으로 배열의 맨 끝 인덱스를 가리키는 $R$을 $n-1$으로 놓는다.       while $L \\neq R$                     배열의 중간 인덱스 원소를 가리키는 $m$을 $\\lceil\\frac{L + R}{2}\\rceil$로 놓는다. $\\lceil x \\rceil$, ceil 기호는 $x$ 값 보다 크거나 같은 수 중 가장 작은 정수를 의미한다. 예) $\\lceil\\frac{1+2}{2}\\rceil$ = 2이다.                        $A_m \\gt T$이면 $R$을 $m-1$로 놓는다.                        $A_m \\leq T$이면 $L$을 $m$으로 놓는다.                   이제 $L = R$ 이다.  $A_L = T$ 이면 $L$을 반환한다. 아니라면, unsuccessful을 반환한다.   다음은 위 절차에 대한 의사코드이다.   function binary_search_alternative(A, n, T) is     L := 0     R := n − 1     while L != R do         m := ceil((L + R) / 2)         if A[m] &gt; T then             R := m - 1         else:             L := m     if A[L] = T then         return L     return unsuccessful   Duplicate elements   앞에서 알아본 방법에 의해 이분 탐색은 배열에서 찾고자 하는 값의 위치를 반환하는데, 중복된 값이 존재해도 마찬가지로 동작한다. 정렬된 배열 $[1,2,3,4,4,5,6,7]$이 있고 찾고자 하는 값이 4일 때, 위에서 알아본 방법에 의해 각각 4번째 위치(3번 인덱스)와 5번째 위치(4번 인덱스)를 반환할 것이다. 처음 알아본 방법은 4번째 위치를 반환할 것이다. 하지만 처음 알아본 방법은 중복된 값이 있으면 그 중에서 제일 처음 값을 반환하지 않는데, 만약 배열 $[1,2,4,4,4,5,6,7]$이 있다고 하면 처음 방법은 4번째 값을 반환하고, 중복된 첫번째 값(3번째 위치)을 반환하지 않는다. 특정 문제나 상황에서 배열에 찾고자 하는 값의 중복된 값이 존재하고 그 값들 중 가장 왼쪽 값 또는 가장 오른쪽 값을 찾아야 하는 경우가 있다. 배열 $[1,2,4,4,4,5,6,7]$에서 값 4의 가장 왼쪽 값은 3번째 위치의 4이고, 가장 오른쪽 값은 5번째 위치의 4이다. 위에서 알아본 Alternative procedure는 배열에서 찾고자 하는 값이 존재하면, 찾고자 하는 값들 중 가장 왼쪽의 위치를 반환한다.   Procedure for finding the leftmost element   다음은 중복된 값들 중 가장 왼쪽에 있는 값을 찾는 알고리즘이다.           배열의 맨 처음 인덱스를 가리키는 $L$을 $0$으로 배열의 맨 끝 인덱스를 가리키는 $R$을 $n$으로 놓는다.       while $L \\lt R$                     배열의 중간 인덱스 원소를 가리키는 $m$을 $\\lfloor\\frac{L + R}{2}\\rfloor$로 놓는다.                        $A_m \\lt T$이면 $L$을 $m+1$로 놓는다.                        $A_m \\geq T$이면 $R$을 $m$으로 놓는다.                   $L$을 반환한다.   위의 과정을 거치고, $L \\lt n$ $and$ $A_L = T$ 이면 $A_L$은 $T$와 같은 가장 왼쪽에 있는 원소이다. $T$가 배열에 있다면 $L$은 $T$의 가장 왼쪽 원소 위치를 가리키는 동시에 $T$보다 작은 원소들의 개수를 의미한다. 이것을 $Rank$라고 한다. $T$가 배열에 없다면 $L$은 $T$보다 작은 원소들의 개수를 의미한다.   다음은 위 알고리즘의 의사코드이다.   function binary_search_leftmost(A, n, T):     L := 0     R := n     while L &lt; R:         m := floor((L + R) / 2)         if A[m] &lt; T:             L := m + 1         else:             R := m     return L   Procedure for finding the rightmost element   다음은 중복된 값들 중 가장 오른쪽에 있는 값을 찾는 알고리즘이다.           배열의 맨 처음 인덱스를 가리키는 $L$을 $0$으로 배열의 맨 끝 인덱스를 가리키는 $R$을 $n$으로 놓는다.       while $L \\lt R$                     배열의 중간 인덱스 원소를 가리키는 $m$을 $\\lfloor\\frac{L + R}{2}\\rfloor$로 놓는다.                        $A_m \\gt T$이면 $R$을 $m$으로 놓는다.                        $A_m \\leq T$이면 $L$을 $m+1$로 놓는다.                   $R-1$을 반환한다.   위의 과정을 거치고, $R \\gt 0$ $and$ $A_{R-1} = T$ 이면 $A_{R-1}$은 $T$와 같은 가장 오른쪽에 있는 원소이다. $T$가 배열에 있다면 $R-1$은 $T$의 위치를 가리킨다. $n-L$은 $T$ 보다 작은 원소들의 개수를 의미한다.   다음은 위 알고리즘의 의사코드이다.   function binary_search_rightmost(A, n, T):     L := 0     R := n     while L &lt; R:         m := floor((L + R) / 2)         if A[m] &gt; T:             R := m         else:             L := m + 1     return R - 1   Approximate matches   이분 탐색은 배열에서 찾고자 하는 값의 위치를 알아낼 때도 쓸 수 있지만, 정렬된 배열에서 동작하는 알고리즘 특성 상 배열에 해당 값이 없어도 그 값과 대략적으로 일치하는 값의 위치를 알아내는 데에도 적용할 수 있다.      위 그림에서 보이듯이, 이분 탐색을 활용하면 Target value의 Rank, predcessor, successor,  nearest neighbor를 계산할 수 있다. 또한 특정 두 원소 사이에 몇 개의 원소가 있는지 찾는 범위 질의(Range queries)도 두 값의 $Rank$를 안다면 쉽게 계산 할 수 있다.           Rank queries: Target value 보다 작은 원소의 개수를 위에서 $Rank$라고 했었다. $Rank$는 위에서 알아본 procedure for finding the leftmost element를 이용하여 알아낼 수 있다. 이 procedure에서는 Target value 보다 작은 원소의 개수를 의미하는 $L$을 반환한다.            predcessor queries: 선행자 - predcessor는 바로 위에서 알아본 Rank queries에서 알아낼 수 있다. target value의 $rank$가 $r$이라고 하면 predcessor는 $r-1$이 된다.            successor queries: 후행자 - successor는 procedure for finding the rightmost element를 통해 알아낼 수 있다. 이 procedure가 반환한 값이 $r$이라면 successor는 $r+1$이 된다.            nearest neighbor: predcessor와 successor 중 더 가까운 쪽이 nearest neighbor가 된다.            Range queries: 두 값의 $Rank$를 안다면 첫번째 값 보다 크거나 같고 두번째 값보다 작은 원소의 개수는 두 $Rank$의 값의 차이이다. 이 개수는 범위의 끝점이 개수로 카운팅 되어야 하는가와 배열에서 해당 범위의 끝점이 target value와 일치 하는가에 따라 하나씩 증가 또는 감소할 수 있다.       Avoid integer overflow   C++이나 java와 같은 프로그래밍 언어에서는 Signed int가 4bytes의 공간을 차지한다. 이는 정수 값으로 -2147483648$(2^{31})$ ~ 2147483647$(2^{31}-1)$의 값을 표현 할 수 있다.   문제는 중간 원소의 위치를 계산하는 과정에서 $L + R$을 할 때 Interger의 범위를 넘을 수가 있다.      (L + R)/2 &gt; 2147483647   Integer overflow를 피하기 위해서는 다음의 트릭을 쓸 수 있다.      L + (R - L)/2 또는 R - (R - L)/2   R-L을 함으로써 overflow를 피하고 이를 반으로 나누면 양 끝점에서 부터 중간 원소 까지의 떨어진 거리 Offset이 된다. 이를 맨 처음 인덱스에 더하거나, 맨 끝 인덱스에서 빼면 중간 원소의 위치가 계산된다.   이 트릭은 중간 위치를 정확하게 계산하면서 Integer 범위 안의 매우 큰 값에 대해서도 두 정수를 더할 때 Integer overflow를 방지한다.   performance   비교 횟수와 관련해, 이분 탐색의 성능은 이분 탐색이 만드는 이진 트리에서의 프로시저의 실행을 통해 분석할 수 있다. 트리의 루트 원소는 배열에서의 중간 위치의 원소이다. 배열의 중간 위치 원소를 기준으로 왼쪽 반은 루트 노드의 왼쪽 자식 트리이고, 오른쪽 반은 루트 노드의 오른쪽 자식 트리이다. 그 밑의 자식 트리들도 이와 같이 만들어 진다. 루트 노드를 시작으로 찾고자 하는 값과의 대소 비교를 통해 어느쪽 자식을 탐색할지 정해진다.      위의 그림은 배열이 [20, 30, 40, 50, 80, 90, 100]일 때, 이분 검색이 그리는 트리를 나타내고 있다.  Target value가 40일 때, 그림처럼 루트 노드에서부터 비교를 시작해서 50, 30, 40순으로 탐색을 한다.      시간적인 측면에서 보면 이분 검색은 최악의 경우, 찾고자 하는 값이 배열에 있을 때, 비교 반복 횟수를 $\\lfloor log_2(n) + 1 \\rfloor$번 만든다. 최악의 경우 찾고자 하는 원소가 트리의 가장 깊은 곳에 있어 $\\lfloor log_2(n) + 1 \\rfloor$만큼의 비교 검색을 수행해야 하기 때문이다.   찾고자 하는 값이 배열에 없을 때도 최악의 경우가 있을 수 있는데, n이 2의 제곱 수 이거나 탐색이 트리의 가장 깊은 곳에서 끝나면 비교 반복 횟수는 $\\lfloor log_2(n) + 1 \\rfloor$이 된다. 그렇지 않고, 탐색이 두번째로 가장 깊은 곳에서 끝나면 비교 반복 횟수는 1 줄어든 $\\lfloor log_2(n)\\rfloor$이 된다.   평균적인 상황에서는 모든 원소가 동일하게 검색될 가능성이 있다고 가정하면, 이분 탐색은 $\\lfloor log_2(n) \\rfloor + 1 - (2^{\\lfloor log_2(n) + 1 \\rfloor} - \\lfloor log_2(n) -2 \\rfloor)/n$의 비교 반복 횟수를 만든다. 이 값은 n이 커질 수록 대략적으로 $\\lfloor log_2(n) - 1 \\rfloor$ 값에 근접해진다.   최선의 상황에서는 찾고자 하는 값이 배열의 중앙에 있어 한번 만에 찾는 경우이다. 이는 한번의 비교 반복 횟수 만으로 원소를 반환하는 경우이다. - $O(1)$   공간적인 측면에서 보면 이분 탐색을 반복적인 방법으로 구현했을 시, 약간의 포인터 혹은 변수들은 $O(1)$의 공간을 요구한다. 또한 처음 프로그램이 호출될 때 단일 콜 스택 $O(1)$의 공간을 요구한다. 반복적인 방법은 다른 변수나 추가적인 Recursive call을 만들지 않기 때문에 전체적으로 $O(1)$의 공간만을 요구한다.   재귀적인 방법으로 구현할 시, 탐색의 매 단계마다 재귀 호출을 하는데, 이는 지금의 함수 호출 정보를 담은 스택 프레임(Stack frame)을 콜 스택(Call stack)에 저장하고 다시 재귀 호출을 한다는 것을 의미한다. 이분 탐색의 레벨 깊이가 m일 때 최악의 경우 m개의 스택 프레임이 만들어지므로 공간 복잡도는 이 레벨 깊이에 비례한다. 원소의 개수가 $n$개일 때 최대 레벨은 $\\lfloor log_2n \\rfloor + 1$개가 되므로 전체적으로 최악 $O(log_2n$)의 공간복잡도가 된다.   Time &amp; Space Complexity           Worst Case performance: $O(log_2n)$            Average Case performance: $O(log_2n)$            Best Case performance: $O(1)$            Worst Case Space Complexity: Iterative: $O(1)$, Recursive: $O(log_2n)$ due to call stack       References      Binary Search   Binary Search   Binary Search - Space Complexity  ","categories": ["Algorithm"],
        "tags": ["Search Algorithm","Tree","binary Search"],
        "url": "http://localhost:4000/algorithm/binary-search/",
        "teaser":null},{
        "title": "삽입 정렬(Insertion Sort)",
        "excerpt":"삽입 정렬(Insertion sort)   삽입 정렬은 안정 정렬이자 제자리 정렬 알고리즘이다.   비교적 심플한 정렬 알고리즘으로서 일상 생활에서도 번호에 따라 카드를 정렬할 때 대부분 이 방법을 사용하곤 한다. 이 알고리즘에서는 각 원소를 정렬된 부분 배열(Sorted partial array)의 적절한 위치에 삽입한다.   삽입 정렬의 시간복잡도는 최악 기준 $O(n^2)$이므로 큰 리스트에는 비효율적이며, 유사한 시간복잡도를 갖는 선택 정렬이나 버블소트 보다는 성능이 좋지만, $O(nlogn)$의 시간복잡도를 같는 퀵 소트나 머지소트 같은 소팅 알고리즘 보다는 덜 효율적이다.   그러나, 삽입 정렬은 원소의 숫자가 적은 배열이나 리스트(원소의 개수가 10-20개 이하)에서는 일반적으로 퀵 소트나 머지소트 보다 효율적이여서, 실무에서는 다른 $O(nlongn)$의 시간복잡도를 갖는 소팅 알고리즘과 함께 정렬에 사용되어지고 있다. (ex. Tim sort)   안정 정렬과 제자리 정렬 이란?   안정 정렬: 정렬이 끝나면 같은 키값을 가진 원소들의 상대적인 순서가 변하지 않는 것을 의미.  안정 정렬 알고리즘으로는 삽입 정렬, 머지소트, 카운팅 소트 등이 있다.  제자리 정렬: 원소들의 개수에 비해서 충분히 무시할 만한 저장 공간만을 더 사용하는 정렬 알고리즘들을 의미.  예를 들어 삽입 정렬은 이미 주어진 원소들을 옮긴 뒤 적절한 위치에 원소를 삽입하는 연산을 반복하는데, 이 과정에서 원소들을 담는 공간 외에 추가로 사용될 수 있는 공간은 옮겨지는 원소가 저장되는 공간과 루프 변수 정도에 불과하다.   다음은 삽입 정렬의 몇 가지 장점이다.      다른 정렬 알고리즘에 비해 코드가 간단하고 구현이 쉽다. - Simple to implement   최악 기준 $O(n^2)$의 시간복잡도를 가지는 소팅 알고리즘(선택 정렬, 버블 소트)에 비해 비교적 효율적이다.   작은 데이터 셋에서 매우 효율적이다. - Efficient in small data set   적응적이다. 대체로 이미 정렬이 되어있는 데이터 셋에서 효율적이다. - Adaptive   같은 키값을 가진 원소들의 상대적인 순서를 바꾸지 않는다. - Stable   O(1)의 상수적인 추가 메모리 공간만이 필요하다. - In-place   실시간으로 원소를 하나씩 입력받으면서 정렬할 수 있다. - Online   알고리즘   다음은 삽입 정렬의 알고리즘이다. (오름차순, 원소 개수 2개 이상 기준)      먼저, 정렬될 리스트에서 두번째 원소를 선택한다.   1.번에서 선택한 원소를 기준으로 리스트의 앞의 원소들과 비교하여 기준에 따라 자기 자리를 찾아간다. - 1 pass   이를 매번 3…n-1번째 원소까지 선택하여 2.번을 반복한다.   이처럼, n개의 원소를 가진 리스트는 삽입 정렬로 n-1번의 패스를 거쳐 정렬이 된다.     삽입 정렬에서는 매 반복(1 pass or each repetition)마다 하나의 원소를 취해 부분 정렬된 정렬된 리스트에 그 원소가 속할 위치를 찾고 그 위치에 삽입을 한다. 이것을 n번째 원소까지 반복한다.   다음 그림은 매번의 반복마다 원소 $x$가 자리를 찾아 삽입되는 것을 보여준다.   아래 그림은 원소 $x$가 정렬이 수행되기 전이다.  원소 $x$는 아직 정렬되지 않은 데이터 셋에 있다.      정렬이 수행되고 나서는 아래 그림처럼 된다.  원소 $x$는 $&lt;=x$ 보다는 오른쪽 $&gt;x$ 보다는 왼쪽에 있어, 부분 정렬 결과에 속하게 된다.        다음은 삽입 정렬의 애니메이션이다.      예제   다음 예제를 보고 알고리즘을 이해해 보자.   다음과 같은 리스트가 있다고 하자.    List = [64 25 12 22 11] - index: 0...4  List = [정렬 완료 | 미정렬]  1 pass: 1번 인덱스 위치의 원소를 선택하여          앞의 원소들과 비교하여 적절한 위치에 삽입한다.  List = [25 64 | 12 22 11]  2 pass: 2번 인덱스 위치의 원소를 선택하여         앞의 원소들과 비교하여 적절한 위치에 삽입한다.  List = [12 25 64 | 22 11]  3 pass: 3번 인덱스 위치의 원소를 선택하여         앞의 원소들과 비교하여 적절한 위치에 삽입한다.  List = [12 22 25 64 | 11]  4 pass: 4번 인덱스 위치의 원소를 선택하여          앞의 원소들과 비교하여 적절한 위치에 삽입한다.  List = [11 12 22 25 64 | ]  n-1번의 pass로 리스트의 정렬이 완료되었다.  List = [11 12 22 25 64]   구현   다음은 삽입 정렬의 의사 코드이다.   i ← 1 while i &lt; length(A)     j ← i     while j &gt; 0 and A[j-1] &gt; A[j]         swap A[j] and A[j-1]         j ← j - 1     end while     i ← i + 1 end while   다음은 선택 정렬을 C++로 구현한 코드이다.   #include&lt;iostream&gt;   using namespace std;   int main ()   {       int i,j, k,temp;       int a[10] = { 10, 9, 7, 101, 23, 44, 12, 78, 34, 23};        cout&lt;&lt;\"\\nprinting sorted elements...\\n\";       for(k=1; k&lt;10; k++)        {           temp = a[k];           j= k-1;           while(j&gt;=0 &amp;&amp; temp &lt;= a[j])           {               a[j+1] = a[j];                j = j-1;           }           a[j+1] = temp;       }       for(i=0;i&lt;10;i++)       {           cout &lt;&lt;a[i]&lt;&lt;\"\\n\";       }   }    /* Output: Printing sorted elements . . .  7 9 10 12 23 23 34 44 78  101  */   다음은 선택 정렬을 java로 구현한 코드이다.   public class InsertionSort {       public static void main(String[] args) {           int[] a = {10, 9, 7, 101, 23, 44, 12, 78, 34, 23};           for(int k=1; k&lt;10; k++)            {               int temp = a[k];               int j= k-1;               while(j&gt;=0 &amp;&amp; temp &lt;= a[j])               {                   a[j+1] = a[j];                    j = j-1;               }               a[j+1] = temp;           }           System.out.println(\"printing sorted elements ...\");           for(int i=0;i&lt;10;i++)           {               System.out.println(a[i]);           }       } }   /* Output: Printing sorted elements . . .  7 9 10 12 23 23 34 44 78  101  */   시간복잡도 &amp; 공간복잡도   시간복잡도 분석   최악 기준 $1$…$n-1$개의 원소를 매 패스마다 비교한다.  n개의 원소가 있다면 $n-1$의 패스를 가진다.     비교의 측면에서 볼 때, 복잡도는 $O(n^2)$이다.   교환(Swap)도 위와 동일하다.   **Insertion sort**  Class\t            정렬 알고리즘  Data structure\t    배열  Worst-case          О(n^2) 비교 performance         О(n^2) 교환  Best-case           О(n^2) 비교 performance         О(n^2) 교환  Average             О(n^2) 비교 performance         О(n^2) 교환  Worst-case          O(n) 총 공간 space complexity    O(1) 추가 공간   References   Insertion sort - wikipedia  Insertion sort - javatpoint  ","categories": ["Algorithm"],
        "tags": ["Sort","Array"],
        "url": "http://localhost:4000/algorithm/insertion-sort/",
        "teaser":null},{
        "title": "퀵 소트(Quick Sort)",
        "excerpt":"Quick sort   퀵 소트(Quick sort)는 효율적인 비교기반 정렬 알고리즘으로 영국의 컴퓨터 과학자 Tony Hoare에 의해 1959 년에 개발되었다. 이 정렬 알고리즘은 현재 여러 프로그래밍 언어의 공식 정렬 라이브러리로 채택이 되었고, 실무에서도 많이 쓰이고 있다. 구현이 잘 되었을 때는 시간복잡도 $O(nlogn)$의 머지 소트나 힙 소트보다 두 배에서 세 배 정도 빨라질 수 있다.   퀵 소트는 분할 정복 알고리즘이다. 배열에서 원소를 두 부분의 서브 배열(sub-array)로 나눌 기준이 되는 피봇(pivot)을 선택하고 피봇 값 보다 크고 작음에 따라 원소를 두 부분의 서브 배열로 나눈다. 피봇을 기준으로 두 서브 배열이 부분 정렬이 되면, 서브 배열은 다시 재귀적(recursively)으로 위와 같이 정렬이 되어진다.   퀵 소트에서 원소가 피봇을 기준으로 두 부분의 서브 배열로 분할 되는 것은 약간의 변수와 같은 상수적 메모리 공간 $O(1)$만을 요구하는 제자리 정렬(in-place)의 속성을 만족 할 수 있다.   퀵 소트는 비교기반 정렬 알고리즘으로서 원소들이 크고 작음의 관계에 따라 상대적인 위치가 정해지게 된다. 대소 관계를 정의할 수 있는 형태는 이 비교기반에 따라 정렬이 가능해진다. 또한 현재 퀵 소트의 효율적인 알고리즘은 안정 정렬(Stable sort)이 아니다. 이 것은 같은 값을 가진 원소의 상대적인 위치가 정렬이 되고 난 후에는 변할 수도 있다는 것을 의미한다.   퀵 소트의 시간복잡도 분석에 따르면 평균적인 상황에서는(서브 배열의 크기를 25% or 75%로 나눌 수 있는 피봇을 원소로 선정) $n$개의 원소를 정렬할 때 성능이 $O(nlogn)$, 최악의 상황에서는(서브 배열이 매 단계마다 1크기 만큼 줄어드는 상황) 성능이 $O(n^2)$임을 보인다. 최악의 경우는 대부분 많이 드물며 세부 구현에 따라 복잡도가 다소 달라질 수 있다.   안정 정렬과 제자리 정렬 이란?   안정 정렬: 정렬이 끝나면 같은 키값을 가진 원소들의 상대적인 순서가 변하지 않는 것을 의미.  안정 정렬 알고리즘으로는 삽입 정렬, 머지 소트, 카운팅 소트 등이 있다.  제자리 정렬: 원소들의 개수에 비해서 충분히 무시할 만한 저장 공간만을 더 사용하는 정렬 알고리즘들을 의미.  예를 들어 삽입 정렬은 이미 주어진 원소들을 옮긴 뒤 적절한 위치에 원소를 삽입하는 연산을 반복하는데, 이 과정에서 원소들을 담는 공간 외에 추가로 사용될 수 있는 공간은 옮겨지는 원소가 저장되는 공간과 루프 변수 정도에 불과하다.   Algorithm   퀵 소트는 분할 정복 알고리즘으로 피봇 원소를 기준으로 입력 배열을 두개의 부분 배열로 나눈다.(하나는 피봇 보다 작거나 같은 원소들, 하나는 피봇보다 큰 원소들) 그리고 나뉜 두개의 부분 배열을 각각 재귀적으로 다시 분할 정복 정렬 한다.   다음은 퀵 소트의 알고리즘이다. (오름차순 기준)           배열에서 피봇(pivot)을 하나 선정한다.            피봇 값을 기준으로 배열의 원소들을 두 개의 부분 배열로 구분한다. 피봇보다 작은 원소는 피봇의 앞의 부분 배열에, 피봇보다 큰 원소는 피봇의 뒷 부분 배열에 놓는다. 구분이 완료되면 피봇을 배열의 최종적인 위치(원소들을 기준으로 절대적으로 위치해야만 하는 특정 위치)에 놓는다. 이 두 번째 스텝을 분할(Partition)이라고 한다.            피봇을 기준으로 나뉜 두 부분 배열에 대해 위의 1, 2번 연산들을 재귀적으로 적용한다.       Step by Step   실제 예를 들어 퀵 소트가 어떻게 동작 되는지 알아본다.   가정      원소를 오름차순으로 정렬한다.   피봇은 배열의 맨 마지막 원소로 선정한다. (피봇 선정 방법은 여러가지가 있다.)   배열의 크기가 1 이하에 대해서는 퀵 소트를 수행하지 않는다. (크기가 1인 배열은 이미 정렬이 되어있다.)     위 알고리즘의 2번째 스텝 분할(Partition)을 세분화하여 보면 다음과 같다.           배열의 맨 첫번째 원소를 가리키는(인덱스 0) Left 포인터를 둔다.            피봇 바로 앞의 원소를 가리키는(피봇 인덱스 -1) Right 포인터를 둔다.            Left 포인터가 Right 포인터보다 작거나 같을 동안 &amp; Left 포인터가 가리키는 원소가 피봇이 가리키는 원소보다 크거나 같을 때 까지 Left 포인터 위치를 1씩 증가시킨다.            Left 포인터가 Right 포인터보다 작거나 같을 동안 &amp; Right 포인터가 가리키는 원소가 피봇이 가리키는 원소보다 작을 때 까지 Right 포인터 위치를 1씩 감소시킨다.            Left &gt; Right가 아니라면 Left와 Right 포인터가 가리키는 원소를 서로 스왑한다.  그리고 3번으로 간다.            Left &gt; Right이라면 Left가 가리키는 원소와 피봇이 가리키는 원소를 서로 스왑 함으로써 피봇이 가리키던 원소의 최종적인 위치가 정해진다.         다음은 예제에 사용될 배열이다.      맨 마지막 원소를 피봇으로 선정한다.      Left 포인터는 배열의 0 번째 인덱스를 가리키고, Right 포인터는 피봇 바로 앞의 원소를 가리킨다.   위 설명에 따라 포인터를 움직인다.      Left &gt; Right가 아니므로 Left와 Right 포인터가 가리키는 원소를 서로 스왑한다.      알고리즘에 의해 Left와 Right 포인터를 움직인다.      Left &gt; Right가 아니므로 Left와 Right 포인터가 가리키는 원소를 서로 스왑한다.      알고리즘에 의해 Left와 Right 포인터를 움직인다.   Left &gt; Right가 되었다.      Left가 가리키는 원소와 피봇이 가리키는 원소를 서로 스왑한다.      피봇이 가리키는 원소의 최종적인 위치가 정해진 모습이다.   피봇을 기준으로 두개의 부분 배열로 분할이 되고, 왼쪽 부분 배열에는 피봇보다 작은 원소, 오른쪽 부분 배열에는 피봇보다 큰 원소들로 구성되었음을 볼 수 있다.      계속해서 왼쪽 부분 배열에 대해 재귀적으로 퀵 소트를 수행한다.   맨 마지막 원소를 피봇으로 선정한다.      Left 포인터는 배열의 0 번째 인덱스를 가리키고, Right 포인터는 피봇 바로 앞의 원소를 가리킨다.      알고리즘에 의해 포인터를 움직인다.   Left &gt; Right가 되었다.      Left가 가리키는 원소와 피봇이 가리키는 원소를 서로 스왑한다.      피봇이 가리키는 원소 1의 최종적인 위치가 정해진 모습이다.   원소 1을 기준으로 양 옆의 두 부분 배열은 모두 크기가 1 이하이므로 퀵소트를 수행하지 않는다.      원소 2의 최종적인 위치가 정해진 모습이다.      계속해서 3의 오른쪽 부분 배열 [6, 5, 4]가 재귀적으로 정렬이 된다.   맨 마지막 원소를 피봇으로 선정한다.      Left 포인터는 배열의 0 번째 인덱스를 가리키고, Right 포인터는 피봇 바로 앞의 원소를 가리킨다.      알고리즘에 의해 포인터를 움직인다.   Left &gt; Right가 되었다.      Left가 가리키는 원소와 피봇이 가리키는 원소를 서로 스왑한다.      피봇이 가리키는 원소 4의 최종적인 위치가 정해진 모습이다.   원소 4의 왼쪽 부분 배열은 크기가 1 이하이므로, 오른쪽 배열에 대해 재귀적으로 정렬을 수행한다.      맨 마지막 원소를 피봇으로 선정한다.      Left 포인터는 배열의 0 번째 인덱스를 가리키고, Right 포인터는 피봇 바로 앞의 원소를 가리킨다.      알고리즘에 의해 포인터를 움직인다.   Left &gt; Right가 되었다.      Left가 가리키는 원소와 피봇이 가리키는 원소를 서로 스왑한다.      피봇이 가리키는 원소 6의 최종적인 위치가 정해진 모습이다.   원소 6을 기준으로 양 옆의 두 부분 배열은 모두 크기가 1 이하이므로 퀵소트를 수행하지 않는다.      원소 5의 최종적인 위치가 정해진 모습이다.      이로써 퀵 소트를 적용한 정렬이 완료된 모습이다.      Selecting pivot - Median of three   위 방법에서는 피봇을 선정할 때 배열의 맨 마지막 원소로 하였는데, 이렇게 되면 입력으로 이미 정렬이 완료된 배열이 들어왔을 때 최악의 성능을 내게 된다. 이를 방지하기 위한 방법은 의외로 간단한데, 피벗을 선정할 때 임의의 인덱스를 선정하거나 배열의 중간 인덱스를 피봇으로 선정하는 것이다.   보다 효율적인 방법은 세지윅(Sedgewick)이 제안한 것으로 세 개의 중앙값(Median of three)이 있다. 이것은 파티션의 첫번째 값, 중간값, 마지막 값의 중앙값(Median)을 계산하여 이를 피봇으로 선정하는 것이다.   이 세 개의 중앙값 방법은 이미 정렬이 되어있는 배열에 대해서는 아주 적절하며, 임의의 원소를 피봇으로 선정하는 방법보다 피봇을 선정하는데 있어 보다 최적의 추정을 하는 것으로 알려져 있다.   다음은 세 개의 중앙값(Median of three)의 의사코드이다.   mid := (lo + hi) / 2 if A[mid] &lt; A[lo]     swap A[lo] with A[mid] if A[hi] &lt; A[lo]     swap A[lo] with A[hi] if A[mid] &lt; A[hi]     swap A[mid] with A[hi] pivot := A[hi]      lo : 첫번째 값   hi : 마지막 값   mid : 중간값   세 개의 값 중에서 제일 작은 값을 맨 앞(lo)으로 보낸다. 그리고 나머지 두개의 값을 비교해 중앙값을 계산한다. 이A[hi]중앙값을 피봇으로 사용한다.   임의의 피봇 선정 방법의 경우 $n$ 개의 요소를 정렬하는 데 필요한 예상 비교 수는 $1.386 nlogn$이다. 세 개의 중앙값은 예상 스왑 횟수가 3%정도 증가하는 대신 필요한 예상 비교 수를 1.188 n log n으로 낮춘다.   Implementation - java code   다음 코드는 퀵 소트를 자바로 구현한 것이다.   이 코드는 위 알고리즘을 적용하였으며, 피봇 선정은 세 개의 중앙값(Median of three)을 적용하였다.   /**  *  * This program is to sort an array using quick sort algorithm by ascending manner  * Applied Hoare partition scheme and median of three method as a pivot selecting  *  * This implementation is not stable sorting in which the relative position of  * two elements with the same value is preserved  *  * partition:  *  * Select a pivot using median of three method  * Arrange an element that less than or equal pivot key to the left side of pivot  * Arrange an element that greater than pivot key to the right side of pivot  *  * quickSort:  *  * recursively Sort left side and right side of pivot respectively  *  *  * Time Complexity:  *  * Average case performance: O(nlogn) where n is the number of item in an array  *  * Worst case performance: O(n^2)  *  * Best case performance: O(nlogn)  *  *  * Space complexity:  *  * Worst case space: O(n) auxiliary (naive)  *  * @author Gyeong  *  */  import java.util.Arrays;  public class QuickSort {      public static void quickSort(int arr[], int start, int end){         if (start &lt; end){             int pivot = partition(arr, start, end); // partition             quickSort(arr, start, pivot-1); // sort left side of pivot recursively             quickSort(arr, pivot+1, end); // sort right side of pivot recursively         }     }      public static int partition(int arr[], int start, int end){         int left = start;         int right = end-1;         // The median is placed at the end of the array. (end)         medianOfThree(arr, start, end);         // Pivot points to median         int pivot = end;          // Loop until left is less than or equal right         while (left &lt;= right){             // Searching for the item that is greater than pivot item             while (left &lt;= right &amp;&amp; arr[left] &lt;= arr[pivot])                 left++;             // Searching for the item that is less than or equal pivot item             while (left &lt;= right &amp;&amp; arr[pivot] &lt; arr[right])                 right--;             // when right is less than left, sub array was sorted             if (left &gt; right)                 break;              // Elements smaller than the pivot are placed on the left side of pivot             // Elements larger than the pivot are placed on the right side of pivot             swap(arr, left, right);              left++;             right--;         }          // Arrange pivot item to the proper position of the array         swap(arr, left, pivot);          // return pivot index         return left;     }      // Find the median of three numbers and place it at the end of the array     public static void medianOfThree(int arr[], int left, int right){         // The smallest of the three numbers is placed before two numbers          int mid = (left+right)/2;         if (arr[mid] &lt; arr[left])             swap(arr, mid, left);         if (arr[right] &lt; arr[left])             swap(arr, right, left);         // then compare the second and third numbers to determine the median         if (arr[mid] &lt; arr[right])             swap(arr, mid, right);     }      public static void swap(int arr[], int a, int b){         int temp = arr[a];         arr[a] = arr[b];         arr[b] = temp;     }      public static void main(String[] args) {         int arr[] = new int[]{2, 1, 4, 5, 7, 1, 1, 8, 9, 10, 11, 14, 15, 3, 2, 4};         System.out.println(\"Before sorting: \" + Arrays.toString(arr));         quickSort(arr, 0, arr.length-1);         System.out.print(\"After sorting: \" + Arrays.toString(arr));     } }    Output:  Before sorting: [2, 1, 4, 5, 7, 1, 1, 8, 9, 10, 11, 14, 15, 3, 2, 4] After sorting: [1, 1, 1, 2, 2, 3, 4, 4, 5, 7, 8, 9, 10, 11, 14, 15]   Time &amp; Space Complexity   Quick sort   The worst-case performance : $O(n^2)$   The best-case performance : $O(nlogn)$ or $O(n)$ (세 개의 분할, 동일 원소 값)   The average-case performance : $O(nlogn)$   The worst-case space requirement : $O(n)$의 보조 공간   References   Quick sort - wikipedia  Quick sort - codingeek  Quick sort - programiz  ","categories": ["Algorithm"],
        "tags": ["Sort","Array","Mathematics"],
        "url": "http://localhost:4000/algorithm/quick-sort/",
        "teaser":null},{
        "title": "선택 정렬(Selection Sort)",
        "excerpt":"선택 정렬   선택 정렬은 비교기반 제자리 정렬 알고리즘이다.  복잡도는 $O(n^2)$이므로 큰 리스트에는 비효율적이며, 유사한 삽입 정렬보다 성능이 더 떨어지는 것이 일반적이다. 선택 정렬은 단순함이 특징이며 특정한 상황(메모리가 제한적인 경우)에서는 더 복잡한 알고리즘보다 성능상 우위가 있다.   비교기반과 제자리 정렬 이란?   비교기반: 원소들을 정렬할 때 원소들의 순서에만 의존하는 것을 의미.  비교하는 원소들이 숫자거나, 문자열이거나, 심지어는 복잡한 객체에 대해서도 순서가 결정되어 있다면 적용할 수 있다.  제자리 정렬: 원소들의 개수에 비해서 충분히 무시할 만한 저장 공간만을 더 사용하는 정렬 알고리즘들을 의미.  예를 들어 삽입 정렬은 이미 주어진 원소들을 옮긴 뒤 적절한 위치에 원소를 삽입하는 연산을 반복하는데, 이 과정에서 원소들을 담는 공간 외에 추가로 사용될 수 있는 공간은 옮겨지는 원소가 저장되는 공간과 루프 변수 정도에 불과하다.   알고리즘   다음은 선택 정렬의 알고리즘이다. (오름차순)      먼저, 정렬될 리스트에서 가장 최소값을 찾는다.   1번에서 찾은 값을 정렬될 리스트의 맨 처음 위치한 값과 바꾼다. (1 pass)   맨 처음 위치를 제외한 나머지 리스트의 원소들에 대해서 이를 반복한다.   1 pass: 정렬이 되지않은 리스트에서 최소값을 선택해, 리스트의 적절한 위치에 넣는다.   이처럼, n개의 원소를 가진 리스트는 선택 정렬로 n-1번의 패스를 거쳐 정렬이 된다.   비교하는 것이 상수 시간에 이루어진다는 가정 아래, n개의 주어진 리스트를 위와 같은 방법으로 정렬하는 데에는 $O(n^2)$ 만큼의 시간이 걸린다.     다음은 선택 정렬의 애니메이션이다.     예제   다음 예제를 보고 알고리즘을 이해해 보자.   다음과 같은 리스트가 있다고 하자.    List = [64 25 12 22 11] - index: 0...4  List = [정렬 완료 | 미정렬]  1 pass: List[0...4]를 순회하여 최소값인 11을 찾고           이를 0번째 인덱스 위치의 64와 스왑한다.  List = [11 | 25 12 22 64]  2 pass: List[1...4]를 순회하여 최소값인 12을 찾고         이를 1번째 인덱스 위치의 25와 스왑한다.  List = [11 12 | 25 22 64]  3 pass: List[2...4]를 순회하여 최소값인 22을 찾고           이를 2번째 인덱스 위치의 25와 스왑한다.  List = [11 12 22 | 25 64]  4 pass: List[3...4]를 순회하여 최소값인 25을 찾고   이를 3번째 인덱스 위치의 25와 스왑한다.  List = [11 12 22 25 | 64]  n-1번의 pass로 리스트의 정렬이 완료되었다.   구현   다음은 선택 정렬을 C로 구현한 코드이다.   /* a[0] to a[aLength-1] is the array to sort */ int i,j; int aLength; // initialise to a's length  /* advance the position through the entire array */ /*   (could do i &lt; aLength-1 because single element is also min element) */ for (i = 0; i &lt; aLength-1; i++) {     /* find the min element in the unsorted a[i .. aLength-1] */      /* assume the min is the first element */     int jMin = i;     /* test against elements after i to find the smallest */     for (j = i+1; j &lt; aLength; j++)     {         /* if this element is less, then it is the new minimum */         if (a[j] &lt; a[jMin])         {             /* found new minimum; remember its index */             jMin = j;         }     }      if (jMin != i)      {         swap(a[i], a[jMin]);     } }   다음은 선택 정렬을 자바로 구현한 코드이다.   void selectionSort(int[] list) {     int indexMin, temp;      for (int i = 0; i &lt; list.length - 1; i++) {         // Lowest position         indexMin = i;         for (int j = i + 1; j &lt; list.length; j++) {             if (list[j] &lt; list[indexMin]) {                 indexMin = j;             }         }         // Swap         temp = list[indexMin];         list[indexMin] = list[i];         list[i] = temp;     } }   시간복잡도 &amp; 공간복잡도   시간복잡도 분석   $n$ $(n-1…1)$개의 원소를 매 패스마다 스캔하여 적절한 위치와 스왑한다.  n개의 원소가 있다면 $n-1$의 패스를 가진다.     등차수열에 의해,     비교의 측면에서 볼 때, 복잡도는 $O(n^2)$이다.   교환은 매 패스마다 한 번씩 일어난다. 즉, $n-1$번 복잡도는 $O(n)$  (마지막 원소는 이미 정렬되어 있다.)  **Selection sort**  Class\t            정렬 알고리즘  Data structure\t    배열  Worst-case          О(n^2) 비교 performance         О(n) 교환  Best-case           О(n^2) 비교 performance         О(n) 교환  Average             О(n^2) 비교 performance         О(n) 교환  Worst-case          O(1) 추가 공간 space complexity\t   References   Selection sort  Selection sort - GIF  ","categories": ["Algorithm"],
        "tags": ["Sort","Array"],
        "url": "http://localhost:4000/algorithm/selection-sort/",
        "teaser":null},{
        "title": "힙(Heap)-예정 포스트",
        "excerpt":" ","categories": ["Data Structure"],
        "tags": ["Array"],
        "url": "http://localhost:4000/data%20structure/heap/",
        "teaser":null},{
        "title": "크루스칼 알고리즘(Kruskal's Algorithm)",
        "excerpt":"들어가기 전에: 크루스칼 알고리즘에는 다음의 선행지식이 필요합니다.     스패닝 트리와 최소 스패닝 트리   Union Find - 서로소 집합     크루스칼 알고리즘(Kruskal’s Algorithm)   크루스칼 알고리즘(Kruskal’s Algorithm)은 연결 가중치 그래프(connected weighted graph)에서 최소 스패닝 트리(Minimum spanning tree)를 찾는 알고리즘이다. 알고리즘 과정에서 볼 때 그래프의 숲(forest)관점에서 여러개의 트리 중 서로 다른 집합의 두 트리를 연결하는 가능한 최소 가중치 간선(least possible weighted edge)을 찾는 작업을 수행한다.   그래프 이론에서는 그리디 알고리즘의 하나로서 알고리즘의 매 과정마다 최소 가중치 간선을 하나씩 선택해 추가하는 작업을 하면서 연결 가중치 그래프에서 최소 스패닝 트리를 찾는다. 그리하여 모든 정점을 포함하고 간선들의 서브셋인 스패닝 트리를 형성하게 하고, 생성된 스패닝 트리의 모든 간선의 가중치 합을 최소로 만든다.   그래프가 연결 그래프가 아니라면, 크루스칼 알고리즘은 최소 스패닝 숲(Minimum spanning forest)을 찾는다. (비 연결 그래프 내의 각 연결된 그래프에서의 최소 스패닝 트리)   알고리즘   크루스칼 알고리즘이 어떻게 동작하는지 살펴보자.   그래프 G가 주어졌다고 하자. (여기서는, 비 연결 그래프, 연결 그래프 구분하지 않는다.)           그래프 G의 모든 정점이 분리된 트리들의 집합인 숲(Forest) F를 생성한다.  여기서 숲은 분리된 트리들의 집합이다. (a set of trees)            그래프 G의 모든 간선을 포함하는 집합 S를 생성한다.            While 집합 S가 공집합이 아니고 &amp;&amp; 숲 F가 스패닝 트리가 아니면             집합 S에서 가장 최소 가중치의 간선을 하나 선택하고 S로 부터 삭제한다.       선택된 간선이 서로 다른 두 트리를 연결한다면 숲 F에 선택된 간선을 추가한다.    이것은 두 트리를 하나의 트리로 합치는 것이다.           알고리즘이 끝나고, 그래프 G가 비 연결 그래프 였다면 숲 F는 다중 컴포넌트(Trees)의 최소 스패닝 숲(MSF)을 형성하고, 그래프 G가 연결 그래프 였다면 숲 F는 단일 컴포넌트의 최소 스패닝 트리(MST)를 형성하게 된다.     다음은 크루스칼 알고리즘의 Animation이다.         파란색 간선은 현재 집합 S에서 선택한 간선   빨간색 간선은 집합 S에서 선택한 간선을 숲 F에 추가한 간선이다.   사이클을 형성하지 않으면서 간선들을 하나씩 추가하며 정점의 개수가 V라면 V-1개의 간선을 가진 최소 스패닝 트리를 구성하고 있는 모습이다.   의사코드   다음은 크루스칼 알고리즘의 의사코드이다. (Union Find 자료구조 사용)   Warning: 의사코드에는 Union Find - 서로소 집합 자료구조가 사용이 되므로 모른다면 반드시 알고와야 이해가 가능하다.   algorithm Kruskal(G) is     // 공집합으로 초기화     A := ∅     // 그래프 G의 모든 정점에 대해서     for each v ∈ G.V do         // 모든 정점들을 하나의 독립된 트리로 만들어 준다.         MAKE-SET(v)     // 그래프 G의 모든 간선들에 대해서 (간선들은 전부 오름차순으로 나열 되어있다.)     for each (u, v) in G.E ordered by weight(u, v), increasing do         // u와 v가 속한 집합이 서로 다르면 (서로 다른 집합의 트리라면)         if FIND-SET(u) ≠ FIND-SET(v) then            // u, v를 정점으로 하는 간선 (u, v)를 집합 A에 포함 시킨다.            A := A ∪ {(u, v)}            // 두 집합 u, v를 하나의 집합으로 합친다.            UNION(FIND-SET(u), FIND-SET(v))     return A   예제   예를 들어 크루스칼 알고리즘이 어떻게 동작하는지 하나씩 알아보자.   다음의 그래프에서 크루스칼 알고리즘을 적용해 최소 스패닝 트리를 찾아본다.   Graph G:        다음은 위 그래프의 가중치 간선들의 정보이다.   Edge\tAE   AD   AC   AB   BC   CD   DE Weight\t6    10   4    1    3    5    2   먼저, 간선들을 가중치에 따라 오름차순으로 정렬한다.   Edge\tAB   DE   BC   AC   CD   AE   AD Weight\t1    2    3    4    5    6    10    MST 구축을 시작한다.   위 간선 집합에서 가중치가 1로 제일 작은 최소 가중치 간선인 AB를 선택한다.  정점 A와 정점B는 서로 다른 집합이므로 간선 AB를 MST에 추가한다.   MST:    이번에는 AB를 선택했으니 그 다음으로 가중치가 작은 간선을 선택한다. 여기서는 가중치가 2인 간선 DE를 선택한다.   정점D와 정점E는 서로 다른 집합이므로 간선 DE를 MST에 추가한다.   MST:    계속해서, DE를 선택했으니 그 다음으로 가중치가 작은 간선을 선택한다. 여기서는 가중치가 3인 간선 BC를 선택한다.   정점B와 정점C는 서로 다른 집합이므로 간선 BC를 MST에 추가한다.   MST:    계속해서, BC를 선택했으니 그 다음으로 가중치가 작은 간선을 선택한다. 여기서는 가중치가 4인 간선 AC를 선택한다.   그러나 정점A와 정점C는 서로 이미 같은 집합에 속해 있다. 따라서 간선 AC를 추가하면 사이클이 생긴다는 것을 알 수 있다.   MST:    MST는 트리이므로 사이클이 없어야 한다는 것을 알고있다. 따라서, 간선 AC는 버린다.   계속해서, 간선 AC 다음으로 가중치가 작은 간선을 선택한다. 여기서는 가중치가 5인 간선 CD를 선택한다.   정점C와 정점D는 서로 다른 집합이므로 해당 정점들을 끝점으로 하는 간선을 추가해도 사이클을 형성하지 않는다. 간선 CD를 MST에 추가한다.   MST:    이로서 그래프 G의 모든 정점을 포함하고 4개(V-1)의 간선으로 구성되는 최소 스패닝 트리(MST)가 완성이 되었다.   위 트리의 모든 간선의 가중치 합은 11로서 그래프 G에서 나올 수 있는 스패닝 트리 중 가장 작은 가중치의 합을 가진 스패닝 트리가 된다.   구현   다음은 유니온 파인드 자료구조를 이용하여 크루스칼 알고리즘을 구현한 C++ 코드이다.   그래프는 위의 예제를 이용하였다.   예제 입력은 다음과 같다.      그래프의 정점의 수와 간선의 수를 입력한다.  nodes, edges   그 다음 그래프의 각 간선별 정보를 입력한다.  x, y, weight   결과 출력은 다음과 같다.      해당 그래프의 MST 간선 가중치 총합을 출력한다.  Minimum cost is ?   Kruskal’s algorithm - C++ Code   #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;utility&gt; #include &lt;algorithm&gt; using namespace std; const int MAX = 1e4 + 5; int id[MAX], ranks[MAX], nodes, edges;  // Edge array : weight, (u, v) pair &lt;long long, pair&lt;int, int&gt; &gt; p[MAX];  // Make set initialization void init() {     for(int i = 0;i &lt; MAX;++i) {         id[i] = i;         ranks[i] = 0;     } }  // Find with path compression int root(int x) {     if (id[x] == x)         return x;     else         // Recursion         return id[x] = root(id[x]); }  // union by rank void union1(int x, int y) {     int p = root(x);     int q = root(y);      if (p == q) // 루트가 같다면 수행하지 않는다.         return;      // p의 랭크가 q의 랭크보다 크다면     if (ranks[p] &gt;= ranks[q]) {         // q가 p의 밑으로 되게 합친다.         id[q] = id[p];     } else { // 위의 if문 과 반대         id[p] = id[q];     }     // 두 트리의 랭크가 같다면, 랭크를 1만큼 키운다.     if (ranks[p] == ranks[q])         ranks[p]+=1; }  // Find MST long long kruskal(pair&lt;long long, pair&lt;int, int&gt; &gt; p[]) {     int x, y;     int cnt = 0;     long long cost, minimumCost = 0;     for(int i = 0; i &lt; edges; ++i)     {         x = p[i].second.first;         y = p[i].second.second;         cost = p[i].first;         if(root(x) != root(y))         {             minimumCost += cost;             union1(x, y);             cnt++;         }         if (nodes-1 == cnt)             break;     }     return minimumCost; }  int main() {     int x, y;     long long weight, minimumCost;     init();     cout &lt;&lt;\"Enter Nodes and edges\";     cin &gt;&gt; nodes &gt;&gt; edges;     for(int i = 0;i &lt; edges;++i)     {         cout&lt;&lt;\"Enter the value of X, Y and edges\";         cin &gt;&gt; x &gt;&gt; y &gt;&gt; weight;         p[i] = make_pair(weight, make_pair(x, y));     }     sort(p, p + edges);     minimumCost = kruskal(p);     cout &lt;&lt;\"Minimum cost is \"&lt;&lt; minimumCost &lt;&lt; endl;     return 0; }   Output  Enter Nodes and edges 5 7 Enter the value of X, Y and edges 1 2 1 Enter the value of X, Y and edges 2 3 3 Enter the value of X, Y and edges 1 3 4 Enter the value of X, Y and edges 1 5 6 Enter the value of X, Y and edges 3 4 5 Enter the value of X, Y and edges 1 4 10 Enter the value of X, Y and edges 4 5 2 Minimum cost is 11   References   Kruskal’s Algorithm - java T point  Kruskal’s Algorithm  ","categories": ["Algorithm"],
        "tags": ["Graph","Union Find","Spanning Tree","Greedy"],
        "url": "http://localhost:4000/algorithm/kruskal/",
        "teaser":"http://localhost:4000/assets/images/kruskal-algorithm-solution3.png"},{
        "title": "카운팅 소트(Counting sort)",
        "excerpt":"카운팅 소트(Counting sort)   계수 정렬이라고도 하며, 점근적 복잡도 O(n+k)를 가지는 선형 정렬 알고리즘이다.      n: 정렬될 입력 배열의 원소 개수.   k: 정렬될 입력 배열의 가장 큰 키 값.   이 정렬 알고리즘은 특정한 조건하에 매우 효율적이며 같은 키값을 가진 원소에 대해 안정적이다. 버블소트와 머지소트와는 다르게, 이 알고리즘은 비교기반 정렬이 아니므로 원소 간에 비교를 하지 않고, 리스트의 O(1)의 삽입 및 조회 연산을 사용해 동작한다.   카운팅 소트는 정수의 특정 범위 사이에서 동작하며, 특정 키 값의 개체의 수를 세아려 이 정보를 보조 배열에 기록한다. 이 정보와 산술계산을 사용하여 각 키 값을 정렬될 결과 리스트의 특정 위치에 배치시킨다.   이 정렬 알고리즘은 정렬될 수의 범위가 정렬될 원소의 개수보다 심하게 크지 않을 때 적합하다.  그리고, 실행시간은 $O$(가장 큰 키 값 - 가장 작은 키 값)이 되므로 정렬될 수의 범위 또는 가장 큰 키 값(K)가 크지 않을 때 적합하다. 그렇지 않으면 보다 비효율적이다.   카운팅 소트는 안정 정렬에 속하고 제자리 정렬이 아니다. 이는 특정 원소의 키 값 개수를 추적할 추가적인 $O(K)$공간을 요구한게 된다.   안정 정렬과 제자리 정렬 이란?   안정 정렬: 정렬되기 전에 같은 키 값을 가진 원소들의 상대적인 위치나 순서는 정렬이 끝나도 변하지 않고 그대로 유지되는 것을 의미.  안정 정렬 알고리즘으로는 삽입 정렬, 머지소트, 카운팅 소트 등이 있다.  제자리 정렬: 원소들의 개수에 비해서 충분히 무시할 만한 저장 공간만을 더 사용하는 정렬 알고리즘들을 의미.  예를 들어 삽입 정렬은 이미 주어진 원소들을 옮긴 뒤 적절한 위치에 원소를 삽입하는 연산을 반복하는데, 이 과정에서 원소들을 담는 공간 외에 추가로 사용될 수 있는 공간은 옮겨지는 원소가 저장되는 공간과 루프 변수 정도에 불과하다.   카운팅 소트에 제약사항으로는 정수 같은 이산적인(Discrete)값들만 정렬 할 수 있고, 입력된 배열을 정렬하기 전에 가장 큰 값 K(범위)를 사전에 알고 있어야 한다.   의사 코드   다음은 카운팅 소트의 의사 코드이다.    // params A: 입력 배열, k: 가장 큰 키 값, n: 입력 배열 원소의 개수 CountingSort(A, n, k,)   // 특정 키 값의 원소 개수를 추적할 c[], 결과 배열 B[]를 준비한다.   c[k+1], B[n+1]    // C[]를 0으로 전부 초기화 한다.   for i = 0 to k do      c[i] = 0    //Complexity: O(n)   for j = 0 to n do     // 특정 키 값의 원소의 개수를 세아린다.     c[A[j]] = c[A[j]] + 1    ////Complexity: O(k)   for i = 1 to k do     // 결과 배열 B[]에 저장될 실제 인덱스 위치를 구한다.     c[i] = c[i] + c[i-1]    //Complexity: O(n)   for j = n-1 down to 0 do     //결과 배열을 구한다.     B[c[A[j]]] = A[j]     c[A[j]] = c[A[j]] - 1  end func   카운팅 소트 - 예제   예제로 카운팅 소트 알고리즘을 이해해 본다.           먼저 정렬 될 입력 배열이다.  그리고, 특정 키 값의 원소 개수를 저장할 배열 Count[k+1], 정렬 결과를 저장할 배열 Result[n+1]를 준비한다.  여기서 k는 입력 배열의 가장 큰 값인 11이고, n은 입력 배열의 원소 개수인 11이다.            입력 배열을 처음부터 끝까지 순회하면서 Count[]에 원소의 특정 키 값을 인덱스로 하여 개수를 기록한다. 그러면, 다음 그림과 같이 Count[] 배열이 완성된다.  위 그림에서 Count[2]은 1인데 이 의미는 실제 입력 배열의 2를 키 값으로 하는 원소가 1번 등장 했다는 것을 의미한다. 마찬가지로 Count[1]은 2인데 이 의미는 실제 입력 배열의 1을 키 값으로 하는 원소가 2번 등장 했다는 것을 의미한다. 이렇게 입력 배열의 특정 키 값을 Count[]의 인덱스로 하여 등장횟수 만큼 +1씩 증가시키며 기록해 준다.            Result[]에 저장될 특정 키 값의 실제 위치를 표현하기 위해 Count[]의 Prefix sum을 구한다.   위 그림의 Modified Count[]의 값은 Count[i] = Count[i] + Count[i-1]를 한 값이다.  이 값은 Result[] 배열에 저장될 원소들의 위치 인덱스 값을 계산하는 것이다.            입력 배열을 순회하면서 결과 배열을 계산한다.  앞에서 계산해둔 Count[]의 정보를 이용해서 결과 배열을 계산해보자.  인덱스 i는 0부터 시작하여, 입력 배열의 맨 처음 원소는 2이다. input[0] = 2  Count[input[i]] = Count[2] 이 값은 Result[]에 저장될 input[i]의 위치를 말해준다.  Count[]을 보자. 여기서 Count[input[i]] 값은 3이다. 즉, Result[Count[input[i]]] = input[i] -&gt; Result 배열 3번 인덱스 위치에는 2가 저장이 된다.  그 다음, 입력 배열에 같은 키 값을 가진 원소들이 2개 이상 있을 수 있는데(예제 입력 배열에서는 1이 2개) 결과 배열의 같은 인덱스에 저장되어 알고리즘의 오류를 피하기 위해 Count[input[j]] = Count[input[j]] - 1를 해야 한다. 이것은 같은 키 값을 가지는 원소들을 결과 배열에 저장할 때 한 칸씩 서로 다른 위치에 저장이 되게 한다. 앞에서 prefix sum을 계산한 이유가 이것이다.  이렇게 입력 배열 끝까지 순회하며 계산해주면 밑의 그림과 같이 Result배열이 완성된다.        실제 정렬된 배열은 Result[]의 [1번 인덱스 … n번 인덱스]이다. 위 그림에서 보이듯이 0번 인덱스가 거슬린다면 Result[]의 크기를 Result[n]로 초기화 하고 Result[Count[input[i]]] = input[i]에서 왼쪽 항에 -1을 넣어주자. =&gt; Result[Count[input[i]] -1] 이는 한칸 씩 앞으로 당겨 저장함을 의미한다.   자바 코드   다음은 카운팅 소트의 자바 코드이다.   import java.util.Arrays;  public class CountingSort {  \tpublic int[] sort(int[] A) { \t\tint[] Result = new int[A.length + 1]; \t\tint[] Count = new int[A.length + 1];  \t\tfor (int i = 0; i &lt; Count.length; i++) { \t\t\tCount[i] = 0; // put count for every element as 0 \t\t} \t\t// Count[] will store the counts of each integer in the given array \t\tfor (int i = 0; i &lt; A.length; i++) { \t\t\tint x = Count[A[i]]; \t\t\tx++; \t\t\tCount[A[i]] = x; \t\t} \t\t// • Update the Count[] so that each index will store the sum till \t\t// previous step. (Count[i]=Count[i] + Count[i-1]). \t\t// Now updated Count[] array will reflect the actual position of each \t\t// integer in Result[]. \t\tfor (int i = 1; i &lt; Count.length; i++) { \t\t\tCount[i] = Count[i] + Count[i - 1]; \t\t} \t\t// • Now navigate the input array taking one element at a time, \t\t// Count[input[i]] will tell you the index position of input[i] in \t\t// Result[]. When you do that, decrease the count in Count[input[i]] by \t\t// 1. \t\tfor (int i = A.length - 1; i &gt;= 0; i--) { \t\t\tint x = Count[A[i]]; \t\t\tResult[x] = A[i]; \t\t\tx--; \t\t\tCount[A[i]] = x; \t\t} \t\treturn Result;  \t}  \tpublic static void main(String[] args) { \t\t// TODO Auto-generated method stub \t\tint input[] = { 2, 1, 4, 5, 7, 1, 1, 8, 9, 10, 11, 14, 15, 3, 2, 4 }; \t\tSystem.out.println(\"Orginal Array: \" + Arrays.toString(input)); \t\tCountingSort c = new CountingSort(); \t\tint[] B = c.sort(input); \t\tSystem.out.println(\"Sorted Array: \" + Arrays.toString(B)); \t} }    Output: Orginal Array: [2, 1, 4, 5, 7, 1, 1, 8, 9, 10, 11, 14, 15, 3, 2, 4] Sorted Array: [0, 1, 1, 1, 2, 2, 3, 4, 4, 5, 7, 8, 9, 10, 11, 14, 15]   시간복잡도 &amp; 공간 복잡도   이 정렬 알고리즘은 재귀나 서브루틴(함수)콜을 사용하지 않고 1차원의 다소 심플한 for loop만 되어 있으므로 복잡도 분석이 꽤 간단한 편이다. Count[]의 prefix sum 계산이 최대 k+1번 수행되므로 O(k), Count[]의 계산과 Result[]의 계산은 n번 계산되므로 O(n)이다.   따라서 이 알고리즘의 전체 시간복잡도는 이 두개의 합인 O(n+k)가 된다.   **Counting sort**  Class\t            정렬 알고리즘  Data structure\t    배열  Worst-case          О(n+k)  performance        Worst-case          О(n+k)  space complexity\t  * n은 원소의 개수, k는 음수가 아닌 키 값의 범위   참고하면 좋은 자료   카운팅 소트를 시각화한 애니메이션으로 참고하면 좋다.   Counting Sort visualization   Reference   Counting sort - wikipedia  Counting sort - codingeek  Counting sort - algorithms.tutorialhorizon  ","categories": ["Algorithm"],
        "tags": ["Sort","Array"],
        "url": "http://localhost:4000/algorithm/counting-sort/",
        "teaser":null},{
        "title": "깊이우선탐색(Depth First Search, DFS)",
        "excerpt":"깊이우선탐색(Depth First Search, DFS)   깊이우선탐색(DFS)은 트리나 그래프 혹은 다른 구조 상에서 탐색을 위한 알고리즘이다. 이 알고리즘은 루트 노드를 시작으로(그래프의 경우에는 임의의 노드를 루트 노드로 정하게 된다.) 탐색을 하다가 더 이상 갈 수 없어 백트랙 하기 전까지 가능한 한 가지를 따라 깊게 멀리 탐색한다.   시간 및 공간 복잡도 분석은 많은 응용분야에 따라 다른데, 이론적인 컴퓨터 과학 분야에서 DFS는 전체 그래프를 탐색하는데 사용되기 때문에 수행 시간은 선형인 $O(|V|+|E| )$가 된다. 공간 복잡도면을 보면 DFS는 경로상의 현재 탐색하고 있는 정점과 경로상 이미 방문한 정점들의 스택을 저장하고 있기 때문에 최악 $O(|V|)$의 공간을 요구한다. ($|V|$는 정점의 수, $|E|$는 간선의 수이다.)   깊이우선탐색(DFS)의 시간 및 공간 상한은 너비우선탐색(BFS)과 같기 때문에, 탐색 알고리즘의 사용면에서 두 알고리즘이 만드는 정점 방문 순서의 다름과 그 복잡성을 생각해 어느 알고리즘을 사용해야 할지 생각해야한다.   예제   다음 그래프를 보고 깊이우선탐색이 어떤 것인지 이해해보자.      가정      현재 방문하고 있는 정점에서 인접한 왼쪽 간선을 오른쪽 간선보다 먼저 선택한다고 가정한다.   탐색 알고리즘은 현재 정점의 이전 정점의 방문을 기억한다고 가정한다.   정점들의 방문은 중복되지 않는다고 가정한다.     먼저 A를 루트 노드로 하여 탐색을 시작한다.           A를 방문하고 위의 가정에 따라 인접 정점 C, E를 탐색하기 전에 B를 먼저 탐색한다.            B를 방문하고 F를 탐색하기 전에 D를 먼저 탐색한다.            D를 방문하고 D의 인접한 정점은 B이지만 이미 방문하였기에 더 이상 탐색할 곳이 없으므로, 이전 정점 B로 백트래킹 한다.            정점 B에서 F를 탐색한다.            F를 방문하고 아직 탐색하지 않은 인접 정점인 E를 탐색한다.            E를 방문하고 나면 인접 정점들은 모두 방문한 상태이므로 이전 정점 F로 백트래킹 한다.            F에서도 인접 정점들은 모두 방문한 상태이므로 이전 정점 B로 백트래킹 한다.            B에서도 인접 정점들은 모두 방문한 상태이므로 이전 정점 A로 백트래킹 한다.            A에서 인접한 정점 중 아직 탐색하지 않은 곳은 C이므로 C를 탐색한다.            C를 방문하고 아직 탐색하지 않은 곳인 G를 탐색한다.            G를 방문한다.            G에서 인접 정점들은 모두 방문한 상태이므로 이전 정점 C로 백트래킹 한다.            C에서 인접 정점들은 모두 방문한 상태이므로 이전 정점 A로 백트래킹 한다.            A에서 모든 인접 정점이 방문 완료 되었으므로 DFS는 완료되었다.       이로서, DFS에 의한 위 그래프의 정점들 방문 순서는 : A, B, D, F, E, C, G 이다.   의사코드   깊이우선탐색(DFS)을 하는 두가지 방법을 알아본다.   서브루틴을 이용한 재귀적 방법   Input: 그래프 G, 그래프 G의 정점 v  Output: v로 부터 탐색 가능한 모든 정점들   다음은 서브루틴을 이용한 재귀적 방법의 의사코드이다.   procedure DFS(G, v) is     label v as discovered     for all directed edges from v to w that are in G.adjacentEdges(v) do         if vertex w is not labeled as discovered then             recursively call DFS(G, w)   한 구문씩 보자.      label v as discovered: 현재 정점 v를 탐색완료 되었다는 것을 표시한다. (중복 방문 방지를 위해)   for all directed edges from v to w that are in G.adjacentEdges(v) do: 그래프 G의 모든 인접한 간선 (v, w)에 대해서   if vertex w is not labeled as discovered then: 만약 w가 탐색되지 않았으면   recursively call DFS(G, w): 재귀적으로 w를 탐색한다.  이것은 현재 정점 v의 인접 정점 w를 매개변수로 하여 같은 서브루틴으로 다음 정점을 탐색하는 것을 의미한다.   이 방법의 최악 공간 복잡도는 $O(|V|)$가 된다.  현재 탐색하고 있는 경로의 정점들과 이미 방문한 정점들의 스택을 저장하고 있기 때문이다.   스택을 이용한 반복적인 방법   Input: 그래프 G, 그래프 G의 정점 v  Output: v로 부터 탐색 가능한 모든 정점들   다음은 스택을 이용한 반복적인 방법의 의사코드이다.  procedure DFS-iterative(G, v) is     let S be a stack     S.push(v)     while S is not empty do         v = S.pop()         if v is not labeled as discovered then             label v as discovered             for all edges from v to w in G.adjacentEdges(v) do                  S.push(w)   한 구문씩 보자.      let S be a stack: S라는 스택을 하나 생성한다. 현재 방문 정점의 인접 정점들을 담는다.   S.push(v): 탐색하고자 하는 시작 정점 v를 스택에 push한다.   while S is not empty do: 스택이 빈 공간이 아닐 때 까지 아래 연산들을 반복한다. v = S.pop(): 현재 탐색 하고 있는 정점을 v에 넣는다.   if v is not labeled as discovered then label v as discovered: 만약 v가 탐색되지 않았으면, 탐색 완료 표시를 한다.   for all edges from v to w in G.adjacentEdges(v) do                S.push(w): 현재 정점 v의 모든 인접한 정점 w를 스택에 넣는다.   이 방법의 최악 공간 복잡도는 $O(|E|)$가 된다.  재귀적인 방법과는 달리, 어떤 해당 정점에서 인접 정점들의 정보를 모두 스택에 저장하기 때문에, 최악의 설정으로 하나의 정점이 다른 모든 정점과 직접 연결되어 있다면 공간 복잡도는 $O(|E|)$가 된다.   두 가지 접근의 차이점   위에서 살펴본 두 가지 DFS의 탐색 방법은 각 정점들의 이웃방문 순서가 서로 반대인데, 재귀적인 방법에서는 인접리스트 방식에서 정점 v의 첫번째 이웃을 먼저 방문하는 반면, 스택을 이용한 반복적인 방법에서는 정점 v의 이웃들이 스택에 역순으로 저장되기 때문에 인접 리스트 관점에서 정점 v의 첫번째 이웃은 제일 마지막(first in last out)에 탐색이 된다.   위 그래프를 예로 들면 재귀적인 방법으로의 방문 순서는 A, B, D, F, E, C, G가 되고, 스택을 이용한 반복적 접근에서는 A, E, F, B, D, C, G가 된다.   응용   DFS 탐색 알고리즘은 많은 곳에서 쓰이는데 예는 다음과 같다.      미로 찾기   그래프의 위상 정렬   모든 경우 다 해보기(전체 탐색)   연결 구성 요소 찾기   이분 그래프   링크   프로그래밍 언어로의 구현은 다음 글을 참고하면 좋다.      DFS Implementation Using Recursion   DFS Implementation Using Stack   시간 복잡도 &amp; 공간 복잡도      시간 복잡도: 최악 $O(|V|+|E| )$ (중복 방문 제외)   공간 복잡도: 최악 $O(|V|)$ (알고리즘이 재귀적 일 때)   References      Wikipedia   JavaTpoint   Algorithms  ","categories": ["Algorithm"],
        "tags": ["Search Algorithm","DFS","Stack","Recursive","Graph","Tree","Back Tracking"],
        "url": "http://localhost:4000/algorithm/DFS/",
        "teaser":null},{
        "title": "깊이우선탐색(DFS) 구현 - Iterative using stack",
        "excerpt":"깊이우선탐색 글 참고하기      Depth First Search   그래프의 구현 글 참고하기      Graph     이번 글에서는 스택을 사용한 DFS를 이해하고 구현해 봅니다.   깊이우선탐색(Depth First Search, DFS)   깊이우선탐색(DFS)은 트리나 그래프 혹은 다른 구조 상에서 탐색을 위한 알고리즘이다. 이 알고리즘은 루트 노드를 시작으로(그래프의 경우에는 임의의 노드를 루트 노드로 정하게 된다.) 탐색을 하다가 더 이상 갈 수 없어 백트랙 하기 전까지 가능한 한 가지를 따라 깊게 멀리 탐색한다.   시간 및 공간 복잡도 분석은 많은 응용분야에 따라 다른데, 이론적인 컴퓨터 과학 분야에서 DFS는 전체 그래프를 탐색하는데 사용되기 때문에 수행 시간은 선형인 $O(|V|+|E| )$가 된다. 공간 복잡도면을 보면 스택을 사용한 DFS는 최악 $O(|E|)$의 복잡도를 가진다. 재귀적인 방법과는 달리, 해당 정점에서 방문하지 않은 인접 정점들의 정보를 모두 스택에 저장하기 때문에, 최악 $O(|E|)$가 된다. ($|V|$는 정점의 수, $|E|$는 간선의 수이다.)   알고리즘   우선, 방문할 인접 정점들을 저장할 Stack과 정점들의 방문 표시를 할 visited[] 배열을 선언한다.   스택을 이용한 DFS 알고리즘은 다음과 같은 순서로 실행된다.           탐색을 시작할 스타팅 노드를 스택에 넣는다.            스택이 빈 공간이 아닐 때 까지 다음을 실행한다.            스택에서 정점 하나를 꺼내 방문하지 않았으면 방문 표시를 하고 그 정점에 인접한 모든 정점을 스택에 넣는다.(방문 하지 않은 정점들만)            2번으로 간다.       예제   예를 들어 DFS 알고리즘을 이해 해보자.   방문 우선순위: 현재 정점과 인접한 정점이 여러개면 번호가 [작은 순서대로] 방문한다.   아래와 같은 정점 5개로 이루어진 비방향 그래프로 DFS를 시작한다.   탐색은 0번 정점부터 시작한다고 가정한다.      위 알고리즘에 따라 탐색을 시작할 0번 정점을 스택에 넣는다.      스택에서 가장 위에있는 원소를 하나 꺼낸다. (여기서는 제일 왼쪽 칸이 top이다.) 0번 정점을 방문표시 하고 0번 정점과 인접한 정점들 중에서 방문하지 않는 정점들을 모두 스택에 넣는다.   0번 정점과 1, 2, 3번 정점이 인접해 있다. 위의 방문 우선순위에 따라 인접한 정점이 여러개면 번호가 [작은 순서대로] 방문해야 하므로 3, 2, 1순으로 스택에 삽입한다. (후입 선출)      계속해서, 스택에서 가장 위에있는 1번 정점을 꺼낸다. 1번 정점을 방문표시 하고 1번 정점과 인접한 정점들 중에서 방문하지 않는 정점들을 모두 스택에 넣는다.  여기서는 2번 정점을 스택에 삽입한다.      그 다음, 스택에서 가장 위에있는 2번 정점을 꺼낸다. 2번 정점을 방문표시 하고 2번 정점과 인접한 정점들 중에서 방문하지 않는 정점들을 모두 스택에 넣는다.  여기서는 4번 정점을 스택에 삽입한다.      그 다음, 스택에서 가장 위에있는 4번 정점을 꺼낸다. 4번 정점을 방문표시 하고 4번 정점과 인접한 정점들 중에서 방문하지 않는 정점들을 모두 스택에 넣는다.  4번 정점과 인접한 정점 중에서는 방문하지 않은 정점들이 없으므로 다음 스탭으로 간다.      그 다음, 스택에서 가장 위에있는 3번 정점을 꺼낸다. 3번 정점을 방문표시 하고 3번 정점과 인접한 정점들 중에서 방문하지 않는 정점들을 모두 스택에 넣는다.  3번 정점과 인접한 정점 중에서는 방문하지 않은 정점들이 없으므로 다음 스탭으로 간다.      알고리즘 2번에 의해 스택이 모두 비었으니 알고리즘을 끝낸다.   스택을 이용한 DFS의 방문순서는 0 1 2 4 3 순이다.   구현   의사코드   스택을 이용한 반복적인 방법   Input: 그래프 G, 그래프 G의 정점 v  Output: v로 부터 탐색 가능한 모든 정점들   procedure DFS-iterative(G, v) is     let S be a stack     S.push(v)     while S is not empty do         v = S.pop()         if v is not labeled as discovered then             label v as discovered             for all edges from v to w in G.adjacentEdges(v) do                 if w is not labeled as discovered then                    S.push(w)   한 구문씩 보자.      let S be a stack: S라는 스택을 하나 생성한다. 현재 방문 정점의 인접 정점들을 담는다.   S.push(v): 탐색하고자 하는 시작 정점 v를 스택에 push한다.   while S is not empty do: 스택이 빈 공간이 아닐 때 까지 아래 연산들을 반복한다.            v = S.pop():현재 탐색 하고 있는 정점을 v에 넣는다.       if v is not labeled as discovered then label v as discovered: 만약 v가 탐색되지 않았으면, 탐색 완료 표시를 한다.       for all edges from v to w in G.adjacentEdges(v) do if w is not labeled as discovered then S.push(w): 현재 정점 v의 모든 인접한 정점 w를 스택에 넣는다. (w가 방문되지 않았으면)             자바 프로그램   위 의사코드를 바탕으로 스택을 이용한 DFS 알고리즘 자바 코드는 다음과 같다.   public void DFS(int start){     boolean[] visited = new boolean[vertex];     Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;();     stack.push(start);     while (!stack.isEmpty()){         int v = stack.pop();         if (!visited[v]){             visited[v] = true;             for (int i = 0; i &lt; list[v].size(); i++){                 int dest = list[v].get(i);                 if (!visited[dest])                     stack.push(dest);             }         }     } }   위의 코드 설명   boolean[] visited = new boolean[vertex]; Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;();   방문할 인접 정점들을 저장할 Stack과 정점들의 방문 표시를 할 visited[] 배열을 선언한다.   stack.push(start);  탐색을 시작할 스타팅 노드를 스택에 넣는다.   while (!stack.isEmpty()){}  스택이 빈 공간이 아닐 때 까지 다음을 실행한다.   int v = stack.pop(); if (!visited[v]){   visited[v] = true;     for (int i = 0; i &lt; list[v].size(); i++){       int dest = list[v].get(i);         if (!visited[dest])             stack.push(dest);     } }  스택에서 정점 하나를 꺼내 방문하지 않았으면 방문 표시를 하고 그 정점에 인접한 모든 정점을 스택에 넣는다.(방문 하지 않은 정점들만)     위의 예제 그래프를 사용한 전체 코드는 다음과 같다.   DFSIterative.java  import java.util.LinkedList; import java.util.Stack;  public class DFSIterative {      static class Graph{         int vertex;         LinkedList&lt;Integer&gt; list[];          public Graph(int vertex) {             this.vertex = vertex;             list = new LinkedList[vertex];             for (int i = 0; i &lt;vertex ; i++) {                 list[i] = new LinkedList&lt;&gt;();             }         }          public void addEdge(int source, int destination){             list[source].addFirst(destination);             list[destination].addFirst(source);         }          public void DFS(int start){             System.out.print(\"Depth First Traversal: \");             boolean[] visited = new boolean[vertex];             Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;();             stack.push(start);             while (!stack.isEmpty()){                 int v = stack.pop();                 if (!visited[v]){                     System.out.print(v + \" \");                     visited[v] = true;                     for (int i = 0; i &lt; list[v].size(); i++){                         int dest = list[v].get(i);                         if (!visited[dest])                             stack.push(dest);                     }                 }             }         }          public void printGraph(){             for (int i = 0; i &lt;vertex ; i++) {                 LinkedList&lt;Integer&gt; nodeList = list[i];                 if(nodeList.isEmpty()==false) {                     System.out.print(\"source = \" + i + \" is connected to nodes: \");                     for (int j = 0; j &lt; nodeList.size(); j++) {                         System.out.print(\" \" + nodeList.get(j));                     }                 }                 System.out.println();             }         }     }      public static void main(String[] args) {         Graph graph = new Graph(6);         graph.addEdge(0, 1);         graph.addEdge(0, 2);         graph.addEdge(1, 2);         graph.addEdge(1, 3);         graph.addEdge(3, 4);         graph.addEdge(2, 3);         graph.addEdge(4, 0);         graph.addEdge(4, 1);         graph.addEdge(4, 5);         graph.printGraph();         graph.DFS(0);     } }    Output:  source = 0 is connected to nodes:  3 2 1 source = 1 is connected to nodes:  2 0 source = 2 is connected to nodes:  4 1 0 source = 3 is connected to nodes:  0 source = 4 is connected to nodes:  2 Depth First Traversal: 0 1 2 4 3  Process finished with exit code 0   References      Wikipedia   JavaTpoint   Algorithms  ","categories": ["Algorithm"],
        "tags": ["Search Algorithm","DFS","Stack","Recursive","Graph","Tree","Back Tracking"],
        "url": "http://localhost:4000/algorithm/DFS-Implementation-stack/",
        "teaser":null},{
        "title": "깊이우선탐색(DFS) 구현 - Recursive",
        "excerpt":"깊이우선탐색 글 참고하기      Depth First Search   그래프의 구현 글 참고하기      Graph     이번 글에서는 재귀 함수를 사용한 DFS를 이해하고 구현해 봅니다.   깊이우선탐색(Depth First Search, DFS)   깊이우선탐색(DFS)은 트리나 그래프 혹은 다른 구조 상에서 탐색을 위한 알고리즘이다. 이 알고리즘은 루트 노드를 시작으로(그래프의 경우에는 임의의 노드를 루트 노드로 정하게 된다.) 탐색을 하다가 더 이상 갈 수 없어 백트랙 하기 전까지 가능한 한 가지를 따라 깊게 멀리 탐색한다.   시간 및 공간 복잡도 분석은 많은 응용분야에 따라 다른데, 이론적인 컴퓨터 과학 분야에서 DFS는 전체 그래프를 탐색하는데 사용되기 때문에 수행 시간은 선형인 $O(|V|+|E| )$가 된다. 공간 복잡도면을 보면 DFS는 경로상의 현재 탐색하고 있는 정점과 경로상 이미 방문한 정점들의 콜 스택 정보를 저장하고 있기 때문에 최악 $O(|V|)$의 공간을 요구한다. ($|V|$는 정점의 수, $|E|$는 간선의 수이다.)   알고리즘   재귀 함수를 이용한 DFS 알고리즘은 다음과 같은 순서로 실행된다.           탐색을 시작할 스타팅 노드를 매개변수로 하여 DFS 함수를 실행한다.            현재 탐색 정점을 방문 표시한다.            현재 정점에 인접한 모든 정점 중에서 방문하지 않은 정점을 재귀적으로 탐색한다.  현재 정점에 인접한 모든 정점을 방문 하였으면 이전 정점으로 백트래킹 한다.            2번으로 간다.       예제   예를 들어 DFS 알고리즘을 이해 해보자.   방문 우선순위: 현재 정점과 인접한 정점이 여러개면 번호가 [작은 순서대로] 방문한다.   아래와 같은 정점 5개로 이루어진 비방향 그래프 G로 DFS를 시작한다.   DFS(G, 정점 번호)는 그래프 G와 정점 번호를 매개변수로 하여 DFS함수를 재귀적으로 호출하는 것을 의미한다.   탐색은 0번 정점부터 시작한다고 가정한다.      DFS(G, 0) 실행   0번 정점을 방문한다.  0번 정점의 인접 정점들 중 탐색하지 않은 정점들을 탐색한다.  1번 정점을 재귀적으로 탐색한다.      DFS(G, 1) 실행   1번 정점을 방문한다.  1번 정점의 인접 정점들 중 탐색하지 않은 정점들을 탐색한다.  2번 정점을 재귀적으로 탐색한다.      DFS(G, 2) 실행   2번 정점을 방문한다.  2번 정점의 인접 정점들 중 탐색하지 않은 정점들을 탐색한다.  4번 정점을 재귀적으로 탐색한다.      DFS(G, 4) 실행   4번 정점을 방문한다.  4번 정점의 인접 정점들 중 탐색하지 않은 정점들을 탐색한다.  인접 정점들 중 방문 하지 않은 정점이 없으므로 이전 정점으로 백트랙 한다.      DFS(G, 2) 백트랙   2번 정점의 인접 정점들 중 탐색하지 않은 정점들을 탐색한다.  인접 정점들 중 방문 하지 않은 정점이 없으므로 이전 정점으로 백트랙 한다.      DFS(G, 1) 백트랙   1번 정점의 인접 정점들 중 탐색하지 않은 정점들을 탐색한다.  인접 정점들 중 방문 하지 않은 정점이 없으므로 이전 정점으로 백트랙 한다.      DFS(G, 0) 백트랙   0번 정점의 인접 정점들 중 탐색하지 않은 정점들을 탐색한다.  3번 정점을 재귀적으로 탐색한다.      DFS(G, 3) 실행   3번 정점을 방문한다.  3번 정점의 인접 정점들 중 탐색하지 않은 정점들을 탐색한다.  인접 정점들 중 방문 하지 않은 정점이 없으므로 이전 정점으로 백트랙 한다.      DFS(G, 0) 백트랙   1번 정점의 인접 정점들 중 탐색하지 않은 정점들을 탐색한다.  인접 정점들 중 방문 하지 않은 정점이 없으므로 DFS(G, 0)이 콜 스택에서 사라진다.      콜스택이 비었으므로 알고리즘을 끝낸다.      재귀 함수를 이용한 DFS의 방문순서는 0 1 2 4 3 순이다.   구현   의사코드   다음은 서브루틴을 이용한 재귀적 방법의 의사코드이다.   Input: 그래프 G, 그래프 G의 정점 v  Output: v로 부터 탐색 가능한 모든 정점들   procedure DFS(G, v) is     label v as discovered     for all directed edges from v to w that are in G.adjacentEdges(v) do         if vertex w is not labeled as discovered then             recursively call DFS(G, w)   한 구문씩 보자.      label v as discovered: 현재 정점 v를 탐색완료 되었다는 것을 표시한다. (중복 방문 방지를 위해)   for all directed edges from v to w that are in G.adjacentEdges(v) do: 그래프 G의 모든 인접한 간선 (v, w)에 대해서            if vertex w is not labeled as discovered then: 만약 w가 탐색되지 않았으면       recursively call DFS(G, w): 재귀적으로 w를 탐색한다.  이것은 현재 정점 v의 인접 정점 w를 매개변수로 하여 같은 서브루틴으로 다음 정점을 탐색하는 것을 의미한다.             자바 프로그램   위 의사코드를 바탕으로 재귀 함수를 이용한 DFS 알고리즘 자바 코드는 다음과 같다.   public void DFSRecursion(int startVertex){     boolean [] visited = new boolean[vertices];     dfs(startVertex, visited); }  public void dfs(int start, boolean [] visited){     visited[start] = true;     for (int i = 0; i &lt;adjList[start].size() ; i++) {         int destination = adjList[start].get(i);         if(!visited[destination])             dfs(destination,visited);     } }   위의 코드 설명   public void DFSRecursion(int startVertex){     boolean [] visited = new boolean[vertices];     dfs(startVertex, visited); }   정점들의 방문 표시를 할 visited[] 배열을 선언한다. 그 다음 탐색 시작 정점과, visited[] 배열을 매개변수로 하는 dfs 함수를 시작한다.   visited[start] = true;  현재 탐색 중인 정점을 방문 표시한다.   for (int i = 0; i &lt;adjList[start].size() ; i++) {}  현재 탐색 중인 인접 정점들에 대하여   int destination = adjList[start].get(i); if(!visited[destination])     dfs(destination,visited);  현재 탐색 중인 인접 정점 destination이 방문되지 않은 정점이면 destination을 다음 정점으로 하는 dfs 함수를 실행하여 재귀적으로 탐색한다.     위의 예제 그래프를 사용한 전체 코드는 다음과 같다.   DFSRecursion.java  import java.util.LinkedList;  public class DFSRecursion {      static class Graph{         int vertices;         LinkedList&lt;Integer&gt;[] adjList;          Graph(int vertices){             this.vertices = vertices;             adjList = new LinkedList[vertices];             for (int i = 0; i &lt;vertices ; i++) {                 adjList[i] = new LinkedList&lt;&gt;();             }         }         public void addEgde(int source, int destination){             adjList[source].add(destination);             adjList[destination].add(source);         }          public void DFSRecursion(int startVertex){             boolean [] visited = new boolean[vertices];             dfs(startVertex, visited);         }          public void dfs(int start, boolean [] visited){             visited[start] = true;             System.out.print(start + \" \");             for (int i = 0; i &lt;adjList[start].size() ; i++) {                 int destination = adjList[start].get(i);                 if(!visited[destination])                     dfs(destination,visited);             }         }     }      public static void main(String[] args) {         int vertices = 6;         Graph graph = new Graph(vertices);         graph.addEgde(0, 1);         graph.addEgde(0, 2);         graph.addEgde(0, 3);         graph.addEgde(1, 2);         graph.addEgde(2, 4);         graph.DFSRecursion(0);     } }   Output:  0 1 2 4 3    References      Wikipedia   JavaTpoint   Algorithms  ","categories": ["Algorithm"],
        "tags": ["Search Algorithm","DFS","Stack","Recursive","Graph","Tree","Back Tracking"],
        "url": "http://localhost:4000/algorithm/DFS-Implementation-recursive/",
        "teaser":null},{
        "title": "너비우선탐색(Breadth First Search, BFS)",
        "excerpt":"너비우선탐색(Breadth First Search)   너비우선탐색(BFS)은 트리나 그래프 혹은 다른 구조 상에서 탐색을 위한 알고리즘이다. 이 알고리즘은 루트 노드를 시작으로(그래프의 경우에는 임의의 노드를 루트 노드로 정하게 된다.) 다음 레벨로 가기전에 현재 레벨에서 인접한 모든 이웃노드들을 탐색한다.   더 이상 탐색할 노드가 없어 백트랙 하기 전까지 가지를 따라 가능한 한 깊이 탐색하는 깊이우선탐색과는 다르게 너비우선탐색은 해당 정점에서 인접한 정점들을 모두 방문하는 레벨 탐색 즉, 깊이보다는 넓게 탐색하는 전략을 쓴다. 이를 위해 너비우선탐색은 큐(Queue) 자료구조를 이용하여 탐색 방법을 구성하게 된다.   시간 및 공간 복잡도 분석은 많은 응용분야에 따라 다른데, 이론적인 컴퓨터 과학 분야에서 BFS는 전체 그래프를 탐색하는데 사용되기 때문에 수행 시간은 선형인 $O(|V|+|E| )$가 된다. 공간 복잡도면을 보면 BFS는 어떤 해당 정점에서 인접 정점들의 정보를 모두 큐에 저장하기 때문에, 최악의 설정으로 하나의 정점이 다른 모든 정점과 직접 연결되어 있다면  최악 $O(|V|)$의 공간을 요구한다. ($|V|$는 정점의 수, $|E|$는 간선의 수이다.)   너비우선탐색(BFS)의 시간 및 공간 상한은 깊이우선탐색(BFS)과 같기 때문에, 탐색 알고리즘의 사용면에서 두 알고리즘이 만드는 정점 방문 순서의 다름과 그 복잡성을 생각해 어느 알고리즘을 사용해야 할지 생각해야한다.   예제   다음 트리를 보고 너비우선탐색이 어떤 것인지 이해해보자.      위에서 보이는 트리에서 정점들의 번호는 너비우선탐색을 적용한 뒤 정점들의 방문 순서와 같다.   1번 정점을 루트로 하여 탐색을 시작하면, 1번 정점을 방문하고 그 인접한 정점 2, 3, 4를 순서대로 방문한다. 그 다음 레벨의 5, 6, 7, 8을 순서대로 방문하고 그 다음 레벨 9, 10, 11, 12순으로 방문하게 된다.   너비우선탐색이 어떻게 동작하는지 알아보자.   가정      현재 방문하고 있는 정점에서 인접한 왼쪽 간선을 오른쪽 간선보다 먼저 선택한다.   정점들의 방문 순서를 위해 큐 자료구조를 사용한다.   정점들의 방문은 중복되지 않는다.   1번 정점 부터 탐색을 시작한다.     먼저 1번 정점을 루트로 하여 BFS 탐색을 시작한다.         1번 정점을 큐에 넣는다.  Queue: [1]         큐에서 제일 앞에 있는 1번을 pop하고, 1번 정점을 방문한다.  1번 정점과 인접한 정점 중에서 방문하지 않은 2, 3, 4번을 순서대로 큐에 넣는다.  Queue: [2, 3, 4]         큐에서 제일 앞에 있는 2번을 pop하고, 2번 정점을 방문한다.  2번 정점과 인접한 정점 중에서 방문하지 않은 5, 6번을 순서대로 큐에 넣는다.  Queue: [3, 4, 5, 6]         큐에서 제일 앞에 있는 3번을 pop하고, 3번 정점을 방문한다.  3번 정점과 인접한 정점 중에서 방문하지 않은 정점이 없으므로 다음 스탭으로 간다.  Queue: [4, 5, 6]         큐에서 제일 앞에 있는 4번을 pop하고, 4번 정점을 방문한다.  4번 정점과 인접한 정점 중에서 방문하지 않은 7, 8번을 순서대로 큐에 넣는다.  Queue: [5, 6, 7, 8]         큐에서 제일 앞에 있는 5번을 pop하고, 5번 정점을 방문한다.  5번 정점과 인접한 정점 중에서 방문하지 않은 9, 10번을 순서대로 큐에 넣는다.  Queue: [6, 7, 8, 9, 10]         큐에서 제일 앞에 있는 6번을 pop하고, 6번 정점을 방문한다.  6번 정점과 인접한 정점 중에서 방문하지 않은 정점이 없으므로 다음 스탭으로 간다.  Queue: [7, 8, 9, 10]         큐에서 제일 앞에 있는 7번을 pop하고, 7번 정점을 방문한다.  7번 정점과 인접한 정점 중에서 방문하지 않은 11, 12번을 순서대로 큐에 넣는다.  Queue: [8, 9, 10, 11, 12]         큐에서 제일 앞에 있는 8번을 pop하고, 8번 정점을 방문한다.  8번 정점과 인접한 정점 중에서 방문하지 않은 정점이 없으므로 다음 스탭으로 간다.  Queue: [9, 10, 11, 12]         큐에서 제일 앞에 있는 9번을 pop하고, 9번 정점을 방문한다.  9번 정점과 인접한 정점 중에서 방문하지 않은 정점이 없으므로 다음 스탭으로 간다.  Queue: [10, 11, 12]         큐에서 제일 앞에 있는 10번을 pop하고, 10번 정점을 방문한다.  10번 정점과 인접한 정점 중에서 방문하지 않은 정점이 없으므로 다음 스탭으로 간다.  Queue: [11, 12]         큐에서 제일 앞에 있는 11번을 pop하고, 11번 정점을 방문한다.  11번 정점과 인접한 정점 중에서 방문하지 않은 정점이 없으므로 다음 스탭으로 간다.  Queue: [12]         큐에서 제일 앞에 있는 12번을 pop하고, 12번 정점을 방문한다.  12번 정점과 인접한 정점 중에서 방문하지 않은 정점이 없으므로 다음 스탭으로 간다.  Queue: [ ]         큐가 비었으므로 너비우선탐색(BFS)가 완료되었다.   의사코드   Input: 그래프 G, 그래프 G의 시작 루트 정점 v   다음은 Queue를 이용한 BFS의 의사코드이다.   1 procedure BFS(G, start_v) is 2      let Q be a queue 3      label start_v as discovered 4      Q.enqueue(start_v) 5      while Q is not empty do 6          v := Q.dequeue() 7          for all edges from v to w in G.adjacentEdges(v) do 8             if w is not labeled as discovered then 9                 label w as discovered 10                Q.enqueue(w)   한 구문씩 보자.           let Q be a queue: Queue를 생성한다.            label start_v as discovered: 시작 루트 정점을 방문표시 한다.            Q.enqueue(start_v): 시작 루트 정점을 Queue에 넣는다.            while Q is not empty do: Queue가 빈 공간이 아닐 때 까지 아래를 반복한다.            v := Q.dequeue(): 현재 방문할 정점 v를 Queue에서 꺼낸다.            for all edges from v to w in G.adjacentEdges(v) do: v와 인접한 모든 정점 w에 대하여            if w is not labeled as discovered then: w가 방문표시 되지 않았으면                       label w as discovered: w를 방문표시 하고                        Q.enqueue(w): w를 Queue에 넣는다.                   위에서 살펴본 예제와 이 의사코드의 한 가지 차이점이 있다면 예제에서는 정점을 큐에서 꺼낼 때 방문표시를 하는 반면, 의사코드 방식에서는 인접 정점들을 큐에 넣을 때 같이 방문표시를 한다는 것이다.   정점의 방문표시를 큐에 꺼낼 때 하거나 큐에 넣을 때 하는것은 어느 구현을 하느냐에 따라 정해진다.   구현   프로그래밍 언어로의 구현은 다음 글을 참고하면 좋다.      BFS Implementation Using Queue   Applications   너비우선탐색(BFS)은 그래프 이론 분야에서 많은 문제를 해결하는데에 쓰이고 있다.           두 정점 u, v간의 최단 경로 찾기 (경로의 길이는 간선의 수에 따라 정해질 때)            플로우 네트워크에서 Edmonds–Karp algorithm을 사용하여 최대 유량을 계산 할 때            문자열 알고리즘 아호-코라식(Aho-Corasick) 패턴 매칭의 실패 함수(failure function)를 구축할 때            그래프에서 정점들이 두개의 독립적인 서로소 그룹으로 나누어질 수 있는가 하는 이분성(bipartiteness) 테스팅            Copying garbage collection, Cheney’s algorithm       시간복잡도 및 공간복잡도   시간복잡도: $O(|V|+|E|)$ - ($O(|E|)$ may vary between $O(1)$ and $O(|V^2|)$)   너비우선탐색(BFS)의 시간복잡도는 최악의 경우 모든 정점과 간선을 탐색하기 때문에 $O(|V|+|E|)$으로 표현 될 수 있다. $O(|E|)$는 그래프가 얼마나 조밀한가에 따라 $O(1)$와 $O(|V^2|)$사이의 값이 될 수 있다.($|V|$는 정점의 수, $|E|$는 간선의 수이다.)   공간복잡도: $O(|V|)$   그래프의 정점들의 수를 미리 알고 있고, 어떤 정점들이 Queue에 추가되었는지와 같은 정보를 저장하기 위한 추가적인 자료구조를 사용하므로, 공간복잡도는 $O(|V|)$로 표현될 수 있다. 이 공간복잡도는 BFS의 탐색을 위한 공간 요구사항 이므로, 그래프 구축을 위해 사용되는 공간 요구사항과는 별개이다.   References      Wikipedia   JavaTpoint  ","categories": ["Algorithm"],
        "tags": ["Search Algorithm","BFS","Queue","Iterative","Graph","Tree"],
        "url": "http://localhost:4000/algorithm/BFS/",
        "teaser":null},{
        "title": "너비우선탐색(Breadth First Search, BFS) - 구현",
        "excerpt":"너비우선탐색 글 참고하기      Breadth First Search   그래프의 구현 글 참고하기      Graph     이번 글에서는 Queue를 사용한 BFS를 이해하고 구현해 봅니다.   너비우선탐색(Breadth First Search)   너비우선탐색(BFS)은 트리나 그래프 혹은 다른 구조 상에서 탐색을 위한 알고리즘이다. 이 알고리즘은 루트 노드를 시작으로(그래프의 경우에는 임의의 노드를 루트 노드로 정하게 된다.) 다음 레벨로 가기전에 현재 레벨에서 인접한 모든 이웃노드들을 탐색한다.   더 이상 탐색할 노드가 없어 백트랙 하기 전까지 가지를 따라 가능한 한 깊이 탐색하는 깊이우선탐색과는 다르게 너비우선탐색은 해당 정점에서 인접한 정점들을 모두 방문하는 레벨 탐색 즉, 깊이보다는 넓게 탐색하는 전략을 쓴다. 이를 위해 너비우선탐색은 큐(Queue) 자료구조를 이용하여 탐색 방법을 구성하게 된다.   시간 및 공간 복잡도 분석은 많은 응용분야에 따라 다른데, 이론적인 컴퓨터 과학 분야에서 BFS는 전체 그래프를 탐색하는데 사용되기 때문에 수행 시간은 선형인 $O(|V|+|E| )$가 된다. 공간 복잡도면을 보면 BFS는 어떤 해당 정점에서 인접 정점들의 정보를 모두 Queue에 저장하기 때문에, 최악의 설정으로 하나의 정점이 다른 모든 정점과 직접 연결되어 있다면  최악 $O(|V|)$의 공간을 요구한다. ($|V|$는 정점의 수, $|E|$는 간선의 수이다.)   너비우선탐색(BFS)의 시간 및 공간 상한은 깊이우선탐색(BFS)과 같기 때문에, 탐색 알고리즘의 사용면에서 두 알고리즘이 만드는 정점 방문 순서의 다름과 그 복잡성을 생각해 어느 알고리즘을 사용해야 할지 생각해야한다.   알고리즘   BFS 알고리즘은 다음과 같은 순서로 실행된다.           그래프의 정점 중 하나를 Queue에 추가한다. (시작 정점)            Queue에서 제일 앞에 있는 아이템 v를 pop하고 방문 완료 배열에 넣는다.            현재 정점 v에 인접한 모든 정점 중에서 방문 완료 되지 않았고, Queue에 추가되지 않은 인접 정점을 Queue에 추가한다.            Queue가 빈 공간이 될 때 까지 2, 3번을 반복한다.       예제   예를 들어 BFS 알고리즘을 이해 해보자.   인접 정점 추가 우선순위: 현재 정점과 인접한 정점이 여러개면 번호가 작은 순서대로 Queue에 추가한다.   먼저 1번 정점을 루트로 하여 BFS 탐색을 시작한다.         1번 정점을 Queue에 넣는다.  Queue: [1]         Queue에서 제일 앞에 있는 1번을 pop하고, 1번 정점을 방문한다.  1번 정점과 인접한 정점 중에서 방문하지 않은 2, 3, 4번을 순서대로 Queue에 넣는다.  Queue: [2, 3, 4]         Queue에서 제일 앞에 있는 2번을 pop하고, 2번 정점을 방문한다.  2번 정점과 인접한 정점 중에서 방문하지 않은 5, 6번을 순서대로 Queue에 넣는다.  Queue: [3, 4, 5, 6]         Queue에서 제일 앞에 있는 3번을 pop하고, 3번 정점을 방문한다.  3번 정점과 인접한 정점 중에서 방문하지 않은 정점이 없으므로 다음 스탭으로 간다.  Queue: [4, 5, 6]         Queue에서 제일 앞에 있는 4번을 pop하고, 4번 정점을 방문한다.  4번 정점과 인접한 정점 중에서 방문하지 않은 7, 8번을 순서대로 Queue에 넣는다.  Queue: [5, 6, 7, 8]         Queue에서 제일 앞에 있는 5번을 pop하고, 5번 정점을 방문한다.  5번 정점과 인접한 정점 중에서 방문하지 않은 9, 10번을 순서대로 Queue에 넣는다.  Queue: [6, 7, 8, 9, 10]         Queue에서 제일 앞에 있는 6번을 pop하고, 6번 정점을 방문한다.  6번 정점과 인접한 정점 중에서 방문하지 않은 정점이 없으므로 다음 스탭으로 간다.  Queue: [7, 8, 9, 10]         Queue에서 제일 앞에 있는 7번을 pop하고, 7번 정점을 방문한다.  7번 정점과 인접한 정점 중에서 방문하지 않은 11, 12번을 순서대로 Queue에 넣는다.  Queue: [8, 9, 10, 11, 12]         Queue에서 제일 앞에 있는 8번을 pop하고, 8번 정점을 방문한다.  8번 정점과 인접한 정점 중에서 방문하지 않은 정점이 없으므로 다음 스탭으로 간다.  Queue: [9, 10, 11, 12]         Queue에서 제일 앞에 있는 9번을 pop하고, 9번 정점을 방문한다.  9번 정점과 인접한 정점 중에서 방문하지 않은 정점이 없으므로 다음 스탭으로 간다.  Queue: [10, 11, 12]         Queue에서 제일 앞에 있는 10번을 pop하고, 10번 정점을 방문한다.  10번 정점과 인접한 정점 중에서 방문하지 않은 정점이 없으므로 다음 스탭으로 간다.  Queue: [11, 12]         Queue에서 제일 앞에 있는 11번을 pop하고, 11번 정점을 방문한다.  11번 정점과 인접한 정점 중에서 방문하지 않은 정점이 없으므로 다음 스탭으로 간다.  Queue: [12]         Queue에서 제일 앞에 있는 12번을 pop하고, 12번 정점을 방문한다.  12번 정점과 인접한 정점 중에서 방문하지 않은 정점이 없으므로 다음 스탭으로 간다.  Queue: [ ]         Queue가 비었으므로 너비우선탐색(BFS)가 완료되었다.   구현   의사코드   Input: 그래프 G, 그래프 G의 시작 루트 정점 v   다음은 Queue를 이용한 BFS의 의사코드이다.   1 procedure BFS(G, start_v) is 2      let Q be a queue 3      label start_v as discovered 4      Q.enqueue(start_v) 5      while Q is not empty do 6          v := Q.dequeue() 7          for all edges from v to w in G.adjacentEdges(v) do 8             if w is not labeled as discovered then 9                 label w as discovered 10                Q.enqueue(w)   한 구문씩 보자.           let Q be a queue: Queue를 생성한다.            label start_v as discovered: 시작 루트 정점을 방문표시 한다.            Q.enqueue(start_v): 시작 루트 정점을 Queue에 넣는다.            while Q is not empty do: Queue가 빈 공간이 아닐 때 까지 아래를 반복한다.            v := Q.dequeue(): 현재 방문할 정점 v를 Queue에서 꺼낸다.            for all edges from v to w in G.adjacentEdges(v) do: v와 인접한 모든 정점 w에 대하여            if w is not labeled as discovered then: w가 방문표시 되지 않았으면                       label w as discovered: w를 방문표시 하고                        Q.enqueue(w): w를 Queue에 넣는다.                   위 의사코드에서는 Queue에 인접 정점의 중복 저장이 되는 것을 방지하기 위해 w를 Queue에 넣음과 동시에 방문표시를 해주고 있다.     BFS 알고리즘 - Java   위 의사코드를 바탕으로 한 BFS 알고리즘 코드는 다음과 같다.   public void BFS(int start){     Queue&lt;Integer&gt; queue = new LinkedList&lt;Integer&gt;();     boolean visited[] = new boolean[V];     queue.offer(start);     visited[start] = true;     while (!queue.isEmpty()){         int V = queue.poll();         for (int i : adj[V]) {             if (!visited[i]){                 queue.offer(i);                 visited[i] = true;             }         }     } }   위의 코드 설명   Queue&lt;Integer&gt; queue = new LinkedList&lt;Integer&gt;(); boolean visited[] = new boolean[V]; }   정점 방문 순서를 위한 Queue와 정점 방문 표시를 할 visited[] 배열을 선언한다.   queue.offer(start); visited[start] = true;  시작 정점을 Queue 추가하고 방문 표시를 한다.   for (int i = 0; i &lt;adjList[start].size() ; i++) {}  현재 탐색 중인 인접 정점들에 대하여   while (!queue.isEmpty()){}  Queue가 빌 때 까지 다음 연산을 실행한다.   int V = queue.poll(); for (int i : adj[V]) {     if (!visited[i]){         queue.offer(i);         visited[i] = true;     } }   Queue에서 제일 앞에 있는 정점을 꺼내 V로 하고, V에 인접한 모든 정점에 대하여 방문하지 정점은 Queue에 추가하고 방문 표시를 함께 한다.     위의 예제 그래프를 사용한 전체 코드는 다음과 같다.      BFS 메소드에 print문을 추가하여 정점 방문 순서를 출력하게 하였다.   BreadthFirstSearch.java  import java.util.*; import java.util.LinkedList;  public class BreadthFirstSearch{     static class Graph{         public int V;         public LinkedList &lt;Integer&gt; adj[];           Graph(int v){             V = v+1;             adj = new LinkedList[V];             for(int i = 0; i&lt;V; i++){                 adj[i] = new LinkedList();             }          }          public void addEdge(int a, int b){             adj[a].add(b);             adj[b].add(a);         }           public void BFS(int start){             Queue&lt;Integer&gt; queue = new LinkedList&lt;Integer&gt;();             boolean visited[] = new boolean[V];             queue.offer(start);             visited[start] = true;             while (!queue.isEmpty()){                 int V = queue.poll();                 System.out.print(V + \" \");                 for (int i : adj[V]) {                     if (!visited[i]){                         queue.offer(i);                         visited[i] = true;                     }                 }             }         }     }      public static void main(String[] args){          Graph g = new Graph(12);         g.addEdge(1, 2);         g.addEdge(1, 3);         g.addEdge(1, 4);         g.addEdge(2, 1);         g.addEdge(2, 5);         g.addEdge(2, 6);         g.addEdge(3, 1);         g.addEdge(4, 1);         g.addEdge(4, 7);         g.addEdge(4, 8);         g.addEdge(5, 2);         g.addEdge(5, 9);         g.addEdge(5, 10);         g.addEdge(6, 2);         g.addEdge(7, 4);         g.addEdge(7, 11);         g.addEdge(7, 12);         g.addEdge(8, 4);         g.addEdge(9, 5);         g.addEdge(10, 5);         g.addEdge(11, 7);         g.addEdge(12, 7);         System.out.print(\"Breath First Search : \");         g.BFS(1);     } }   Output:  Breath First Search : 1 2 3 4 5 6 7 8 9 10 11 12    References      Wikipedia   JavaTpoint  ","categories": ["Algorithm"],
        "tags": ["Search Algorithm","BFS","Queue","Iterative","Graph","Tree"],
        "url": "http://localhost:4000/algorithm/BFS-Implementation/",
        "teaser":null},{
        "title": "그리디 알고리즘(Greedy Algorithm)-예정 포스트",
        "excerpt":" ","categories": ["Algorithm"],
        "tags": ["Spanning Tree"],
        "url": "http://localhost:4000/algorithm/greedy-algorithm/",
        "teaser":null},{
        "title": "위상정렬(Topological sorting)",
        "excerpt":"위상정렬(Topological sorting)   컴퓨터 과학에서 위상정렬(Topological sorting)은 방향 그래프에서 정점들의 선형적인 순서를 말하는데, 여기서 정점들의 선형적 순서란 정점 u로 부터 정점 v로 가는 간선에 대해 순서상 정점 u가 정점 v보다 앞에 있다는 것을 뜻한다. 예를 들어, 방향 그래프에서 정점들은 수행될 작업들을 뜻할 수 있고, 간선은 어떤 작업이 다른 작업보다 먼저 수행되어야 한다는 제약을 나타낼 수 있다. 즉, 위상정렬의 결과는 작업들이 수행되는 일련의 순서를 의미한다. 위상정렬은 사이클이 형성되지 않은 그래프에서 가능하다. 즉, 사이클이 없는 방향 그래프에서 적용이 가능한데, 이런 그래프를 DAG(Directed acyclic graph)라고 한다. 어떤 DAG에 대해서도 위상정렬을 적용하면 적어도 하나의 위상순서를 가지게 되고 경우에 따라 여러개의 위상순서를 가질수 있다. 위상정렬 알고리즘은 DAG에서 위상순서를 구하는데 선형시간이 걸린다고 알려져 있다.   Example   위상정렬은 현실적인 예로는 제약에 따른 작업들의 스케줄링 순서라고 이해하면 된다. 작업들은 정점으로 나타내어지고 정점에서 다른 정점으로의 간선이 있는데, 이는, x, y 두 정점을 끝 점으로 하고 x-&gt;y로의 방향 간선 E(x,y)이 있을 때 작업 y가 수행되기 위해서는 x가 사전에 먼저 수행 완료되어야 한다는 것을 뜻한다. 작업 y의 제약은 x인 것이다. 이처럼 제약이 있는 해당 작업들에 대해서 위상정렬은 작업들의 수행순서를 나타낸다.   밑 그림에서 5번 정점과 11번 정점을 보자. 정점은 작업으로 생각하고 간선은 제약 또는 작업 흐름으로 보면 위상정렬에서는 5번 작업이 완료되고 11번 작업이 수행된다는 것이다. 즉, 11번 작업이 수행되기 위해선 5번 작업이 사전에 완료가 되어야 한다는 것을 말한다. 다른 작업들도 마찬가지로, 9번 정점이 수행되기 위해서는 11번과 8번 작업이 사전에 완료가 되어야 한다.      위상순서: DAG의 모든 간선 u-&gt;v에 대해서, 정점 u는 v보다 순서상에서 먼저 나와야 한다.   다음은 위 그림에서의 위상정렬 순서인데 기준에 따라 여러가지가 있을 수 있다.      5-&gt;7-&gt;3-&gt;11-&gt;8-&gt;2-&gt;9-&gt;10 (왼쪽에서 오른쪽, 밑에서 아래로)   3-&gt;5-&gt;7-&gt;8-&gt;11-&gt;2-&gt;9-&gt;10 (현재 작업 가능한 작업들의 번호가 작은순서)   3-&gt;7-&gt;8-&gt;5-&gt;11-&gt;10-&gt;2-&gt;9 (현재 작업 가능한 작업들의 무작위 선택)   Algorithm   DAG에서의 위상정렬을 구하는 두 가지 알고리즘을 살펴보자.  이 두 알고리즘은 모두 $O(V+E)$의 선형시간에 동작한다. V는 정점의 개수, E는 간선의 개수이다.   Kahn’s algorithm   위상정렬을 구하는 이 알고리즘은 Kahn (1962)에 의해 처음 소개 되었다.   Kahn’s algorithm은 해당 그래프에서의 진입간선(Incoming edge)을 가지고 있지 않은 정점으로 부터 시작해서 그 정점과 연결된 정점의 진입간선(Incoming edge)을 삭제 하면서 동작한다.   다음은 Kahn’s algorithm의 위상정렬 의사코드이다.   S ← Set of all nodes with no incoming edge L ← Empty list that will contain the sorted elements  while S is non-empty do     remove a node n from S     add n to tail of L     for each node m with an edge e from n to m do         remove edge e from the graph         if m has no other incoming edges then             insert m into S  if graph has edges then     return error   (graph has at least one cycle) else      return L   (a topologically sorted order)      진입간선이 없는 없는 정점들을 시작 리스트 S에 넣는다.   S가 빈 공간이 아닐 때 까지 다음을 반복한다.   S의 앞에서 부터 정점 n을 하나 취해서 위상정렬 리스트 L의 끝에 추가한다.   정점 n과 m을 양 끝점으로 하는 간선 e와 정점 m에 대해서            간선 e를 삭제한다. (정점 m의 진입간선 삭제와 같은 의미이다.)       정점 m의 진입간선의 개수가 0개라면, S에 m을 추가한다.           그래프에 간선이 남아있으면 적어도 하나의 사이클이 있다는 의미이므로 error를 리턴한다. 그렇지 않으면 위상정렬 순서를 리턴한다.     위상정렬을 적용할 그래프가 DAG이라면 이 알고리즘은 위상정렬 순서 L을 리턴할 것이고, 그래프에 사이클이 하나라도 있다면 위상정렬은 불가능하다.   집합 S에서 n이 삭제되는 순서에 따라 위상정렬의 결과는 달라지기 때문에, 한 그래프에서 위상정렬은 특정하지 않고 여러개가 존재할 수 있다. S는 큐와 스택 같은 정점들을 담을 수 있는 집합이 될 수 있다.   구현에 있어서 간선을 삭제하는 방법과 정점 m의 진입간선 개수를 추적하는 방법은 각 정점마다 진입간선의 개수를 가지고 있는 배열을 둠으로써 쉽게 구현이 가능하다.      indegree[m]은 m의 진입간선 개수를 의미한다.   indegree[m] = indegree[m] - 1 을 함으로써 m의 진입간선을 하나 삭제할 수 있다.   indegree[m] == 0 이면 m의 진입간선은 없으므로 m을 S에 추가한다.   Depth-first search   위상정렬을 구하는 다른 방법은 깊이우선탐색(Depth-first search)에 기반한 것이다.   이 방법은 그래프의 기준에 따라 또는 임의의 순서로 노드들을 탐색해 나가다가 이미 방문이 완료된 정점 또는 더 이상 탐색할 정점을 가지지 않은 정점에 대해서 위상정렬 리스트에 노드를 추가하는 방법이다.   다음은 Depth-first search에 기반한 위상정렬의 의사코드이다.      permanent mark: 더 이상 방문할 정점이 없어 DFS 탐색이 끝난 정점의 표시를 뜻한다.   temporary mark: DFS 탐색이 진행 중인 정점의 표시를 뜻한다.   L ← Empty list that will contain the sorted nodes while exists nodes without a permanent mark do     select an unmarked node n     visit(n)  function visit(node n)     if n has a permanent mark then         return     if n has a temporary mark then         stop   (not a DAG)      mark n with a temporary mark      for each node m with an edge from n to m do         visit(m)      remove temporary mark from n     mark n with a permanent mark     add n to head of L   DAG에서 방문완료 되지 않은 정점들이 있는 동안, 정점을 하나 선택해 탐색을 진행한다.   function visit(node n):     정점 n이 방문완료 정점이면 백트랙 한다.   정점 n이 현재 방문 중인 정점이면 역 간선(Back edge)이 있다는 것이므로 사이클이 있다는 말이된다. 알고리즘을 종료한다.   위 1, 2번 조건이 아니라면, 정점 n을 진행 중인 정점으로 표시한다.   정점 n과 m을 양 끝점으로 하는 간선의 정점 m에 대해서   정점 m을 재귀적으로 탐색한다. (1번으로 간다.)   정점 n을 방문완료 표시하고 L의 맨 처음에 추가한다.   DFS 함수에서 temporary mark검사를 하고 있는데, DFS 탐색에 있어서 방문되어 지고 있는 정점이 방문완료 되지 못한 채 다른 정점에 의해서 방문이 되면, 역 간선(Back edge)이 있다는 의미가 된다. 이는 사이클이 있다는 것과 같은 의미이다.   Implementation   다음의 구현들은 밑의 그래프를 예제로 사용하였다.      다음은 Kahn’s algorithm을 구현한 java 코드이다.      Graph class: 간선 정보들로 부터 그래프를 구축한다.   indegree.set(dest, indegree.get(dest) + 1);: 간선 정보들로 부터 그래프를 구축하면서 해당 정점에 해당하는 진입간선을 하나씩 추가한다.   Stack&lt;Integer&gt; S = new Stack&lt;&gt;();: 정점들을 담을 집합 S로는 스택을 사용하였다.   import java.util.*;  // data structure to store graph edges class Edge { \tint source, dest;  \tpublic Edge(int source, int dest) { \t\tthis.source = source; \t\tthis.dest = dest; \t} };  // class to represent a graph object class Graph { \t// A List of Lists to represent an adjacency list \tList&lt;List&lt;Integer&gt;&gt; adjList = null;  \t// stores indegree of a vertex \tList&lt;Integer&gt; indegree = null;  \t// Constructor \tGraph(List&lt;Edge&gt; edges, int N) { \t\tadjList = new ArrayList&lt;&gt;(N); \t\tfor (int i = 0; i &lt; N; i++) { \t\t\tadjList.add(i, new ArrayList&lt;&gt;()); \t\t}  \t\t// initialize indegree of each vertex by 0 \t\tindegree = new ArrayList&lt;&gt;(Collections.nCopies(N, 0));  \t\t// add edges to the undirected graph \t\tfor (int i = 0; i &lt; edges.size(); i++) \t\t{ \t\t\tint src = edges.get(i).source; \t\t\tint dest = edges.get(i).dest;  \t\t\t// add an edge from source to destination \t\t\tadjList.get(src).add(dest);  \t\t\t// increment in-degree of destination vertex by 1 \t\t\tindegree.set(dest, indegree.get(dest) + 1); \t\t} \t} }  class TopologicalSort { \t// performs Topological Sort on a given DAG \tpublic static List&lt;Integer&gt; doTopologicalSort(Graph graph, int N) \t{ \t\t// list to store the sorted elements \t\tList&lt;Integer&gt; L = new ArrayList&lt;&gt;();  \t\t// get indegree information of the graph \t\tList&lt;Integer&gt; indegree = graph.indegree;  \t\t// Set of all nodes with no incoming edges \t\tStack&lt;Integer&gt; S = new Stack&lt;&gt;(); \t\tfor (int i = 0; i &lt; N; i++) { \t\t\tif (indegree.get(i) == 0) { \t\t\t\tS.add(i); \t\t\t} \t\t}  \t\twhile (!S.isEmpty()) \t\t{ \t\t\t// remove a node n from S \t\t\tint n = S.pop();  \t\t\t// add n to tail of L \t\t\tL.add(n);  \t\t\tfor (int m : graph.adjList.get(n)) \t\t\t{ \t\t\t\t// remove edge from n to m from the graph \t\t\t\tindegree.set(m, indegree.get(m) - 1);  \t\t\t\t// if m has no other incoming edges then \t\t\t\t// insert m into S \t\t\t\tif (indegree.get(m) == 0) { \t\t\t\t\tS.add(m); \t\t\t\t} \t\t\t} \t\t}  \t\t// if graph has edges then graph has at least one cycle \t\tfor (int i = 0; i &lt; N; i++) { \t\t\tif (indegree.get(i) != 0) { \t\t\t\treturn null; \t\t\t} \t\t}  \t\treturn L; \t}  \tpublic static void main(String[] args) \t{ \t\t// List of graph edges as per above diagram \t\tList&lt;Edge&gt; edges = Arrays.asList(             new Edge(0, 6), new Edge(1, 2), new Edge(1, 4),             new Edge(1, 6), new Edge(3, 0), new Edge(3, 4),             new Edge(5, 1), new Edge(7, 0), new Edge(7, 1)         );  \t\t// Set number of vertices in the graph \t\tfinal int N = 8;  \t\t// create a graph from edges \t\tGraph graph = new Graph(edges, N);  \t\t// Perform Topological Sort \t\tList&lt;Integer&gt; L = doTopologicalSort(graph, N);  \t\tif (L != null) { \t\t\tSystem.out.print(L);  // print topological order \t\t} else { \t\t\tSystem.out.println(\"Graph has at least one cycle. \" + \t\t\t\t\t\t\t  \"Topological sorting is not possible\"); \t\t} \t} }  Output: 7 5 1 2 3 4 0 6   References      Topological Sorting - Kahn’s algorithm   Topological Sorting  ","categories": ["Algorithm"],
        "tags": ["Sort","DFS","Cycle","DAG"],
        "url": "http://localhost:4000/algorithm/topological-sorting/",
        "teaser":null},{
        "title": "플로이드 와샬 알고리즘(Floyd Warshall Algorithm)-예정 포스트",
        "excerpt":" ","categories": ["Algorithm"],
        "tags": ["Shortest Path"],
        "url": "http://localhost:4000/algorithm/floyd-warshall/",
        "teaser":null},{
        "title": "SPFA(Shortest Path Faster Algorithm)",
        "excerpt":"Graph 글 참고하기      Graph   Queue 글 참고하기      Queue     SPFA(Shortest Path Faster Algorithm)   The Shortest Path Faster Algorithm (SPFA)는 Bellman–Ford algorithm 을 개선한 알고리즘 으로서, 방향 가중치 그래프에서 단일 출발 정점 최단 거리를(Single source shortest path distance) 계산한다. 다른 여타 Bellman–Ford algorithm 이나 Dijkstra’s algorithm 과 같은 Single source shortest path algorithm 처럼 SPFA도 변 경감(Edge relaxation)을 핵심 연산으로 하여 동작한다.   이 SPFA는 무작위 희소 그래프에서 잘 동작한다고 알려져 있고, 음수 가중치 간선(Nagative weighted edge)을 가진 그래프에서도 적합하다. 그러나 최악 시간복잡도는 $O(|V|\\cdot|E|)$ 로서 Bellman–Ford algorithm과 같기 때문에, 음수 가중치 간선이 없는 그래프의 경우에는 최악 시간복잡도를 고려한다면 Dijkstra’s algorithm이 더 적합하다고 볼 수 있다.   Algorithm   방향 가중치 그래프가 주어지고 $G = (V, E)$ 그리고 출발 정점을 $s$라고 하자. SPFA는 출발 정점 $s$으로부터 다른 모든 정점 $v$로의 최단 경로를 찾는다. $s$로 부터 $v$로의 최단 경로 거리는 각 정점 $v$에 대하여 $d(v)$에 저장된다.   SPFA는 각 정점의 인접 정점을 필요하다면 변 경감(Edge relaxation)하기 위해 각 정점을 후보자로 사용한다. 이 점은 Bellman–Ford algorithm과 같다. 하지만 Bellman–Ford algorithm과 비교했을 때의 개선점은 모든 정점들을 무조건 적으로 연산을 시도하기 보다는 SPFA는 후보자 정점에 대한 Queue를 가지고, 어떤 정점에 대해 그 정점이 변 경감 연산이 이루어졌을 때만 후보자 정점으로서 Queue에 삽입을 한다. 이런 행동들은 변 경감 연산이 실행될 정점이 없을 때까지 반복된다.     다음은 SPFA의 의사코드이다.   Input: 그래프 G, 시작 정점 s   $Q$는 변 경감 연산이 되고 난 후의 후보자를 담을 Queue를 의미한다.  $w(u,v)$는 간선 $(u,v)$의 간선 가중치를 의미한다.   Notice: Q 안에 v의 존재 유무를 판단하기 위해 구현 시에는 이를 추적하기 위한 추가적인 자료구조가 요구된다.    0 procedure Shortest-Path-Faster-Algorithm(G, s)  1    for each vertex v ≠ s in V(G)  2        d(v) := ∞  3    d(s) := 0  4    offer s into Q  5    while Q is not empty  6        u := poll Q  7        for each edge (u, v) in E(G)  8            if d(u) + w(u, v) &lt; d(v) then  9                d(v) := d(u) + w(u, v) 10                if v is not in Q then 11                    offer v into Q    하나씩 보자.   1    for each vertex v ≠ s in V(G) 2        d(v) := ∞  그래프 G의 출발 정점 s를 제외한 모든 정점 v에 대하여 s로부터 각 v에 대한 최단경로 거리 d(v)를 INF로 초기화 한다.    3    d(s) := 0  4    offer s into Q   먼저 출발 정점 s의 최단경로 거리를 0으로 초기화하고 s를 Q에 넣는다.   5    while Q is not empty   큐가 빌 때 까지 아래 연산들을 반복한다.   6    u := poll Q 7    for each edge (u, v) in E(G)   Q에서 정점하나를 꺼내 u라 하고, 그래프 G에서 u와 인접한 정점 v와의 간선 (u, v)에 대하여   8    if d(u) + w(u, v) &lt; d(v) then 9       d(v) := d(u) + w(u, v)  s로부터 u로의 최단경로 거리 d(u) + 간선 (u, v)의 값이 s로부터 v로의 최단경로 거리 d(v)보다 작다면 d(v)값을 d(u) + w(u, v)로 업데이트 한다. (Edge Relaxation)   10      if v is not in Q then 11          offer v into Q  변 경감 연산(Edge Relaxation)이 된 정점 v가 현재 Q에 없으면, v를 Q에 추가한다.   Step by step   실제 그래프를 예로 들어 SPFA가 어떻게 동작하는지 알아보자.   0번을 시작 정점으로 하여 5번 정점으로의 최단 경로를 구한다.   해당 정점에 연결된 인접 정점이 여러개 일 땐, 번호가 작은 것을 먼저 선택한다.      시작 정점으로 부터 모든 정점까지의 최단거리 d(v)를 무한대(INF)로 초기화 한다.  d(s)는 0으로 초기화 한다.   Queue에 시작 정점 0을 넣는다.  Queue : [0]      Queue에서 원소 하나를 pop한다.  0번 정점과 인접한 정점 1번에 대하여 d(0) + w(0, 1) &lt; d(1): 0 + 4 &lt; INF이므로  d(1)을 4로 업데이트 한다.   업데이트 되었으므로 1번 정점을 Queue에 넣는다.  Queue : [1]      0번 정점과 인접한 정점 2번에 대하여 d(0) + w(0, 2) &lt; d(1): 0 + 2 &lt; INF이므로  d(2)을 2로 업데이트 한다.   업데이트 되었으므로 2번 정점을 Queue에 넣는다.  Queue : [1 2]      Queue에서 원소 하나를 pop한다.  1번 정점과 인접한 정점 2번에 대하여 d(1) + w(1, 2) &lt; d(2): 4 + 5 &gt; 2이므로  d(2)를 업데이트 하지 않는다.   Queue : [2]      1번 정점과 인접한 정점 3번에 대하여 d(1) + w(1, 3) &lt; d(3): 4 + 10 &lt; INF이므로  d(3)을 14로 업데이트 한다.   업데이트 되었으므로 3번 정점을 Queue에 넣는다.  Queue : [2, 3]      Queue에서 원소 하나를 pop한다.  2번 정점과 인접한 정점 4번에 대하여 d(2) + w(2, 4) &lt; d(4): 2 + 3 &lt; INF이므로  d(4)을 5로 업데이트 한다.   업데이트 되었으므로 4번 정점을 Queue에 넣는다.  Queue : [3, 4]      Queue에서 원소 하나를 pop한다.  3번 정점과 인접한 정점 5번에 대하여 d(3) + w(3, 5) &lt; d(5): 14 + 11 &lt; INF이므로  d(5)을 25로 업데이트 한다.   업데이트 되었으므로 5번 정점을 Queue에 넣는다.  Queue : [4, 5]      Queue에서 원소 하나를 pop한다.  4번 정점과 인접한 정점 3번에 대하여 d(4) + w(4, 3) &lt; d(3): 5 + 4 &lt; 14이므로  d(3)을 9로 업데이트 한다.   업데이트 되었으므로 3번 정점을 Queue에 넣는다.  Queue : [5, 3]      Queue에서 원소 하나를 pop한다.  5번 정점과 인접한 정점이 없다.   Queue : [3]      Queue에서 원소 하나를 pop한다.  3번 정점과 인접한 정점 5번에 대하여 d(3) + w(3, 5) &lt; d(5): 9 + 11 &lt; 25이므로  d(5)을 20로 업데이트 한다.   업데이트 되었으므로 5번 정점을 Queue에 넣는다.  Queue : [5]      Queue에서 원소 하나를 pop한다.  5번 정점과 인접한 정점이 없다.   Queue : [ ]      큐가 비었으므로 SPFA가 완료되었다.   0번 부터 5번으로의 최단경로는 빨간선을 따라간 경로이고 그 거리는 20이다.      Implementation   다음은 위 의사코드를 바탕으로 SPFA를 구현한 자바 메소드이다.   static void shortestPathFasterAlgorithm(int s){     dist = new int[n];     onQueue = new boolean[n];     Arrays.fill(dist, INF);     Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();     queue.offer(s);     dist[s] = 0;     onQueue[s] = true;     while (!queue.isEmpty()){         int cur = queue.poll();         onQueue[cur] = false;         for (Edge e : graph[cur]){             if (dist[cur] + e.cost &lt; dist[e.to]){                 dist[e.to] = dist[cur] + e.cost; // Edge Relaxation             }         }     } }   현재 Queue에서 정점 $v$의 존재 유무를 추적하기 위해 위 코드에서는 onQueue[] 를 사용한다.     그래프의 가중치 간선 정보를 구성하기 위해 아래의 Edge 클래스를 사용한다.   to는 다음 인접 정점의 번호, cost는 간선 비용(가중치)를 나타낸다.   ... // static ArrayList&lt;Edge&gt; [] graph; ...  static class Edge{     int to;     int cost;      // Constructor     public Edge(int to, int cost) {         this.to = to;         this.cost = cost;     } }    다음은 SPFA를 구현한 자바 코드이다.   그래프의 입력은 예제 그래프를 사용하였고, 최단경로를 추적하고 구성하기 위해 pred[]배열을 선언한 뒤 SPFA의 실행 중에 어느 한 포인트에서 정점 u, v가 있고(정점 v가 u에 의해 relaxation 되어지는 정점), relaxation 되어진 정점 v가 있으면, 그 정점을 relaxation하게 만든 정점 u가 최단경로 상의 이전 노드 이므로 pred[e.to] = cur;를 하여 경로를 구축한다. 그 다음 printPathReconstruction함수로 경로를 출력한다.   이 프로그램은 최단경로 거리와 그 경로를 출력한다.      Input: Graph G, start vertex   Output: Distance of shortest path of Graph G, shortest path of Graph G   시작 정점은 0번이다.   import java.io.*; import java.util.*; import java.util.LinkedList;  /**  * This program is to find Shortest path in weighted graph using SPFA.  * Time Complexity : Worst case : O(VE) same as Standard Bellman ford  *                   Average case : O(E) - not proved  *  * @author Lemidia(Gyeong)  */  public class ShortestPathFasterAlgorithm{       // the number of vertices in Graph G     static int n;     // Shortest distance from s to each vertex v     static int dist[];     // for construct shortest path     static int pred[];     static ArrayList&lt;Edge&gt; [] graph;     static final int INF = Integer.MAX_VALUE;     // For check whether the vertex is on queue or not     static boolean onQueue[];       // Init Graph G     static void createGraph(){         graph = new ArrayList[n];         for (int i = 0; i &lt; n; i++){             graph[i] = new ArrayList&lt;&gt;();         }     }      // Add weighted direct edges.     static void addEdge(int from, int to, int cost){         Edge e = new Edge(to, cost);         graph[from].add(e);     }      static void shortestPathFasterAlgorithm(int s){         dist = new int[n];         pred = new int[n];         onQueue = new boolean[n];         Arrays.fill(dist, INF);         Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();         queue.offer(s);         dist[s] = 0;         onQueue[s] = true;         while (!queue.isEmpty()){             int cur = queue.poll();             onQueue[cur] = false;             for (Edge e : graph[cur]){                 if (dist[cur] + e.cost &lt; dist[e.to]){                     dist[e.to] = dist[cur] + e.cost; // Edge Relaxation                     pred[e.to] = cur; // store previous node                     if (onQueue[e.to] == false){ // Node(e.to) is not in the queue                         onQueue[e.to] = true;                         queue.offer(e.to);                     }                 }             }         }     }      static void printPathReconstruction(int start, int end){         if (end == start) {             System.out.print(start);             return;         }         pathReconstruction(start, pred[end]);         System.out.print(\" -&gt; \" + end );     }      public static void main(String[] args) throws IOException {         BufferedReader br = new BufferedReader(new InputStreamReader(System.in));          n = 6;         int start = 0;         createGraph();         addEdge(0, 1, 4);         addEdge(0, 2, 2);         addEdge(1, 2, 5);         addEdge(1, 3, 10);         addEdge(2, 4, 3);         addEdge(3, 5, 11);         addEdge(4, 3, 4);          shortestPathFasterAlgorithm(start);          System.out.println(\"Shortest path distance : \" + dist[5]);         System.out.print(\"Shortest path : \");         printPathReconstruction(start, 5);     }      static class Edge{         int to;         int cost;          public Edge(int to, int cost) {             this.to = to;             this.cost = cost;         }     } }   Output:  Shortest path distance : 20 Shortest path : 0 -&gt; 2 -&gt; 4 -&gt; 3 -&gt; 5   Optimization techniques   Small Label First (SLF) technique.   변 경감(Edge relaxation) 되어진 정점 $v$를 항상 Queue 뒤에 추가하였지만 이 technique에서는 그 추가되어진 정점 $v$의 $d(v)$와 Queue의 맨 앞 정점의 거리 $d(front(Q))$를 비교하고 $d(v)$가 더 작다면 $d(v)$를 Queue의 맨 앞으로 보낸다. 이 technique은 front에 원소 추가를 요구하므로 front와 rear 전부 pop(), offer()연산을 지원하는 Deque(데크) 자료구조를 사용함으로써 구현할 수 있다.   위 SPFA 자바 메소드에서 Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();를 Deque&lt;Integer&gt; queue = new LinkedList&lt;&gt;();로 하여 Deque를 사용한다.   다음은 이 technique의 의사코드이다.   procedure Small-Label-First(G, Q)      if d(back(Q)) &lt; d(front(Q)) then          u := pop back of Q          push u into front of Q   다음은 SPFA에 위 최적화를 적용한 코드이다.   static void shortestPathFasterAlgorithm(int s){     dist = new int[n];     pred = new int[n];     onQueue = new boolean[n];     Arrays.fill(dist, INF);     Deque&lt;Integer&gt; queue = new LinkedList&lt;&gt;();     queue.offer(s);     dist[s] = 0;     onQueue[s] = true;     while (!queue.isEmpty()){         int cur = queue.poll();         onQueue[cur] = false;         for (Edge e : graph[cur]){             if (dist[cur] + e.cost &lt; dist[e.to]){                 dist[e.to] = dist[cur] + e.cost; // Edge Relaxation                 pred[e.to] = cur; // store previous node                 if (onQueue[e.to] == false){ // Node(e.to) is not in the queue                     onQueue[e.to] = true;                     queue.offer(e.to);                     // Optimization &lt;Small Label First&gt;                     if (dist[e.to] &lt; dist[queue.peekFirst()]){                         queue.offerFirst(queue.pollLast());                     }                 }             }         }     } }    Large Label Last (LLL) technique.   Queue의 front 원소의 값이 현재 Queue에 들어있는 모든 정점의 평균보다 작게 하기 위해, Queue에 들어있는 모드 정점 $v$의 평균을 구하고, Queue 앞에서 부터 평균보다 큰 값을 가진 정점 $v$들을 Queue의 맨 뒤로 보내는 연산이다. 평균보다 작은 값을 가진 정점 $v$가 나오면 loop를 빠져나온다.   다음은 이 technique의 의사코드이다.    procedure Large-Label-Last(G, Q)      x := average of d(v) for all v in Q      while d(front(Q)) &gt; x          u := pop front of Q          push u to back of Q   Running time   The worst-case running time : $O(|V|\\cdot|E|)$   SPFA의 최악 실행 시간은 standard Bellman-Ford algorithm과 같은 $O(|V|\\cdot|E|)$ 이다.   The average running time : $O(|E|)$   실험으로 보여지는 SPFA의 평균 실행 시간은 $O(|E|)$ 수준이다. 그러나 평균 실행 시간은 아직 증명 되지 않았다.   References      Wikipedia - SPFA   wcipeg - Shortest path  ","categories": ["Algorithm"],
        "tags": ["Graph","Shortest Path","Queue","Search Algorithm"],
        "url": "http://localhost:4000/algorithm/SPFA/",
        "teaser":null},{
        "title": "다익스트라 알고리즘(Dijkstra Algorithm)- 예정 포스트",
        "excerpt":" ","categories": ["Algorithm"],
        "tags": ["Shortest Path"],
        "url": "http://localhost:4000/algorithm/Dijkstra/",
        "teaser":null},{
        "title": "연결 리스트(Linked List)",
        "excerpt":"Linked List  배열과 같이 선형 자료구조 이다.  원소들이 메모리 공간상에 연속적으로 저장 되어있지 않고, 그림과 같이 각 원소들이 포인터로 링크되어 있는 자료구조이다.   하나의 원소를 노드라고 표현하고, 데이터를 저장하는 Data 필드와 그 다음 노드를 가리키는 Next필드로 구성되어 있다.   추가적으로 연결 리스트의 맨 처음 노드를 가리키는 헤드라는 포인터를 두고 있다.   그림을 참고하자.      배열과 비교해 연결 리스트가 가지는 장점   베열은 유사한 타입의 선형 데이터를 저장하는데 사용될 수 있다.  하지만 배열은 다음과 같은 제한을 가진다.      배열 크기가 고정되어 있다.  그래서 우리는 배열의 상한크기를 미리 알고 있어야 한다.  또한, 일반적으로, 할당된 메모리는 사용량에 관계없이 상한과 동일하다.   배열에 원소를 삽입하는 연산은 연결 리스트와 비교해 다소 비용이 많이든다.  원소를 저장할 공간이 만들어져야 하며, 특정 위치에 값을 삽입한다면 다른 원소를 한칸 씩 쉬프트 해야할 수도 있다.   연결 리스트가 배열과 비교해 가지는 장점      동적 크기  연결 리스트의 크기는 고정되어 있지 않고, 프로그램 실행중에 동적으로 변할 수 있다.  운영체제가 프로그램상의 메모리 공간을 허용하는 한 연결 리스트의 크기를 신경 쓸 필요가 없다.   원소의 삽입 및 삭제가 수월하다.  배열과 비교해 연결 리스트의 삽입 삭제는 노드들 간에 포인터만 설정해주면 된다.  새로운 원소를 위해 다른 원소를 위치를 쉬프트 한다든지의 수고를 할 필요가 없다.   배열과 비교해 연결 리스트가 가지는 단점           임의 접근이 되지 않는다.  배열은 각 원소를 index 번호로 바로 접근할 수 있는 반면(Random access), 연결 리스트에서는 처음 노드부터 순차적으로 탐색해야 한다.            포인터로 인한 메모리상 추가적인 공간이 필요하다.  배열과 달리 연결 리스트는 다른 노드를 가리키는 포인터(Next)공간을 추가로 요구한다.            캐시 친화적이지 않다.  배열 요소는 연속된 메모리 공간상에 위치하므로 참조 지역성이 좋은 반면, 연결 리스트는 요소들이 링크되어 있고 메모리 상에 흩어져 존재하므로 참조 지역성이 없다.       Representation   연결 리스트는 첫번째 노드를 가리키는 헤드를 가지고 있다.  연결 리스트에 노드가 없다면 헤드는 NULL이다.      노드는 두개의 부분으로 구성되어 있다.      Data - 데이터를 저장하는 필드(Integer, Double, String, Object …)   Next(Pointer Or Reference) - 다음 노드를 참조하는 필드   다음은 자바로 구현한 연결 리스트 클래스이다.   class LinkedList {      Node head; // head of the list         /* Linked list Node*/     static class Node {          int data;          Node next;          Node(int d)          {              data = d;              next = null;          } // Constructor      }  }   연결 리스트는 하나의 클래스로 표현되고 있고, 노드는 그 안의 분리된 클래스로 표현되고 있다.   연결 리스트 클래스의 헤드는 노드를 참조하므로 노드 클래스 타입으로 선언 되어있다.   노드 클래스는 데이터를 저장하는 data필드와 다음 노드를 참조할 수 있는 next필드를 가지고 있다. 또한 생성자를 가지고 있는데, 이는 노드가 생성될 때 데이터를 d로 초기화하고, 포인터를 null로 초기화하는 역할을 한다.     위 클래스를 이용하여 노드 3개를 가진 연결리스트를 자바로 구현해 보자.   // A simple Java program to introduce a linked list  class LinkedList {      Node head; // head of list         /* Linked list Node.  This inner class is made static so that         main() can access it */     static class Node {          int data;          Node next;          Node(int d)          {              data = d;              next = null;          } // Constructor      }         /* method to create a simple linked list with 3 nodes*/     public static void main(String[] args)      {          /* 빈 연결 리스트 생성 */         LinkedList llist = new LinkedList();             llist.head = new Node(1);          Node second = new Node(2);          Node third = new Node(3);             /* 3개의 노드가 메모리상에 할당된다.            head와 second, third가 각 노드를 참조한다.              llist.head        second              third               |                |                  |               |                |                  |           +----+------+     +----+------+     +----+------+           | 1  | null |     | 2  | null |     |  3 | null |           +----+------+     +----+------+     +----+------+ */            llist.head.next = second; // 첫번째 노드와 두번째 노드를 연결한다.            /*  첫번째 노드의 next가 두번째 노드를 참조한다.             llist.head        second              third              |                |                  |              |                |                  |          +----+------+     +----+------+     +----+------+          | 1  |  o--------&gt;| 2  | null |     |  3 | null |          +----+------+     +----+------+     +----+------+ */            second.next = third; // 세번째 노드와 두번째 노드를 연결한다.            /*  두번째 노드의 next가 세번째 노드를 참조한다.             llist.head        second              third              |                |                  |              |                |                  |          +----+------+     +----+------+     +----+------+          | 1  |  o--------&gt;| 2  |  o--------&gt;|  3 | null |          +----+------+     +----+------+     +----+------+ */     }  }    Inserting a node   연결 리스트에 노드를 추가 해보자.   노드를 추가하는 데에는 3 가지 케이스가 있다.      연결 리스트 맨 앞에 추가   특정 노드 뒤에 추가   연결 리스트 맨 뒤에 추가   연결 리스트 맨 앞에 추가      추가할 노드를 할당한다.   노드에 데이터를 넣는다.   추가할 노드의 next 포인터가 첫번째 노드를 참조하게 한다.   헤드가 추가한 노드를 참조하게 함으로써 처음 노드임을 가리킨다.      다음은 위의 연산을 구현한 자바 메소드이다.   /* This function is in LinkedList class. Inserts a     new Node at front of the list. */ public void push(int new_data)  {      /* 1 &amp; 2: Allocate the Node &amp;                Put in the data*/     Node new_node = new Node(new_data);         /* 3. Make next of new Node as head */     new_node.next = head;         /* 4. Move the head to point to new Node */     head = new_node;  }    이 연산의 시간복잡도는 O(1)이 된다.   특정 노드 뒤에 추가      특정 노드가 null인지 확인한다.  null이면 아무런 작업이 수행되지 않는다.   추가할 노드를 할당한다.   추가할 노드에 데이터를 넣는다.   추가할 노드가 특정노드가 참조하는 다음 노드를 참조하게 한다.   특정 노드가 추가할 노드를 참조하게 한다.      다음은 위의 연산을 구현한 자바 메소드이다.   /* This function is in LinkedList class.     Inserts a new node after the given prev_node. */ public void insertAfter(Node prev_node, int new_data)  {      /* 1. Check if the given Node is null */     if (prev_node == null)      {          System.out.println(\"The given previous node cannot be null\");          return;      }         /* 2. Allocate the Node &amp;         3. Put in the data*/     Node new_node = new Node(new_data);         /* 4. Make next of new Node as next of prev_node */     new_node.next = prev_node.next;         /* 5. make next of prev_node as new_node */     prev_node.next = new_node;  }    이 연산의 시간복잡도는 O(1)이 된다.   연결 리스트 맨 뒤에 추가      추가할 노드를 할당한다.   추가할 노드에 데이터를 넣는다.   연결 리스트가 null이면, 헤드가 추가할 노드를 참조하게 함으로써 연산을 끝낸다.   그렇지 않다면, 처음 노드부터 탐색을 시작하여 마지막 노드를 찾는다.   마지막 노드가 추가할 노드를 참조하게 한다.      다음은 위의 연산을 구현한 자바 메소드이다.    // Appends a new node at the end.  public void append(int new_data)  {      /* 1. Allocate the Node &amp;         2. Put in the data */     Node new_node = new Node(new_data);         /* 3. If the Linked List is empty, then make the             new node as head */     if (head == null)      {          head = new Node(new_data);          return;      }      /* 4. Else traverse till the last node */     Node last = head;       while (last.next != null)          last = last.next;         /* 5. Change the next of last node */     last.next = new_node;      return;  }    이 연산의 시간복잡도는 탐색으로 인하여 O(n)이 된다.  연결 리스트의 끝 노드의 정보를 가지고 있는 tail 포인터를 둔다면, 이 연산의 시간복잡도는 O(1)이 된다.   다음은 위 연산을 포한한 예제 자바 코드이다.   // A complete working Java program to demonstrate all insertion methods  // on linked list  class LinkedList  {      Node head;  // head of list         /* Linked list Node*/     class Node      {          int data;          Node next;          Node(int d) {data = d; next = null; }      }         /* Inserts a new Node at front of the list. */     public void push(int new_data)      {          /* 1 &amp; 2: Allocate the Node &amp;                    Put in the data*/         Node new_node = new Node(new_data);             /* 3. Make next of new Node as head */         new_node.next = head;             /* 4. Move the head to point to new Node */         head = new_node;      }         /* Inserts a new node after the given prev_node. */     public void insertAfter(Node prev_node, int new_data)      {          /* 1. Check if the given Node is null */         if (prev_node == null)          {              System.out.println(\"The given previous node cannot be null\");              return;          }             /* 2 &amp; 3: Allocate the Node &amp;                    Put in the data*/         Node new_node = new Node(new_data);             /* 4. Make next of new Node as next of prev_node */         new_node.next = prev_node.next;             /* 5. make next of prev_node as new_node */         prev_node.next = new_node;      }            /* Appends a new node at the end.  This method is          defined inside LinkedList class shown above */     public void append(int new_data)      {          /* 1. Allocate the Node &amp;             2. Put in the data */         Node new_node = new Node(new_data);             /* 3. If the Linked List is empty, then make the                new node as head */         if (head == null)          {              head = new Node(new_data);              return;          }             /* 4. Else traverse till the last node */         Node last = head;           while (last.next != null)              last = last.next;             /* 5. Change the next of last node */         last.next = new_node;          return;      }         /* This function prints contents of linked list starting from          the given node */     public void printList()      {          Node tnode = head;          while (tnode != null)          {              System.out.print(tnode.data+\" \");              tnode = tnode.next;          }      }         /* Driver program to test above functions. Ideally this function         should be in a separate user class.  It is kept here to keep         code compact */     public static void main(String[] args)      {          /* Start with the empty list */         LinkedList llist = new LinkedList();             // Insert 6.  So linked list becomes 6-&gt;NUllist          llist.append(6);             // Insert 7 at the beginning. So linked list becomes          // 7-&gt;6-&gt;NUllist          llist.push(7);             // Insert 1 at the beginning. So linked list becomes          // 1-&gt;7-&gt;6-&gt;NUllist          llist.push(1);             // Insert 4 at the end. So linked list becomes          // 1-&gt;7-&gt;6-&gt;4-&gt;NUllist          llist.append(4);             // Insert 8, after 7. So linked list becomes          // 1-&gt;7-&gt;8-&gt;6-&gt;4-&gt;NUllist          llist.insertAfter(llist.head.next, 8);             System.out.println(\"\\nCreated Linked list is: \");          llist.printList();      }  }  // This code is contributed by Rajat Mishra    Output: Created Linked list is:  1  7  8  6  4   Deleting a node   이번에는 연결 리스트에서 특정 키 값을 갖고 있는 노드를 삭제 해보자.      삭제될 노드를 참조할 temp 포인터와 그 이전 노드를 참조하는 prev 포인터를 둔다.   temp는 헤드를 참조하게 함으로써 처음 노드를 참조하게 한다.   만약 삭제될 노드가 처음 노드라면, 헤드가 temp 다음 노드를 참조하게 하고 연산을 끝낸다.   그렇지 않다면, 삭제할 키 값을 가지고 있는 노드를 탐색한다.   탐색함에 따라 삭제될 노드와 그 이전 노드 정보를 가지고 있는 temp, prev 포인터들을 갱신한다.   temp가 null이거나 삭제될 키 값을 가진 노드를 찾으면 반복문을 빠져나온다.   temp가 null이면 원하는 키값을 가진 노드를 찾지 못한 것이므로 아무런 작업도 하지 않고 연산을 끝낸다.   그렇지 않다면 찾은 것이므로, prev 포인터가 temp.next 참조하게 함으로써 작업을 끝낸다.      다음은 위의 연산을 구현한 자바 메소드이다.    /* Given a key, deletes the first occurrence of key in linked list */     void deleteNode(int key)      {          // 1 &amp; 2. Store head node to temp, prev         Node temp = head, prev = null;             // 3. If head node itself holds the key to be deleted          if (temp != null &amp;&amp; temp.data == key)          {              head = temp.next; // Changed head              return;          }             // 4. Search for the key to be deleted, keep track of the          // previous node as we need to change temp.next          while (temp != null &amp;&amp; temp.data != key) // 6.         {              // 5. keep track of the previous node             //    as we need to change temp.next              prev = temp;                     temp = temp.next;          }                 // 7. If key was not present in linked list          if (temp == null) return;             // 8. Unlink the node from linked list          prev.next = temp.next;      }     이 연산의 시간복잡도는 O(n)이 된다.  순수 삭제연산은 O(1)이지만, 삭제될 키 값을 찾아 탐색하는 연산이 추가되었으므로 O(n)이 된다.   특정 키 값의 노드 찾기   연결 리스트에서 특정 키 값 x를 가진 노드를 찾아보자.   search 메소드는 키 값 x를 가진 노드가 존재하면 true, 존재하지 않으면 false를 리턴한다.      리스트를 순회할 current를 헤드로 초기화한다.   current가 null 아닐 때 까지 반복한다.  null이면 while 빠져나와 false 리턴하고 연산을 끝낸다.   current가 참조하는 노드의 데이터가 x라면 true 리턴하고 연산을 끝낸다.   그렇지 않다면 다음 노드를 참조하고 2번으로 다시 간다.   다음은 위의 연산을 구현한 자바 메소드이다.   //Checks whether the value x is present in linked list      public boolean search(Node head, int x)      {          Node current = head;    // 1 포인터 초기화         while (current != null) // 2. current가 null 아닐 때 까지 반복한다         {              if (current.data == x)                  return true;    //3. 찾았다             current = current.next; // 4. 다음 노드를 참조한다         }          return false;    // 데이터를 찾지 못하였다     }    다음은 위 연산을 포한한 예제 자바 코드이다.   // Iterative Java program to search an element  // in linked list     //Node class  class Node  {      int data;      Node next;      Node(int d)      {          data = d;          next = null;      }  }     //Linked list class  class LinkedList  {      Node head;    //Head of list         //Inserts a new node at the front of the list      public void push(int new_data)      {          //Allocate new node and putting data          Node new_node = new Node(new_data);             //Make next of new node as head          new_node.next = head;             //Move the head to point to new Node          head = new_node;      }         //Checks whether the value x is present in linked list      public boolean search(Node head, int x)      {          Node current = head;    //Initialize current          while (current != null)          {              if (current.data == x)                  return true;    //data found              current = current.next;          }          return false;    //data not found      }         //Driver function to test the above functions      public static void main(String args[])      {             //Start with the empty list          LinkedList llist = new LinkedList();             /*Use push() to construct below list          14-&gt;21-&gt;11-&gt;30-&gt;10  */         llist.push(10);          llist.push(30);          llist.push(11);          llist.push(21);          llist.push(14);             if (llist.search(llist.head, 21))              System.out.println(\"Yes\");          else             System.out.println(\"No\");      }  }  // This code is contributed by Pratik Agarwal    Output: Yes  연결 리스트 연산들의 시간복잡도  시간복잡도 - 최악 기준        접근     검색      삽입     삭제\t O(n)    O(n)\t O(1)\t O(1)\t    References   GeeksforGeeks  ","categories": ["Data Structure"],
        "tags": ["programming","Data Structure","Linked List"],
        "url": "http://localhost:4000/data%20structure/LinkedList/",
        "teaser":null},{
        "title": "스택(Stack)",
        "excerpt":"스택(Stack)  스택은 원소의 특정한 순서를 유지하고 특정 연산을 가지고 있는 선형 자료구조이다.   스택은 후입선출의 선형 자료 구조로서, 한쪽 끝에서만 삽입 및 삭제가 수행된다.  나중에 들어간 원소가 먼저 들어온 원소보다 먼저 나간다 하여 후입선출이라 불리게 된다.   스택은 또한 Top이라 불리는 포인터를 가지고 있는데 이는, 스택의 맨 위의 원소를 가리킨다.(그림상)      스택의 기본 연산   스택이 가지고 있는 연산들을 보자.   Push   스택에 원소를 삽입한다.  스택이 Full이라면 Overflow 에러가 난다.      Notice: 새로운 원소가 삽입됨에 따라 Top이 10을 가리키고 있다.   Pop - 스택에서 원소를 삭제한다.   스택에서 원소를 삭제한다.  스택이 빈 공간이면, Underflow 에러가 난다.      Notice: 기존 원소가 삭제됨에 따라 Top이 93을 가리키고 있다.   Peek  스택에서 Top 가리키고 있는 원소를 반환한다.   Notice: 원소가 삽입, 삭제 되는 것이 아닌 원소 반환이므로 Top의 위치는 변화가 없다.      isEmpty  스택이 빈 공간이라면 true, 아니라면 false를 반환한다.   스택의 응용   스택은 많은 곳에서 응용되어 쓰인다.      괄호의 균형성 검사. ex) (()) 짝이 맞는지   웹브라우저의 앞으로 가기 또는 뒤로 가기   그래프 알고리즘 중에서 위상정렬이나 강한연결요소   대표적 백트래킹 문제 - N-Queen, Knight tour, rat in a maze, sudoku   스택을 이용한 여러 알고리즘 문제 - 하노이 탑, 트리순회, 히스토그램 면적 등   중위식 표기법의 후위식 표기법으로의 변환   구현   스택을 구현하는 데에는 크게 두 가지 방법이 있다.      배열을 이용   연결 리스트를 이용   먼저 배열을 이용한 스택 구현을 보자.   배열을 이용한 스택 구현   스택 클래스의 프로퍼티와 생성자   스택의 최대 크기를 결정하는 MAX 상수, top 포인터, 원소를 담을 배열을 선언한다.  스택이 생성되면 top을 -1로 초기화할 생성자를 선언한다.  class Stack {      static final int MAX = 1000;      int top;      int a[] = new int[MAX]; // Maximum size of Stack       public Stack() // Constructor of Stack Class     {          top = -1;      }  }   스택 클래스의 메서드 - push   스택에 원소를 삽입하는 메서드이다.   top이 배열의 끝(MAX-1)을 가리키고 있으면 스택은 다 차서 더 이상 원소 삽입이 안되므로 에러 메세지를 출력하고 false를 리턴한다.   그렇지 않다면 top을 한 칸 올리고 그 자리에 원소를 삽입한다.   boolean push(int x)  {      if (top &gt;= (MAX - 1)) {          System.out.println(\"Stack Overflow\");          return false;      }      else {          a[++top] = x;          System.out.println(x + \" pushed into stack\");          return true;      }  }    스택 클래스의 메서드 - pop   스택에서 원소를 삭제하는 메서드이다.   top이 0보다 작으면 스택은 빈 공간이므로 에러 메세지를 출력하고 false를 리턴한다.   그렇지 않다면 top이 가리키는 원소를 리턴하고 top은 한 칸 감소한다.   int pop()  {      if (top &lt; 0) {          System.out.println(\"Stack Underflow\");          return 0;      }      else {          int x = a[top--];          return x;      }  }    스택 클래스의 메서드 - peek   스택의 top이 가리키는 원소를 반환하는 메서드이다.   top이 0보다 작으면 스택은 빈 공간이므로 에러 메세지를 출력하고 false를 리턴한다.   그렇지 않다면 top이 가리키는 원소를 리턴한다.   int peek()  {      if (top &lt; 0) {          System.out.println(\"Stack Underflow\");          return 0;      }      else {          int x = a[top];          return x;      }  }    스택 클래스의 메서드 - isEmpty   스택이 빈 공간인지 확인하는 메서드이다.   top이 0보다 작으면 스택은 빈 공간이므로 true 리턴   그렇지 않다면 원소가 있다는 뜻이므로 false 리턴   int peek()  boolean isEmpty()  {      return (top &lt; 0);  }    전체 코드   다음은 배열을 이용하여 스택을 구현한 전체 코드이다.   /* Java program to implement basic stack  operations */ class Stack {      static final int MAX = 1000;      int top;      int a[] = new int[MAX]; // Maximum size of Stack         boolean isEmpty()      {          return (top &lt; 0);      }      Stack()      {          top = -1;      }         boolean push(int x)      {          if (top &gt;= (MAX - 1)) {              System.out.println(\"Stack Overflow\");              return false;          }          else {              a[++top] = x;              System.out.println(x + \" pushed into stack\");              return true;          }      }         int pop()      {          if (top &lt; 0) {              System.out.println(\"Stack Underflow\");              return 0;          }          else {              int x = a[top--];              return x;          }      }         int peek()      {          if (top &lt; 0) {              System.out.println(\"Stack Underflow\");              return 0;          }          else {              int x = a[top];              return x;          }      }  }     // Driver code  class Main {      public static void main(String args[])      {          Stack s = new Stack();          s.push(10);          s.push(20);          s.push(30);          System.out.println(s.pop() + \" Popped from stack\");      }  }   Output : 10 pushed into stack 20 pushed into stack 30 pushed into stack 30 popped from stack   연결 리스트 이용한 스택 구현   연결 리스트를 이용한 스택 클래스 표현   스택의 top을 표현할 StackNode 타입의 root 레퍼런스 가지고 있다.   또한, 스택 원소 즉, 노드를 표현할 내부 클래스를 가지고 있다.  내부 클래스인 스택 노드 클래스는 데이터를 담을 data 변수, 다음 원소를 가리키는 next 레퍼런스 변수를 가지고 있다.   public class StackAsLinkedList {     StackNode root;       static class StackNode {          int data;          StackNode next;          StackNode(int data) {              this.data = data;          }      }  }   스택 클래스의 메서드 - push   데이터를 받아 노드를 할당한다.   스택이 빈 공간이면 단순히 root가 새로 생성된 노드를 가리키게 한다.   빈 공간이 아니라면 임시 레퍼런스 변수 temp가 root를 가리키게한다.  root는 새로 생성된 노드를 가리키게 하고, 새로 생성된 노드는 temp를 가리키게 한다.   public void push(int data)  {      StackNode newNode = new StackNode(data);       if (root == null) {          root = newNode;      }      else {          StackNode temp = root;          root = newNode;          newNode.next = temp;      }      System.out.println(data + \" pushed to stack\");  }    스택 클래스의 메서드 - pop   스택이 빈 공간이면 에러 메세지를 출력하고 int 최소 값을 반환한다.  (여기서는 Integer.MIN_VALUE는 빈 공간임을 표시하는 수로 쓰였다.)   빈 공간이 아니라면 popped 변수에 값을 담고, root는 다음 변수를 가리키게 한다.  popped을 리턴한다.   public int pop()  {      int popped = Integer.MIN_VALUE;      if (root == null) {          System.out.println(\"Stack is Empty\");      }      else {          popped = root.data;          root = root.next;      }      return popped;  }    스택 클래스의 메서드 - peek   스택이 빈 공간이면 에러 메세지를 출력하고 int 최소 값을 반환한다.  (여기서도 Integer.MIN_VALUE는 빈 공간임을 표시하는 수로 쓰였다.)   빈 공간이 아니라면 root가 가리키는 값을 리턴한다.   public int peek()  {      if (root == null) {          System.out.println(\"Stack is empty\");          return Integer.MIN_VALUE;      }      else {          return root.data;      }  }    스택 클래스의 메서드 - isEmpty   스택이 빈 공간 즉, root가 null이면 true 리턴, 아니라면 false 리턴   public boolean isEmpty()  {      if (root == null) {          return true;      }      else         return false;  }    전체 코드   다음은 연결 리스트를 이용하여 스택을 구현한 전체 코드이다.   public class StackAsLinkedList {         StackNode root;         static class StackNode {          int data;          StackNode next;             StackNode(int data)          {              this.data = data;          }      }         public boolean isEmpty()      {          if (root == null) {              return true;          }          else             return false;      }         public void push(int data)      {          StackNode newNode = new StackNode(data);             if (root == null) {              root = newNode;          }          else {              StackNode temp = root;              root = newNode;              newNode.next = temp;          }          System.out.println(data + \" pushed to stack\");      }         public int pop()      {          int popped = Integer.MIN_VALUE;          if (root == null) {              System.out.println(\"Stack is Empty\");          }          else {              popped = root.data;              root = root.next;          }          return popped;      }         public int peek()      {          if (root == null) {              System.out.println(\"Stack is empty\");              return Integer.MIN_VALUE;          }          else {              return root.data;          }      }         public static void main(String[] args)      {             StackAsLinkedList sll = new StackAsLinkedList();             sll.push(10);          sll.push(20);          sll.push(30);             System.out.println(sll.pop() + \" popped from stack\");             System.out.println(\"Top element is \" + sll.peek());      }  }   Output : 10 pushed to stack 20 pushed to stack 30 pushed to stack 30 popped from stack Top element is 20   스택 연산들의 시간복잡도  시간복잡도 - 최악 기준        push    pop      peek    isEmpty\t O(1)    O(1)\t O(1)\t O(1)\t    References  GeeksforGeeks  ","categories": ["Data Structure"],
        "tags": ["programming","Data Structure","Linked List","Array","Stack"],
        "url": "http://localhost:4000/data%20structure/Stack/",
        "teaser":null},{
        "title": "버블소트(Bubble Sort)",
        "excerpt":"Bubble(버블 정렬)   비교 기반 정렬 알고리즘이다.   정렬이 실행되면서 마치 형태가 거품이 수면위로 떠오르는 것 같은 모양을 한다고 하여 붙여진 이름이다.   인접한 두 원소를 비교하여 기준에 따라 스왑하고, 한 칸씩 옆으로 가면서 이를 n번째 원소까지 반복한다.   이를 모든 원소에 대해 n번 반복한다.  (최적화를 하면 배열의 원소 위치상태에 따라 횟수가 n번 보다 낮아질 수 있다.)   다른 O(nlongn)의 성능을 내는 정렬 알고리즘에 비해 성능이 좋지 않으므로 실무에서는 사용되지 않고 교육용 목적으로 사용 되어진다.   더 효율적인 정렬 알고리즘인 팀소트(Timsort)나 머지소트(Merge sort)가 인기있는 프로그래밍 언어(java, python)의 내장 정렬 라이브러리로 사용되고 있다.    Algorithm   밑의 애니메이션을 먼저 보고 알고리즘을 읽으면 이해가 빠를 수 있다.      처음 원소를 시작으로 n번째 원소까지 차례대로 인접한 원소와 오른쪽으로 비교하며 스왑을 진행한다.   n번째 원소와 비교가 끝이나면 n번째 원소는 정렬이 완료된 것이다.   다시 처음 원소부터 n-1번째 원소까지 인접한 원소와 비교하며 필요하면 스왑을 한다.   n-1번째 원소와 비교가 끝이나면 n-1번째 원소는 정렬이 완료된 것이다.   이를 반복하여, n-2..n-3..2번째 원소까지 정렬이 완료되면 알고리즘은 끝이난다.   Animation - Bubble sort     Analysis   버블소트는 최악과 평균 시간복잡도가 $O(n^2)$인 (2중 루프로 인해) 정렬 알고리즘이다.   최악과 평균 시간복잡도가 $O(nlog_{2}n)$인 실용적인 정렬 알고리즘 보다 성능이 좋지않고  시간복잡도가 $O(n^2)$인 삽입정렬도 버블소트보다는 빠르게 동작하기 때문에 버블소트는 다소 실용적인 정렬 알고리즘이 아니다.   다른 정렬들과 비교해(삽입정렬을 제외한) 버블소트의 최대 장점은 배열이 정렬되어 있는 것을 탐지해낼 수 있는 능력이다.   리스트가 정렬이 완료되어 있을 때의 버블정렬은 O(n)이다.   Step-by-step example   배열 [5 1 4 2 8]이 있다고 하자.   처음 원소부터 끝 원소까지 오름차순으로 버블소트를 이용하여 정렬하려고 한다.   첫번째 패스   ( 5 1 4 2 8 ) → ( 1 5 4 2 8 )   첫번째 원소와 두번째 원소를 비교한다, 5 &gt; 1 이므로 스왑한다.  ( 1 5 4 2 8 ) → ( 1 4 5 2 8 )   두번째 원소와 세번째 원소를 비교한다, 5 &gt; 4 이므로 스왑한다.  ( 1 4 5 2 8 ) → ( 1 4 2 5 8 )   세번째 원소와 네번째 원소를 비교한다, 5 &gt; 2 이므로 스왑한다.  ( 1 4 2 5 8 ) → ( 1 4 2 5 8 )   네번째 원소와 다섯번째 원소를 비교한다, 5 &lt; 8 이므로 그대로 둔다.  첫번째 패스가 끝났다.  두번째 패스  ( 1 4 2 5 8 ) → ( 1 4 2 5 8 )   첫번째 원소와 두번째 원소를 비교한다, 1 &lt; 4 이므로 그대로 둔다. ( 1 4 2 5 8 ) → ( 1 2 4 5 8 )   두번째 원소와 세번째 원소를 비교한다, 4 &gt; 2 이므로 스왑한다.  ( 1 2 4 5 8 ) → ( 1 2 4 5 8 )   세번째 원소와 네번째 원소를 비교한다, 4 &lt; 5 이므로 그대로 둔다. ( 1 2 4 5 8 ) → ( 1 2 4 5 8 )   첫번째 원소와 두번째 원소를 비교한다, 5 &lt; 8 이므로 그대로 둔다.  두번째 패스가 끝났다.  이제, 배열은 이미 오름차순으로 정렬이 완료되었다. 그러나, 알고리즘은 정렬이 완료되었는지 아직 모른다.  정렬이 완료되었는지 알기 위해선 하나의 패스를 더 거쳐야 한다.  (불리언 변수 하나를 두어 이를 알 수 있는데, 밑의 구현에서 알아본다.)  세번째 패스  ( 1 2 4 5 8 ) → ( 1 2 4 5 8 )   ( 1 2 4 5 8 ) → ( 1 2 4 5 8 )   ( 1 2 4 5 8 ) → ( 1 2 4 5 8 )   ( 1 2 4 5 8 ) → ( 1 2 4 5 8 )    세번째 패스가 끝났다.  스왑된 원소가 없으므로 알고리즘은 더 이상 패스를 수행하지 않는다.  알고리즘을 종료한다.   Implementation   다음은 버블소트를 의사코드로 구현한 것이다.   버블소트 의사코드 구현 (index is 0 base)   procedure bubbleSort(A : list of sortable items)     n := length(A) // 배열 길이, 원소 개수     repeat // 반복한다.         swapped = false // 스왑이 되었는지 여부         for i := 1 to n - 1 inclusive do // [1 ~ n-1]까지             /* 만약 두 원소가 순서에 어긋나면 */             if A[i - 1] &gt; A[i] then                 /* 스왑하고, 스왑되었다는 것을 체크한다. */                 swap(A[i - 1], A[i])                 swapped := true              end if         end for     // 스왑이 안되었을때 까지, 즉, swapped가 true면 repeat로 간다.     until not swapped end procedure   버블소트 최적화   n번째 패스가 끝이나면 n번째로 큰 원소는 이미 정렬이 완료되어 그자리에 위치가 변하지 않기에, 내부 루프는 매 패스마다, 0번째 부터 n번째 까지 원소를 비교할 필요가 없다.   한번의 패스가 끝이나면 n을 n-1로, 즉 1씩 줄여 쓸때없는 연산을 피할 수 있다.   procedure bubbleSort(A : list of sortable items)     n := length(A)     repeat         swapped := false         for i := 1 to n - 1 inclusive do             if A[i - 1] &gt; A[i] then                 swap(A[i - 1], A[i])                 swapped = true             end if         end for         // n을 1 감소시켜 다음번 패스 때 불필요한 연산을 하지 않는다.         n := n - 1     until not swapped end procedure   한가지 더 최적화를 해보자.   한 번의 패스로 하나 이상의 원소가 최종 정렬된 자리에 올 수 있다.  그렇다면 우리는 최종 정렬된 원소를 굳이 비교하지 않고 스킵할 수 있다.   다음은 이를 구현한 슈도 코드이다.   새로운 변수 newn을 주목하라.   procedure bubbleSort(A : list of sortable items)     n := length(A)     repeat         // newn: 몇 번째 원소까지 비교가 완료 되었는지         newn := 0         for i := 1 to n - 1 inclusive do             if A[i - 1] &gt; A[i] then                 swap(A[i - 1], A[i])                 newn := i             end if         end for         n := newn         // n이 1보다 작거나 같으면 반복문을 빠져 나온다.     until n ≤ 1 end procedure   [3 2 1 4 5]인 배열이 있다고 해보자.   첫번째 패스를 거치면  인덱스 0~4번 까지 비교를 하게 된다.  [2 1 3 4 5]가 된다.   이 때, newn은 2가 된다.  이는 2번 인덱스에서 마지막으로 스왑이 되었고, 그 이후로는 스왑이되지 않았다.  즉, 그 이후로는 정렬이 완료되었으니 정렬이 불필요하다는 것을 의미한다.   두번때 패스에서는  원래 대로라면 인덱스 0~3번 까지 비교를 하게 되겠지만  최적화를 거치면 첫번째 패스에서 newn은 2인 것을 아니까  인덱스 0~3, 0~2를 스킵하고, 0~1번 까지만 비교가 진행되게 된다.   이로서 불필요한 패스를 줄임으로서 최악 기준 약 50%의 성능 향상을 기대할 수 있다.   시간복잡도   최악 시간복잡도\t$O(n^2)$  최선 시간복잡도\t$O(n)$ - 배열이 이미 정렬 완료되었을 때  평균 시간복잡도\t$O(n^2)$   References   Bubble Sort - wikipedia  ","categories": ["Algorithm"],
        "tags": ["Sort","Array","Mathematics"],
        "url": "http://localhost:4000/algorithm/bubble-sort/",
        "teaser":null},{
        "title": "선형구조와 탐색(Linear Structure and Search)",
        "excerpt":"선형구조의 탐색   선형구조란 자료의 순서를 유일하게 결정할 수 있는 형태의 구조를 말한다. $i$번째 자료 를 탐색한 다음, $i+1$번째로 탐색 해야할 자료가 유일한 형태를 의미한다. 2차원, 3차원 구조라도 순서가 일정하게 정해져 있으면 이는 선형이라고 할 수 있다.   선형구조는 주로 배열과 리스트의 형태로 저장된다. 일반적으로 1차원 배열에 자료를 저장하는 1차원 선형구조와 2차원 이상의 배열에 자료가 저장이 되어있는 다차원 선형구조로 나눌 수 있다.   선형구조의 탐색은 선형구조로 저장된 자료들 중에서 원하는 것을 찾는 작업을 말한다. 선형구조를 탐색하는 방법은 기본적으로 순차탐색과 이분탐색이 있고, 이들을 적절히 응용한 탐색법도 만들어 사용할 수 있다. 이 단원에서는 순차탐색과 이분탐색을 익히고 이를 통하여 간단한 문제를 해결하는 실습을 한다.   순차탐색   순차탐색은 자료의 특성에 관계없이 사용할 수 있는 일반적인 방법으로 전체탐색기법의 한 방법이다. 첫 번째 원소로부터 시작하여 한 원소씩 차례로 다음 원소를 탐색해 나가는 방법으로 자료가 $n$개 있을 때의 계산량은 $O(n)$이다.   탐색 순서를 그림으로 나타내면 다음과 같다.      다음은 선형탐색을 구현한 소스코드이다.  public class LinearSearch {     public static boolean linearSearch(int S[], int k){         for (int i = 0; i &lt; S.length; i++) {             if (S[i] == k)                 return true;         }         return false;     }      public static void main(String[] args) {         int S[] = {5, 2, 6, 2, 1, 8};         int k = 4;         System.out.print(linearSearch(S, k));     } }   이분탐색   이분탐색은 배열에서 중간 원소를 선택하여 찾는 값과 비교하고 중간 원소의 값이 찾는 값보다 작다면 중간 원소를 기준으로 오른쪽을 탐색, 중간 원소의 값이 찾는 값보다 크다면 중간 원소를 기준으로 왼쪽을 탐색하는 기법이다. 이 알고리즘은 오름차순이나 내림차순으로 정렬된 선형구조에서 원하는 원소를 찾는 것으로 계산량은 $O(log_2n)$이다.      이분탐색의 탐색순서(원은 처음 접근하는 원소이고, 사각형은 찾은 곳의 값이 찾으려는 값보다 작으면 찾는 위치, 둥근 사각형은 그 값의 반대조건일 경우에 탐색하는 위치이다. 조건의 결과에 따라 왼쪽 또는 오른쪽 중 하나를 탐색하게 된다.)   다음은 이분탐색을 구현한 C++ 소스코드이다.  $S$에 $n$개의 원소를 입력받고, 그 중에 $k$가 있는지를 찾는 알고리즘이다.   // 이분탐색 - 반복 #include &lt;stdio.h&gt; int S[100], n, k; int find(int s, int e) {   while(s&lt;=e) {  // s가 e보다 작거나 같을 때 까지     int m=(s+e)/2; // 중간 원소     if(S[m]==k) return m; // 찾았다      // 탐색한 원소가 찾고자 하는 원소 보다 크다     //탐색한 원소의 왼쪽 배열 탐색     if(S[m]&gt;k) e=m‐1;      // 탐색한 원소가 찾고자 하는 원소 보다 작다     //탐색한 원소의 오른쪽 배열 탐색     else s=m+1;   }   return ‐1; // 원하는 원소를 찾지 못했다. } int main() {   scanf(\"%d%d\", &amp;n, &amp;k);   for(int i=0; i&lt;n; i++ )     scanf(\"%d\", &amp;S[i]);    printf(\"%d\\n\", find(0, n‐1));   return 0; }   다음은 재귀로 이분탐색을 구현한 java 소스코드이다.    // 이분탐색 - 재귀 import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.Arrays; import java.util.StringTokenizer;  public class BinarySearchRecur {     private static int S[] = new int[100];     private static int n, k; // 배열 크기, 찾고자 하는 원소      public static int find(int s, int e){         if (s &gt; e) // 원하는 원소를 찾지 못했다             return -1;         int m = (s+e)/2; // 중간 원소         if (S[m] == k) // 찾았다             return m;         else if (S[m] &lt; k) // 탐색한 원소가 찾고자 하는 원소 보다 작다             return find(m+1, e); //탐색한 원소의 오른쪽 배열 탐색         else               // 탐색한 원소가 찾고자 하는 원소 보다 크다             return find(s, m-1); //탐색한 원소의 왼쪽 배열 탐색     }      public static void main(String[] args) throws IOException {         BufferedReader br = new BufferedReader(new InputStreamReader(System.in));         StringTokenizer st = new StringTokenizer(br.readLine()); // n, k         n = Integer.parseInt(st.nextToken());         k = Integer.parseInt(st.nextToken());         st = new StringTokenizer(br.readLine()); // S array         Arrays.sort(S);         for (int i = 0; i &lt; n; i++) {             S[i] = Integer.parseInt(st.nextToken());         }         System.out.print(find(0, n-1)); // index 반환     } }  /*  Test Case ----------- input 5 19 3 4 2 19 4  output 3 ----------- input 5 10 3 4 2 19 4  output -1  */    기본적인 탐색방법을 익힐 수 있는 다음 문제들을 해결해보자.   최댓값   9개의 서로 다른 자연수가 주어질 때, 이들 중 최댓값을 찾고  그 값이 몇 번째 수 인지를 구하는 프로그램을 작성하시오.  예를 들어, 서로 다른 9개의 자연수가 각각 3, 29, 38, 12, 57, 74, 40, 85, 61 라면,   이 중 최댓값은 85이고, 이 값은 8번째 수이다.  ----------------------------------------  입력 첫째 줄부터 아홉째 줄까지 한 줄에 하나의 자연수가 주어진다.  주어지는 자연수 는 100보다 작다.  출력 첫째 줄에 최댓값을 출력하고, 둘째 줄에 최댓값이  몇 번째 수인지를 출력한다.  입력 예      출력 예 3          85 29         8 38 12 57 74  40  85  61   이 문제는 자료를 1차원 배열에 저장한 후 반복문을 이용하여 전체탐색법을 구현하면 쉽게 구할 수 있다. 전체탐색을 하더라도 탐색해야할 자료의 수가 9개뿐이므로 충분히 빠른 시간 내에 해를 구할 수 있는 기본적인 문제이다.   따라서 반복문을 구현하는 연습을 할 수 있는 문제로 이 문제를 해결하는 방법이 다른 문제들을 해결하는 도구로 많이 활용될 수 있으므로 꼭 익혀둘 수 있도록 한다.   일단 먼저 문제해결 아이디어를 생각하자. 최종적으로 출력할 해를 변수 ans로 두고, 최댓값의 인덱스를 저장할 변수를 index로 설정한다.   먼저 모든 자료를 탐색하기 전에 ans를 모든 원소들 보다 작은 값으로 설정한다. 이 문제에서는 100 이하의 자연수가 데이터의 정의역이므로, 0으로 설정하면 된다. 다음 으로 첫 번째 자료부터 마지막 자료까지 하나씩 검사해가며 현재까지 ans보다 더 큰 값이 나타나면 ans를 갱신하고, index값도 갱신한다.   마지막 자료까지 탐색을 마치면, ans와 index를 출력하면 된다. 이 과정을 입출력 예를 통해서 알아보자.            이와 같이 배열을 선형으로 전체탐색을 하면서 최댓값을 구할 수 있다. 이 방법은 가장 기본적인 방법 중 하나로 다른 알고리즘에 많이 응용되는 방법이다.   이를 프로그램으로 구현하면 다음과 같다.   #include &lt;stdio.h&gt;  #define MAXN 9 int ans, A[MAXN+1];  void solve(void) {   for(int i=1; i&lt;10; i++) {     scanf(\"%d\", A+i);     if(A[ans]&lt;A[i]) ans=i;    } } int main() {   solve();   printf(\"%d\\n%d\\n\", A[ans], ans);   return 0; }   ans, index를 하나의 변수 ans로 처리하고 있다. 그리고 9행에서 입력 받을 때 “&amp;A[i]” 대신 “A+i”를 활용하고 있다. 이러한 코딩 스타일도 자주 활용되는 방법으로 배열과 포인터를 이해하면 위와 같이 사용할 수 있음을 알 수 있다. 이와 같을 때에는 특수문자로 인한 오타의 확률도 줄일 수 있으므로 다양한 방법을 익힐 수 있도록 하자.   3의 배수 게임   3의 배수 게임을 하던 정올이는 3의 배수 게임에서 잦은 실수로  계속해서 벌칙을 받게 되었다. 3의 배수 게임의 왕이 되기 위한 마스터 프로그램을 작성해 보자.  ** 3의 배수 게임이란?  여러 사람이 순서를 정해 순서대로 수를 부르는 게임이다. 만약 3의 배수를 불러야 하는 상황이라면, 그 수 대신 \"박수\" 를 친다.  ----------------------------------------------  입력 첫 째 줄에 하나의 정수 n이 입력된다(n은 10000미만의 자연수이다.). 출력 1부터 그 수까지 순서대로 공백을 두고 수를 출력하는데,  3 또는 6 또는 9인 경우 그 수 대신 영문 대문자 X 를 출력한다.  입력 예      출력 예 7          1 2 X 4 5 X 7   이 문제도 앞선 문제와 마찬가지로 단순히 반복문을 이용하여 전체탐색법으로 해결할 수 있다. 단지 이 문제는 특정 값을 찾거나 하는 것이 아니라 전체 데이터를 읽으면서 특정 자료가 있으면 변경한다는 점은 다르나 전반적으로 같은 방법으로 해결할 수 있다. 이 문제에서 특정 자료란 입력된 숫자가 3의 배수일 경우를 말한다.   임의의 변수 n이 3의 배수인지 판정하는 가장 일반적인 방법은 다음과 같은 방법을 이용한다.   n % 3 == 0  1부터 n까지 1씩 증가하여 탐색하면서 각 수가 3의 배수인지 판정하여 3의 배수이면 “X”를 아니면 그 수를 출력하도록 작성하면 쉽게 해결할 수 있다.   이 문제를 해결한 예시는 다음과 같다.   #include &lt;stdio.h&gt;  int n; void solve(void) {   for(int i=1; i&lt;=n; i++) {     if(i%3==0) printf(\"X \");     else printf(\"%d \", i);   } } int main() {   scanf(\"%d\", &amp;n); s   solve();   return 0; }   linear structure search   n개로 이루어진 정수 집합에서 원하는 수의 위치를 찾으시오.  단, 입력되는 집합은 오름차순으로 정렬되어 있으며, 같은 수는 없다.  -------------------------------------------  입력 첫 줄에 한 정수 n이 입력된다. 둘째 줄에 n개의 정수가 공백으로 구분되어 입력된다. 셋째 줄에는 찾고자 하는 수가 입력된다. (단, 2 &lt;= n &lt;= 1,000,000, 각 원소의 크기는 100,000,000을 넘지 않는다.)  출력 찾고자 하는 원소의 위치를 출력한다. 없으면 -1을 출력한다.  입력 예                       출력 예 8                           1 2 3 5 7 9 11 15 11        7 11  3 2 5 7                       -1 3                 이 문제는 앞에서 다룬 이분탐색의 예제 프로그램을 거의 그대로 활용할 수 있는 문제이다.   이분탐색으로 풀어보자.   이분탐색 알고리즘   배열을 A라고 할 때, A[m] == k 인 경우와 A[m] &gt; k, A[m] &lt; k인 경우로 나누어 처리 하는 방법으로 문제를 해결할 수 있다.   탐색 범위를 [s, e]로 정한 다음, 이분탐색을 진행한다. (이분탐색 - 반복)      s &lt;= e를 만족할 때까지(만족하지 않으면 3번으로 간다), 가운데 위치의 값을 m( (s+e)/2 )으로 설정하고 탐색 진행.   A[m] == k인 경우, 찾았으므로 위치를 반환한다. (예제에서는 m+1)  A[m] &gt; k인 경우, 가운데 위치의 값이 찾고자 하는 값보다 크므로 탐색 범위를[s, m-1]로 하여 다시 이분탐색(1번으로 간다)  A[m] &lt; k인 경우, 가운데 위치의 값이 찾고자 하는 값보다 작으므로 탐색 범위를[m+1, e]로 하여 다시 이분탐색(1번으로 간다)   s &gt; e인 경우, 원하는 값이 없으므로 -1을 반환한다.   그림과 함께 자세한 과정을 보자.         위 방법을 소스코드로 작성하면 다음과 같다.   #include &lt;stdio.h&gt; int n, k, A[1000001];  int solve(int s, int e) {   int m;    while(s&lt;=e) {     m=(s+e)/2;      if(A[m]==k)       return m+1;      if(A[m]&lt;k) s=m+1;      else e=m‐1;   }   return ‐1; } int main() {   scanf(\"%d\",&amp;n);    for(int i=0; i&lt;n; i++ )     scanf(\"%d\", A+i);    scanf(\"%d\",&amp;k);    printf(\"%d\\n\", solve(0, n‐1));    return 0; }   위 소스코드를 다음과 같은 재귀함수로도 만들 수 있다. 재귀함수는 매우 다양한 응용이 가능하므로 이해해두면 많은 도움이 된다.   #include &lt;stdio.h&gt; int n, k, A[1000001];  int solve(int s, int e) {   if(s&gt;e)      return ‐1;   int m=(s+e)/2;    if(A[m]==k)     return m+1;    if(A[m]&lt;k)     return solve(m+1, e);    else     return solve(s, m‐1); } int main() {   scanf(\"%d\",&amp;n);    for(int i=0; i&lt;n; i++ )     scanf(\"%d\", A+i);    scanf(\"%d\",&amp;k);    printf(\"%d\\n\", solve(0, n‐1));    return 0; }   References      문제해결을 위한 창의적 알고리즘  ","categories": ["Algorithm"],
        "tags": ["이분탐색","순차탐색","Data structure","programming"],
        "url": "http://localhost:4000/algorithm/%EC%84%A0%ED%98%95%EA%B5%AC%EC%A1%B0%EC%9D%98-%ED%83%90%EC%83%89/",
        "teaser":"http://localhost:4000/assets/images/creativealgorithm43.png"},{
        "title": "Huddle landing page with alternating feature blocks",
        "excerpt":"Frontend Mentor - Huddle landing page with alternating feature blocks   7일 동안 하루에 하나씩 웹 사이트 랜딩 페이지를 만들어 봅시다.   1일차 : huddle landing page   이 프로젝트는 유튜버 Florin pop에 진행되었으며, Frontend Mentor 사이트에 있는 프로젝트들을 가지고 진행합니다.   프로젝트 따라하기   다음 링크를 따라가셔서 프로젝트에 필요한 이미지와 텍스트 그리고 가이드라인이 들어있는 파일을 다운로드 할 수 있습니다.   해당 프로젝트 기초파일   이 프로젝트는 유튜버 Florin pop에 의해서도 실시간으로 진행되었으니 같이 따라하셔도 좋습니다.   유튜브에서 이 프로젝트 같이 실습하기   결과 프로젝트 실행 방법   다음 링크의 저장소로 가시면 완성된 결과 프로젝트의 파일을 확인 하실 수 있습니다.   프로젝트 완성 파일   저장소를 클론하여, 압축을 푼 다음, index.html 파일을 실행시켜 주세요.   밑은 프로젝트의 README.md 입니다.      Welcome! 👋   Thanks for checking out this front-end coding challenge.   Frontend Mentor challenges allow you to improve your skills in a real-life workflow.   To do this challenges, you need a basic understanding of HTML and CSS.   Where to find everything   Your task is to build out the project to the designs inside the /design folder. You will find both a mobile and a desktop version of the design to work to.   The designs are in JPG static format. This will mean that you’ll need to use your best judgment for styles such as font-size, padding and margin. This should help train your eye to perceive differences in spacings and sizes.   If you would like the Sketch file in order to see sizes etc, it is available to download from the challenge page.   You will find all the required assets in the /images folder. The assets are already optimized.   There is also a style-guide.md file, which contains the information you’ll need, such as color palette and fonts.   Building your project   Feel free to use any workflow that you feel comfortable with. Below is a suggested process, but do not feel like you need to follow these steps:      Initialize your project as a public repository on GitHub. This will make it easier to share your code with the community if you need some help. If you’re not sure how to do this, have a read through of this Try Git resource.   Configure your repository to publish your code to a URL. This will also be useful if you need some help during a challenge as you can share the URL for your project with your repo URL. There are a number of ways to do this, but we recommend using ZEIT Now. We’ve got more information about deploying your project with ZEIT below.   Look through the designs to start planning out how you’ll tackle the project. This step is crucial to help you think ahead for CSS classes that you could create to make reusable styles.   Before adding any styles, structure your content with HTML. Writing your HTML first can help focus your attention on creating well-structured content.   Write out the base styles for your project, including general content styles, such as font-family and font-size.   Start adding styles to the top of the page and work down. Only move on to the next section once you’re happy you’ve completed the area you’re working on.   If you’d like to try making your project fully responsive, we’d recommend checking out Sizzy. It’s a great browser that makes it easy to view your site across multiple devices.   Deploying your project   As mentioned above, there are a number of ways to host your project for free. We recommend using ZEIT Now as it’s an amazing service and extremely simple to get set up with. If you’d like to use ZEIT, here are some steps to follow to get started:      Sign up to ZEIT Now and go through the onboarding flow, ensuring your GitHub account is connected by using their ZEIT Now for GitHub integration.   Connect your project to ZEIT Now from the “Create a new project” page, using the “New Project From GitHub” button and selecting the project you want to deploy.   Once connected, every time you git push, ZEIT Now will create a new deployment and the deployment URL will be shown on your ZEIT Dashboard. You will also receive an email for each deployment with the URL.   Sharing your solution   There are multiple places you can share your solution:      Submit it on the platform so that other users will see your solution on the site. Other users will be able to give you feedback, which could help improve your code for the next project.   Share your repository and live URL in the #finished-projects channel of the Slack community.   Tweet @frontendmentor and mention @frontendmentor including the repo and live URLs in the tweet. We’d love to take a look at what you’ve built and help share it around.   Giving feedback   Feedback is always welcome, so if you have any to give on this challenge please email hi[at]frontendmentor[dot]io.   This challenge is completely free. Please share it with anyone who will find it useful for practice.   Have fun building! 🚀  ","categories": ["Development"],
        "tags": ["HTML","CSS","Web"],
        "url": "http://localhost:4000/development/Huddle-landing-page/",
        "teaser":null},{
        "title": "이진 탐색 트리-예정포스트",
        "excerpt":" ","categories": ["Data Structure"],
        "tags": ["programming","Data Structure","Tree"],
        "url": "http://localhost:4000/data%20structure/binary-search-tree/",
        "teaser":"http://localhost:4000/assets/images/tree1.png"},{
        "title": "Fylo landing page dark theme",
        "excerpt":"Frontend Mentor - Fylo landing page dark theme   7일 동안 하루에 하나씩 웹 사이트 랜딩 페이지를 만들어 봅시다.   5일차 : Fylo landing page dark theme   이 프로젝트는 Frontend Mentor 사이트에 있는 프로젝트들을 가지고 진행합니다.   프로젝트 따라하기   다음 링크를 따라가셔서 프로젝트에 필요한 이미지와 텍스트 그리고 가이드라인이 들어있는 파일을 다운로드 할 수 있습니다.   해당 프로젝트 기초파일   결과 프로젝트 실행 방법   다음 링크의 저장소로 가시면 완성된 결과 프로젝트의 파일을 확인 하실 수 있습니다.   프로젝트 완성 파일   저장소를 클론하여, 압축을 푼 다음, index.html 파일을 실행시켜 주세요.   밑은 프로젝트의 README.md 입니다.      Welcome! 👋   Thanks for checking out this front-end coding challenge.   Frontend Mentor challenges allow you to improve your skills in a real-life workflow.   To do this challenges, you need a basic understanding of HTML and CSS.   Where to find everything   Your task is to build out the project to the designs inside the /design folder. You will find both a mobile and a desktop version of the design to work to.   The designs are in JPG static format. This will mean that you’ll need to use your best judgment for styles such as font-size, padding and margin. This should help train your eye to perceive differences in spacings and sizes.   If you would like the Sketch file in order to see sizes etc, it is available to download from the challenge page.   You will find all the required assets in the /images folder. The assets are already optimized.   There is also a style-guide.md file, which contains the information you’ll need, such as color palette and fonts.   Building your project   Feel free to use any workflow that you feel comfortable with. Below is a suggested process, but do not feel like you need to follow these steps:      Initialize your project as a public repository on GitHub. This will make it easier to share your code with the community if you need some help. If you’re not sure how to do this, have a read through of this Try Git resource.   Configure your repository to publish your code to a URL. This will also be useful if you need some help during a challenge as you can share the URL for your project with your repo URL. There are a number of ways to do this, but we recommend using ZEIT Now. We’ve got more information about deploying your project with ZEIT below.   Look through the designs to start planning out how you’ll tackle the project. This step is crucial to help you think ahead for CSS classes that you could create to make reusable styles.   Before adding any styles, structure your content with HTML. Writing your HTML first can help focus your attention on creating well-structured content.   Write out the base styles for your project, including general content styles, such as font-family and font-size.   Start adding styles to the top of the page and work down. Only move on to the next section once you’re happy you’ve completed the area you’re working on.   If you’d like to try making your project fully responsive, we’d recommend checking out Sizzy. It’s a great browser that makes it easy to view your site across multiple devices.   Deploying your project   As mentioned above, there are a number of ways to host your project for free. We recommend using ZEIT Now as it’s an amazing service and extremely simple to get set up with. If you’d like to use ZEIT, here are some steps to follow to get started:      Sign up to ZEIT Now and go through the onboarding flow, ensuring your GitHub account is connected by using their ZEIT Now for GitHub integration.   Connect your project to ZEIT Now from the “Create a new project” page, using the “New Project From GitHub” button and selecting the project you want to deploy.   Once connected, every time you git push, ZEIT Now will create a new deployment and the deployment URL will be shown on your ZEIT Dashboard. You will also receive an email for each deployment with the URL.   Sharing your solution   There are multiple places you can share your solution:      Submit it on the platform so that other users will see your solution on the site. Other users will be able to give you feedback, which could help improve your code for the next project.   Share your repository and live URL in the #finished-projects channel of the Slack community.   Tweet @frontendmentor and mention @frontendmentor including the repo and live URLs in the tweet. We’d love to take a look at what you’ve built and help share it around.   Giving feedback   Feedback is always welcome, so if you have any to give on this challenge please email hi[at]frontendmentor[dot]io.   This challenge is completely free. Please share it with anyone who will find it useful for practice.   Have fun building! 🚀  ","categories": ["Development"],
        "tags": ["HTML","CSS","Web"],
        "url": "http://localhost:4000/development/Fylo-landing-page-dark/",
        "teaser":null},{
        "title": "Fylo landing page with two column layout",
        "excerpt":"Frontend Mentor - Fylo landing page with two column layout   7일 동안 하루에 하나씩 웹 사이트 랜딩 페이지를 만들어 봅시다.   4일차 : Fylo landing page with two column layout   이 프로젝트는 유튜버 Florin pop에 진행되었으며, Frontend Mentor 사이트에 있는 프로젝트들을 가지고 진행합니다.   프로젝트 따라하기   다음 링크를 따라가셔서 프로젝트에 필요한 이미지와 텍스트 그리고 가이드라인이 들어있는 파일을 다운로드 할 수 있습니다.   해당 프로젝트 기초파일   이 프로젝트는 유튜버 Florin pop에 의해서도 실시간으로 진행되었으니 같이 따라하셔도 좋습니다.   유튜브에서 이 프로젝트 같이 실습하기   결과 프로젝트 실행 방법   다음 링크의 저장소로 가시면 완성된 결과 프로젝트의 파일을 확인 하실 수 있습니다.   프로젝트 완성 파일   저장소를 클론하여, 압축을 푼 다음, index.html 파일을 실행시켜 주세요.   밑은 프로젝트의 README.md 입니다.      Welcome! 👋   Thanks for checking out this front-end coding challenge.   Frontend Mentor challenges allow you to improve your skills in a real-life workflow.   To do this challenges, you need a basic understanding of HTML and CSS.   Where to find everything   Your task is to build out the project to the designs inside the /design folder. You will find both a mobile and a desktop version of the design to work to.   The designs are in JPG static format. This will mean that you’ll need to use your best judgment for styles such as font-size, padding and margin. This should help train your eye to perceive differences in spacings and sizes.   If you would like the Sketch file in order to see sizes etc, it is available to download from the challenge page.   You will find all the required assets in the /images folder. The assets are already optimized.   There is also a style-guide.md file, which contains the information you’ll need, such as color palette and fonts.   Building your project   Feel free to use any workflow that you feel comfortable with. Below is a suggested process, but do not feel like you need to follow these steps:      Initialize your project as a public repository on GitHub. This will make it easier to share your code with the community if you need some help. If you’re not sure how to do this, have a read through of this Try Git resource.   Configure your repository to publish your code to a URL. This will also be useful if you need some help during a challenge as you can share the URL for your project with your repo URL. There are a number of ways to do this, but we recommend using ZEIT Now. We’ve got more information about deploying your project with ZEIT below.   Look through the designs to start planning out how you’ll tackle the project. This step is crucial to help you think ahead for CSS classes that you could create to make reusable styles.   Before adding any styles, structure your content with HTML. Writing your HTML first can help focus your attention on creating well-structured content.   Write out the base styles for your project, including general content styles, such as font-family and font-size.   Start adding styles to the top of the page and work down. Only move on to the next section once you’re happy you’ve completed the area you’re working on.   If you’d like to try making your project fully responsive, we’d recommend checking out Sizzy. It’s a great browser that makes it easy to view your site across multiple devices.   Deploying your project   As mentioned above, there are a number of ways to host your project for free. We recommend using ZEIT Now as it’s an amazing service and extremely simple to get set up with. If you’d like to use ZEIT, here are some steps to follow to get started:      Sign up to ZEIT Now and go through the onboarding flow, ensuring your GitHub account is connected by using their ZEIT Now for GitHub integration.   Connect your project to ZEIT Now from the “Create a new project” page, using the “New Project From GitHub” button and selecting the project you want to deploy.   Once connected, every time you git push, ZEIT Now will create a new deployment and the deployment URL will be shown on your ZEIT Dashboard. You will also receive an email for each deployment with the URL.   Sharing your solution   There are multiple places you can share your solution:      Submit it on the platform so that other users will see your solution on the site. Other users will be able to give you feedback, which could help improve your code for the next project.   Share your repository and live URL in the #finished-projects channel of the Slack community.   Tweet @frontendmentor and mention @frontendmentor including the repo and live URLs in the tweet. We’d love to take a look at what you’ve built and help share it around.   Giving feedback   Feedback is always welcome, so if you have any to give on this challenge please email hi[at]frontendmentor[dot]io.   This challenge is completely free. Please share it with anyone who will find it useful for practice.   Have fun building! 🚀  ","categories": ["Development"],
        "tags": ["HTML","CSS","Web"],
        "url": "http://localhost:4000/development/Fylo-landing-page/",
        "teaser":null},{
        "title": "Insure landing page",
        "excerpt":"Frontend Mentor - Insure landing page   7일 동안 하루에 하나씩 웹 사이트 랜딩 페이지를 만들어 봅시다.   2일차 : Insure landing page   이 프로젝트는 유튜버 Florin pop에 진행되었으며, Frontend Mentor 사이트에 있는 프로젝트들을 가지고 진행합니다.   프로젝트 따라하기   다음 링크를 따라가셔서 프로젝트에 필요한 이미지와 텍스트 그리고 가이드라인이 들어있는 파일을 다운로드 할 수 있습니다.   해당 프로젝트 기초파일   이 프로젝트는 유튜버 Florin pop에 의해서도 실시간으로 진행되었으니 같이 따라하셔도 좋습니다.   유튜브에서 이 프로젝트 같이 실습하기   결과 프로젝트 실행 방법   다음 링크의 저장소로 가시면 완성된 결과 프로젝트의 파일을 확인 하실 수 있습니다.   프로젝트 완성 파일   저장소를 클론하여, 압축을 푼 다음, index.html 파일을 실행시켜 주세요.   밑은 프로젝트의 README.md 입니다.      Welcome! 👋   Thanks for checking out this front-end coding challenge.   Frontend Mentor challenges allow you to improve your skills in a real-life workflow.   To do this challenges, you need a basic understanding of HTML and CSS.   Where to find everything   Your task is to build out the project to the designs inside the /design folder. You will find both a mobile and a desktop version of the design to work to.   The designs are in JPG static format. This will mean that you’ll need to use your best judgment for styles such as font-size, padding and margin. This should help train your eye to perceive differences in spacings and sizes.   If you would like the Sketch file in order to see sizes etc, it is available to download from the challenge page.   You will find all the required assets in the /images folder. The assets are already optimized.   There is also a style-guide.md file, which contains the information you’ll need, such as color palette and fonts.   Building your project   Feel free to use any workflow that you feel comfortable with. Below is a suggested process, but do not feel like you need to follow these steps:      Initialize your project as a public repository on GitHub. This will make it easier to share your code with the community if you need some help. If you’re not sure how to do this, have a read through of this Try Git resource.   Configure your repository to publish your code to a URL. This will also be useful if you need some help during a challenge as you can share the URL for your project with your repo URL. There are a number of ways to do this, but we recommend using ZEIT Now. We’ve got more information about deploying your project with ZEIT below.   Look through the designs to start planning out how you’ll tackle the project. This step is crucial to help you think ahead for CSS classes that you could create to make reusable styles.   Before adding any styles, structure your content with HTML. Writing your HTML first can help focus your attention on creating well-structured content.   Write out the base styles for your project, including general content styles, such as font-family and font-size.   Start adding styles to the top of the page and work down. Only move on to the next section once you’re happy you’ve completed the area you’re working on.   If you’d like to try making your project fully responsive, we’d recommend checking out Sizzy. It’s a great browser that makes it easy to view your site across multiple devices.   Deploying your project   As mentioned above, there are a number of ways to host your project for free. We recommend using ZEIT Now as it’s an amazing service and extremely simple to get set up with. If you’d like to use ZEIT, here are some steps to follow to get started:      Sign up to ZEIT Now and go through the onboarding flow, ensuring your GitHub account is connected by using their ZEIT Now for GitHub integration.   Connect your project to ZEIT Now from the “Create a new project” page, using the “New Project From GitHub” button and selecting the project you want to deploy.   Once connected, every time you git push, ZEIT Now will create a new deployment and the deployment URL will be shown on your ZEIT Dashboard. You will also receive an email for each deployment with the URL.   Sharing your solution   There are multiple places you can share your solution:      Submit it on the platform so that other users will see your solution on the site. Other users will be able to give you feedback, which could help improve your code for the next project.   Share your repository and live URL in the #finished-projects channel of the Slack community.   Tweet @frontendmentor and mention @frontendmentor including the repo and live URLs in the tweet. We’d love to take a look at what you’ve built and help share it around.   Giving feedback   Feedback is always welcome, so if you have any to give on this challenge please email hi[at]frontendmentor[dot]io.   This challenge is completely free. Please share it with anyone who will find it useful for practice.   Have fun building! 🚀  ","categories": ["Development"],
        "tags": ["HTML","CSS","Web"],
        "url": "http://localhost:4000/development/Insure-landing-page/",
        "teaser":null},{
        "title": "Clipboard landing page",
        "excerpt":"Frontend Mentor - Clipboard landing page   7일 동안 하루에 하나씩 웹 사이트 랜딩 페이지를 만들어 봅시다.   3일차 : Clipboard landing page   이 프로젝트는 유튜버 Florin pop에 진행되었으며, Frontend Mentor 사이트에 있는 프로젝트들을 가지고 진행합니다.   프로젝트 따라하기   다음 링크를 따라가셔서 프로젝트에 필요한 이미지와 텍스트 그리고 가이드라인이 들어있는 파일을 다운로드 할 수 있습니다.   해당 프로젝트 기초파일   이 프로젝트는 유튜버 Florin pop에 의해서도 실시간으로 진행되었으니 같이 따라하셔도 좋습니다.   유튜브에서 이 프로젝트 같이 실습하기   결과 프로젝트 실행 방법   다음 링크의 저장소로 가시면 완성된 결과 프로젝트의 파일을 확인 하실 수 있습니다.   프로젝트 완성 파일   저장소를 클론하여, 압축을 푼 다음, index.html 파일을 실행시켜 주세요.   밑은 프로젝트의 README.md 입니다.      Welcome! 👋   Thanks for checking out this front-end coding challenge.   Frontend Mentor challenges allow you to improve your skills in a real-life workflow.   To do this challenges, you need a basic understanding of HTML and CSS.   Where to find everything   Your task is to build out the project to the designs inside the /design folder. You will find both a mobile and a desktop version of the design to work to.   The designs are in JPG static format. This will mean that you’ll need to use your best judgment for styles such as font-size, padding and margin. This should help train your eye to perceive differences in spacings and sizes.   If you would like the Sketch file in order to see sizes etc, it is available to download from the challenge page.   You will find all the required assets in the /images folder. The assets are already optimized.   There is also a style-guide.md file, which contains the information you’ll need, such as color palette and fonts.   Building your project   Feel free to use any workflow that you feel comfortable with. Below is a suggested process, but do not feel like you need to follow these steps:      Initialize your project as a public repository on GitHub. This will make it easier to share your code with the community if you need some help. If you’re not sure how to do this, have a read through of this Try Git resource.   Configure your repository to publish your code to a URL. This will also be useful if you need some help during a challenge as you can share the URL for your project with your repo URL. There are a number of ways to do this, but we recommend using ZEIT Now. We’ve got more information about deploying your project with ZEIT below.   Look through the designs to start planning out how you’ll tackle the project. This step is crucial to help you think ahead for CSS classes that you could create to make reusable styles.   Before adding any styles, structure your content with HTML. Writing your HTML first can help focus your attention on creating well-structured content.   Write out the base styles for your project, including general content styles, such as font-family and font-size.   Start adding styles to the top of the page and work down. Only move on to the next section once you’re happy you’ve completed the area you’re working on.   If you’d like to try making your project fully responsive, we’d recommend checking out Sizzy. It’s a great browser that makes it easy to view your site across multiple devices.   Deploying your project   As mentioned above, there are a number of ways to host your project for free. We recommend using ZEIT Now as it’s an amazing service and extremely simple to get set up with. If you’d like to use ZEIT, here are some steps to follow to get started:      Sign up to ZEIT Now and go through the onboarding flow, ensuring your GitHub account is connected by using their ZEIT Now for GitHub integration.   Connect your project to ZEIT Now from the “Create a new project” page, using the “New Project From GitHub” button and selecting the project you want to deploy.   Once connected, every time you git push, ZEIT Now will create a new deployment and the deployment URL will be shown on your ZEIT Dashboard. You will also receive an email for each deployment with the URL.   Sharing your solution   There are multiple places you can share your solution:      Submit it on the platform so that other users will see your solution on the site. Other users will be able to give you feedback, which could help improve your code for the next project.   Share your repository and live URL in the #finished-projects channel of the Slack community.   Tweet @frontendmentor and mention @frontendmentor including the repo and live URLs in the tweet. We’d love to take a look at what you’ve built and help share it around.   Giving feedback   Feedback is always welcome, so if you have any to give on this challenge please email hi[at]frontendmentor[dot]io.   This challenge is completely free. Please share it with anyone who will find it useful for practice.   Have fun building! 🚀  ","categories": ["Development"],
        "tags": ["HTML","CSS","Web"],
        "url": "http://localhost:4000/development/Clipboard-landing-page/",
        "teaser":null},{
        "title": "트리(Tree)",
        "excerpt":"트리(Tree)   트리는 부모와 자식간의 관계가 계층적으로 구성되는 자료구조이다.  하나의 노드가 여러개의 자식들을, 다시 자식들은 다른 자식들을 가질 수 있는 구조이다.   다음 그림은 전형적인 트리를 보여준다.      트리 용어  트리에 쓰이는 용어들을 알아보자.   루트(Root)  트리의 계층적 구조상 가장 위에 위치한 노드를 지칭한다.  위의 그림에서 A가 루트이다.   루트는 유일하게 부모 노드가 없는 노드이다.   리프 노드(Reaf Node)  아무런 자식도 가지지 않는 노드를 리프 노드라고 한다.  위의 그림에서 E, F, C, G, H가 리프 노드이다.   조상 노드(Ancestor)  특정 노드에서 루트로의 선행자가 이에 해당한다.  노드 F의 조상 노드는 B, A가 된다.   형제 노드(Sibling)  같은 부모를 가지는 노드들을 형제 노드라고 한다.  위의 그림에서 B, C, D가 형제 노드이다.   서브 트리(Sub Tree)  위의 그림에서 A가 null이 아니면, 그 밑의 자식 트리 T1, T2, T3를 노드 A의 서브 트리라고 한다.   레벨(Level)  트리는 계층적 구조로서 레벨을 가지고 있다.  루트는 0레벨이며, 밑 자식으로 갈수록 레벨이 1씩 커진다.   이진 트리   한 노드가 최대 2개의 자식 노드를 가질 수 있는 트리를 이진 트리라고 한다.  한 노드의 왼쪽에 오는 자식을 왼쪽 자식 노드, 오른쪽에 오는 자식을 오른쪽 자식 노드라고 부른다.   다음은 전형적인 이진 트리를 나타내는 그림이다.      이진 트리의 종류   이진 트리를 구성하는 노드의 형태에 따라 다음과 같이 분류된다.   Full Binary Tree   모든 노드가 자식을 0개 혹은 2개 가진 트리를 일컽는다.   다음은 전부 Full Binary Tree이다.            18        /    \\         15      30        /  \\     /  \\    40   50  100   40              18            /    \\             15     20             /  \\              40    50        /   \\    30   50            18          /   \\           40   30               /  \\           100   40   Full Binary Tree에서 리프노드의 수는 내부노드의 수 + 1 이다.   Complete Binary Tree   트리의 마지막 레벨을 제외한 모든 레벨에서 노드가 자식을 두개 가지고 있고, 마지막 레벨에서는 왼쪽 부터 자식이 빠짐없이 차 있는 트리를 일컽는다.   다음은 전부 Complete Binary Tree 이다.                18            /    \\            15      30           /  \\    /  \\       40   50 100   40                18            /    \\            15      30           /  \\    /  \\       40   50  100 40      / \\   /     8  7  9    Binary Heap은 Complete Binary 트리이다.   Perfect Binary Tree   리프노드를 제외한 모든 내부노드가 자식 노드를 2개 가지고, 모든 리프노드가 동일 레벨 선상에 있는 트리를 일컽는다.   다음은 전부 Perfect Binary Tree 이다.                 18            /       \\  --- 높이 h: 3          15         30         /  \\        /  \\       40    50    100   40                18            /    \\  -- 높이 h: 2          15     30    Perfect Binary Tree의 높이가 h일 때 $2^h-1$개의 노드를 가진다.  (높이 h: 루트로부터 리프노드 까지의 경로에 있는 노드의 수)   Degenerate (or pathological) tree   트리의 내부노드가 오직 하나의 자식만을 갖는 트리를 일컽는다.   다음은 Degenerate tree 이다.       10     /    20     \\      30        \\        40       연결 리스트와 성능면에서 동일하다.   이진 트리 표현   이진 트리를 어떻게 표현하고 구현할 수 있을지 알아본다.   이진 트리 클래스는 최상위 노드를 가리키는 root 레퍼런스를 갖고 있다.   class BinaryTree  {      // Root of Binary Tree      Node root;         // Constructors      BinaryTree(int key)      {          root = new Node(key);      }         BinaryTree()      {          root = null;      }  }   또한 이진 트리 클래스는 각 노드를 표현할 노드 클래스를 가지고 있다.   class Node  {      int key;      Node left, right;         public Node(int item)      {          key = item;          left = right = null;      }  }    노드는 다음과 같은 부분으로 구성된다.      Data - 데이터를 저장하는 필드   왼쪽 자식에 대한 레퍼런스   오른쪽 자식에 대한 레퍼런스   트리 예제 코드   위의 표현들을 이용하여 트리를 만들어보고 이해해보자.   먼저 전체 코드이다.   /* Class containing left and right child of current     node and key value*/    // A Java program to introduce Binary Tree  class BinaryTree  {      // Root of Binary Tree      Node root;         // Constructors      BinaryTree(int key)      {          root = new Node(key);      }         BinaryTree()      {          root = null;      }       static class Node      {          int key;          Node left, right;             public Node(int item)          {          key = item;          left = right = null;          }      }         public static void main(String[] args)      {          BinaryTree tree = new BinaryTree();             /*create root*/         tree.root = new Node(1);             tree.root.left = new Node(2);          tree.root.right = new Node(3);          tree.root.left.left = new Node(4);      }  }    BinaryTree tree = new BinaryTree();    이진 트리를 생성하는 구문이다.  아직은 아무런 노드가 없으므로 root 레퍼런스는 null이다.    tree.root = new Node(1);  노드를 할당하여 1을 넣고, 트리의 root 레퍼런스가 할당된 노드를 가리키게 한다.   그림으로 표현하면 다음처럼 도식화 된다.                 1              /   \\            null  null    1번 노드는 루트가 되었다.  1번 노드의 왼쪽, 오른쪽 자식노드는 없으므로 left, right 레퍼런스는 null이다.   그 다음을 보자.   tree.root.left = new Node(2);  tree.root.right = new Node(3);   노드를 할당하여 2를 넣고, 트리의 root 왼쪽 자식 레퍼런스가 할당된 노드를 가리키게 한다. 노드를 할당하여 3을 넣고, 트리의 root 오른쪽 자식 레퍼런스가 할당된 노드를 가리키게 한다. 2, 3번 노드는 아직 자식들이 없으므로 left, right 레퍼런스는 null이다.   그림으로 표현하면 다음과 같다.                   1               /    \\              2       3            /   \\    /  \\          null null null null   계속해서 그 다음을 보자.   tree.root.left.left = new Node(4);   노드를 할당하여 4를 넣고, root의 왼쪽 노드의 왼쪽 자식 레퍼런스가 할당된 노드를 가리키게 한다.   그림으로 표현하면 다음과 같다.                       1                  /       \\                 2          3               /   \\       /  \\              4    null  null  null             /   \\            null null    4번 노드는 2번 노드의 자식이 되었다.   References  GeeksforGeeks  ","categories": ["Data Structure"],
        "tags": ["programming","Data Structure","Linked List","Tree"],
        "url": "http://localhost:4000/data%20structure/Tree/",
        "teaser":null},{
        "title": "Base Apparel coming soon page",
        "excerpt":"Frontend Mentor - Base Apparel coming soon page   7일 동안 하루에 하나씩 웹 사이트 랜딩 페이지를 만들어 봅시다.   7일차 : Base Apparel coming soon page   이 프로젝트는 유튜버 Florin pop에 진행되었으며, Frontend Mentor 사이트에 있는 프로젝트들을 가지고 진행합니다.   프로젝트 따라하기   다음 링크를 따라가셔서 프로젝트에 필요한 이미지와 텍스트 그리고 가이드라인이 들어있는 파일을 다운로드 할 수 있습니다.   해당 프로젝트 기초파일   이 프로젝트는 유튜버 Florin pop에 의해서도 실시간으로 진행되었으니 같이 따라하셔도 좋습니다.   유튜브에서 이 프로젝트 같이 실습하기   결과 프로젝트 실행 방법   다음 링크의 저장소로 가시면 완성된 결과 프로젝트의 파일을 확인 하실 수 있습니다.   프로젝트 완성 파일   저장소를 클론하여, 압축을 푼 다음, index.html 파일을 실행시켜 주세요.      Welcome! 👋   Thanks for checking out this front-end coding challenge.   Frontend Mentor challenges allow you to improve your skills in a real-life workflow.   To do this challenges, you need a basic understanding of HTML and CSS.   Where to find everything   Your task is to build out the project to the designs inside the /design folder. You will find both a mobile and a desktop version of the design to work to.   The designs are in JPG static format. This will mean that you’ll need to use your best judgment for styles such as font-size, padding and margin. This should help train your eye to perceive differences in spacings and sizes.   If you would like the Sketch file in order to see sizes etc, it is available to download from the challenge page.   You will find all the required assets in the /images folder. The assets are already optimized.   There is also a style-guide.md file, which contains the information you’ll need, such as color palette and fonts.   Building your project   Feel free to use any workflow that you feel comfortable with. Below is a suggested process, but do not feel like you need to follow these steps:      Initialize your project as a public repository on GitHub. This will make it easier to share your code with the community if you need some help. If you’re not sure how to do this, have a read through of this Try Git resource.   Configure your repository to publish your code to a URL. This will also be useful if you need some help during a challenge as you can share the URL for your project with your repo URL. There are a number of ways to do this, but we recommend using ZEIT Now. We’ve got more information about deploying your project with ZEIT below.   Look through the designs to start planning out how you’ll tackle the project. This step is crucial to help you think ahead for CSS classes that you could create to make reusable styles.   Before adding any styles, structure your content with HTML. Writing your HTML first can help focus your attention on creating well-structured content.   Write out the base styles for your project, including general content styles, such as font-family and font-size.   Start adding styles to the top of the page and work down. Only move on to the next section once you’re happy you’ve completed the area you’re working on.   If you’d like to try making your project fully responsive, we’d recommend checking out Sizzy. It’s a great browser that makes it easy to view your site across multiple devices.   Deploying your project   As mentioned above, there are a number of ways to host your project for free. We recommend using ZEIT Now as it’s an amazing service and extremely simple to get set up with. If you’d like to use ZEIT, here are some steps to follow to get started:      Sign up to ZEIT Now and go through the onboarding flow, ensuring your GitHub account is connected by using their ZEIT Now for GitHub integration.   Connect your project to ZEIT Now from the “Create a new project” page, using the “New Project From GitHub” button and selecting the project you want to deploy.   Once connected, every time you git push, ZEIT Now will create a new deployment and the deployment URL will be shown on your ZEIT Dashboard. You will also receive an email for each deployment with the URL.   Sharing your solution   There are multiple places you can share your solution:      Submit it on the platform so that other users will see your solution on the site. Other users will be able to give you feedback, which could help improve your code for the next project.   Share your repository and live URL in the #finished-projects channel of the Slack community.   Tweet @frontendmentor and mention @frontendmentor including the repo and live URLs in the tweet. We’d love to take a look at what you’ve built and help share it around.   Giving feedback   Feedback is always welcome, so if you have any to give on this challenge please email hi[at]frontendmentor[dot]io.   This challenge is completely free. Please share it with anyone who will find it useful for practice.   Have fun building! 🚀  ","categories": ["Development"],
        "tags": ["HTML","CSS","Web"],
        "url": "http://localhost:4000/development/Base-Apparel-coming-soon-page/",
        "teaser":null},{
        "title": "트리의 순회(Tree Traversal)",
        "excerpt":"트리의 순회(Tree Traversal)   트리를 순회하는데 여러가지 방법이 있지만 이번 포스트에서는 그 중 깊이우선탐색(DFS)의 성질을 가진 3가지 순회 방법을 알아본다.   다음은 트리를 순회하는 대표적인 3가지 방법이다. (깊이우선탐색(DFS))      Inorder - 중위 순회   Preorder - 전위 순회   Postorder - 후위 순회   3가지 순회들은 다음의 공통된 패턴을 가지고 있다.   (L) 현재 노드의 왼쪽 서브트리를 재귀적으로 순회한다.  (R) 현재 노드의 오른쪽 서브트리를 재귀적으로 순회한다.  (N) 현재 노드를 방문한다.   모든 노드에 대해서, 이 패턴들이 실행되는 순서에 따라 3가지 순회 방법이 결정되게 된다.   여기서 ‘재귀적으로’라는 말은 작업이 다른 서브루틴으로 분기된다는 뜻이다.  서브루틴에서의 작업이 끝나게 되면 다시 현재의 작업으로 백트랙하게 된다.   Inorder - 중위 순회   트리의 중위 순회를 위해서 루트 노드 부터 모든 노드에 대해 다음의 작업을 수행한다.   중위 순회(LNR)  현재 노드가 null인지 확인한다.   아니라면 다음의 순서대로 순회를 한다.    (L) 현재 노드의 왼쪽 서브트리를 재귀적으로 순회한다.   (N) 현재 노드를 방문한다.   (R) 현재 노드의 오른쪽 서브트리를 재귀적으로 순회한다.    다음의 그림은 Inorder의 예를 보여준다.      위의 그림에서 볼 수 있듯이, 어떤 노드가 처리되기 전에 왼쪽 서브트리가 먼저 처리되고(L) 그 다음 해당 노드가 처리되고(N) 그 다음 오른쪽 서브트리 처리된다(R).   모든 노드에 대해서 (L), (R) 연산들은 재귀적으로 수행이 된다.   다음은 위를 구현한 자바 코드이다.   // Recursive function to perform in-order traversal of the tree public static void inorder(TreeNode root) { \t// 현재 노드가 null이면 리턴 \tif (root == null) { \t\treturn; \t}  \t// 재귀적으로 왼쪽 서브트리를 탐색한다. \tinorder(root.left);  \t// 현재 노드의 데이터를 출력한다. (방문) \tSystem.out.print(root.data + \" \");  \t// 재귀적으로 오른쪽 서브트리를 탐색한다. \tinorder(root.right); }   Preorder - 전위 순회   트리의 전위 순회를 위해서 루트 노드 부터 모든 노드에 대해 다음의 작업을 수행한다.   전위 순회(NLR)  현재 노드가 null인지 확인한다.   아니라면 다음의 순서대로 순회를 한다.    (N) 현재 노드를 방문한다.   (L) 현재 노드의 왼쪽 서브트리를 재귀적으로 순회한다.   (R) 현재 노드의 오른쪽 서브트리를 재귀적으로 순회한다.    다음의 그림은 Preorder의 예를 보여준다.      위의 그림에서 볼 수 있듯이, 해당 노드가 처리되고(N) 그 다음 왼쪽 서브트리가 처리되고(L) 마지막으로 오른쪽 서브트리가 처리된다(R).   모든 노드에 대해서 (L), (R) 연산들은 재귀적으로 수행이 된다.   다음은 위를 구현한 자바 코드이다.   // Recursive function to perform pre-order traversal of the tree public static void preorder(TreeNode root) { \t// return if the current node is empty \tif (root == null) { \t\treturn; \t} \t// 현재 노드의 데이터를 출력한다. (방문) \tSystem.out.print(root.data + \" \");  \t// 재귀적으로 왼쪽 서브트리를 탐색한다. \tpreorder(root.left);  \t// 재귀적으로 오른쪽 서브트리를 탐색한다. \tpreorder(root.right); }   Postorder - 후위 순회   트리의 후위 순회를 위해서 루트 노드 부터 모든 노드에 대해 다음의 작업을 수행한다.   후위 순회(LRN)  현재 노드가 null인지 확인한다.   아니라면 다음의 순서대로 순회를 한다.    (L) 현재 노드의 왼쪽 서브트리를 재귀적으로 순회한다.   (R) 현재 노드의 오른쪽 서브트리를 재귀적으로 순회한다.   (N) 현재 노드를 방문한다.    다음의 그림은 Postorder의 예를 보여준다.      위의 그림에서 볼 수 있듯이, 해당 노드가 처리되기 전에 왼쪽 서브트리가 먼저 처리되고(L) 그 다음 오른쪽 서브트리 처리되고(R) 마지막으로 해당 노드가 처리된다(N).   모든 노드에 대해서 (L), (R) 연산들은 재귀적으로 수행이 된다.   다음은 위를 구현한 자바 코드이다.   // Recursive function to perform post-order traversal of the tree public static void postorder(TreeNode root) { \t// return if the current node is empty \tif (root == null) { \t\treturn; \t}  \t// 재귀적으로 왼쪽 서브트리를 탐색한다. \tpostorder(root.left);  \t// 재귀적으로 오른쪽 서브트리를 탐색한다. \tpostorder(root.right);    // 현재 노드의 데이터를 출력한다. (방문) \tSystem.out.print(root.data + \" \"); }   References  GeeksforGeeks  ","categories": ["Algorithm"],
        "tags": ["programming","Traversal","DFS","Tree"],
        "url": "http://localhost:4000/algorithm/treeTraversal/",
        "teaser":null},{
        "title": "그래프(Graph)",
        "excerpt":"Graph  정점들과 간선들로 이루어진 집합이다.   V: Vertex, E: Edge, G: Graph  그래프 G는 (V, E)의 집합으로 정의 될 수 있다. =&gt; G = (V, E)  V(G)는 정점의 집합 그리고 E(G)는 두 정점들의 연결을 나타내는 간선의 집합이다.   Info: 그래프는 트리를 포함하는 개념이고, 트리는 사이클을 포함하지 않는 그래프라고 볼 수 있다.  그래서 모든 트리는 그래프이지만, 모든 그래프는 트리가 아니다.   Undirected and Directed Graph   그래프는 방향 그래프 또는 비방향 그래프가 될 수 있다.   비방향 그래프는 두 정점 간의 간선에 방향이 없다.  A - B의 비방향 간선이 있다면, 이것은 A -&gt; B로, B -&gt; A로의 탐색이 가능하다는 것을 의미한다.   방향 그래프는 두 정점 간의 간선에 방향을 가지고 있다.  A -&gt; B의 방향 간선이 있다면, 이것은 A -&gt; B로의 탐색이 가능, 그러나 B -&gt; A로의 탐색이 가능하지 않다는 것을 의미     Unweighted and weighted Graph   두 정점 간의 간선에 추가 정보가 없다면 Unweighted(비가중치) 그래프.  두 정점 간의 간선에 추가 정보가 있다면 weighted(가중치) 그래프.      Representation  그래프를 표현하는 2가지 방법을 알아본다.  인접 행렬(Adjacency matrix)   2차원 행렬로 표현하는 방법.  행은 출발 정점을 나타내고 열을 도착 정점을 나타낸다. 꼭짓점 x에서 꼭짓점 y로 변이 존재하면 행렬 성분 x행 y열의 값은 1이고 그렇지 않으면 0이다.      Note: 그래프가 100개의 정점과 1개의 간선으로 이루어져 있어도, 인접행렬 표현 시 100x100 크기의 매트릭스를 써야한다. 즉, 비교적 적은 간선의 그래프를 표현하는데에는 불필요한 공간이 많이 소비된다.   인접 리스트(Adjacency list)  인접 리스트를 이용하여 그래프를 표현하는 방법  이 표현에서는, 각 정점이 인접리스트 배열로 표현이 되어 있고, 자신과 인접한 노드들을 리스트로 연결한다.   표현방식: A - B 와 같이 방향성이 없을 때는 A의 인접리스트에 B 원소를 추가하고, B의 뒤에도 A를 추가한다.  A -&gt; B 와 같이 방향성이 있을 때는 A의 인접리스트에 B 원소만 추가한다.      Note: 위 그래프는 방향 그래프임에 주의하라.  A 정점은 B와 C 노드와 이웃하므로 A의 인접리스트 뒤로 B와 C의 원소가 따라 붙는다.  B 정점은 D와 E 노드와 이웃하므로 B의 인접리스트 뒤로 D와 E의 원소가 따라 붙는다.   Pros: 인접 행렬 방식에 비해 메모리 공간을 많이 절약할 수 있다.  각 정점들 간의 이웃관계를 보다 쉽고 확실하게 표현할 수 있다.   Cons: 두 정점이 서로 연결되어 있는지 찾는 연산은 인접 행렬에 비해 다소 느리다.   Implementation   Example Graph  예제에서 나타내고자 하는 그래프는 다음과 같다.   Graph G (Bidirectional):  V = (0, 1, 2, 3, 4) E = (0, 1), (0, 2), (1, 2), (1, 3), (2, 4), (3, 4)  G: 0 ------ 2 |      /   \\ |    /      4 |  /       / 1 ------ 3    위 그래프로 부터 표현되어지는 인접 리스트는 다음과 같다.   0 =&gt; 1 =&gt; 2       // 0번 정점은 1, 2번 정점과 연결되어 있다. 1 =&gt; 0 =&gt; 2 =&gt; 3  // 1번 정점은 0, 2, 3번 정점과 연결되어 있다. 2 =&gt; 0 =&gt; 1 =&gt; 4  // 2번 정점은 0, 1, 4번 정점과 연결되어 있다. 3 =&gt; 1 =&gt; 4       // 3번 정점은 1, 4번 정점과 연결되어 있다. 4 =&gt; 2 =&gt; 3   Graph Class  public class Graph {     private int V; // 그래프의 정점 갯수     private LinkedList&lt;Integer&gt; adjListArray[]; // 그래프의 정점을 저장할 인접리스트 배열      public Graph(int V) { // 그래프 생성자, 정점과 인접리스트 배열을 초기화 한다.         this.V = V;         adjListArray = new LinkedList[V]; // 인접리스트 배열 생성         for (int i = 0; i &lt; V; i++) {             adjListArray[i] = new LinkedList&lt;&gt;(); // 인접리스트 노드 초기화 및 생성         }     } }    addEdge  // 양방향 간선 정보 저장 static void addEdge(Graph graph, int src, int dest) {      graph.adjListArray[src].add(dest); // src -&gt; dest     graph.adjListArray[dest].add(src); // dest -&gt; src }    Graph.java  import java.util.LinkedList;  public class Graph {     private int V; // 그래프의 정점 갯수     LinkedList&lt;Integer&gt; adjListArray[]; // 그래프의 정점을 저장할 인접리스트 배열      public Graph(int V) { // 그래프 생성자, 정점과 인접리스트 배열을 초기화 한다.         this.V = V;         adjListArray = new LinkedList[V];         for (int i = 0; i &lt; V; i++) {             adjListArray[i] = new LinkedList&lt;&gt;();         }     }     // 그래프 출력 메소드     public void printGraph() {         for (int v = 0; v &lt; V; v++) {             System.out.print(v);             for (Integer i : adjListArray[v]) {                 System.out.print(\" =&gt; \" + i);             }             System.out.print(\"\\n\");         }     }     // 양방향 간선 생성 메소드     static void addEdge(Graph graph, int src, int dest) {         graph.adjListArray[src].add(dest);         graph.adjListArray[dest].add(src);     }       public static void main(String[] args) {         int V = 5; // 정점의 갯수는 5개 (0, 1, 2, 3, 4)         Graph graph = new Graph(V); // 그래프 초기화          addEdge(graph, 0, 1); // 0번과 1번을 정점으로 하는 간선을 생성한다.         addEdge(graph, 0, 2); // 0번과 2번을 정점으로 하는 간선을 생성한다.         addEdge(graph, 1, 2); // 1번과 2번을 정점으로 하는 간선을 생성한다.         addEdge(graph, 1, 3);         addEdge(graph, 2, 4);         addEdge(graph, 3, 4);          graph.printGraph();     } }  Output: 0 =&gt; 1 =&gt; 2       // 0번 정점은 1, 2번 정점과 연결되어 있다. 1 =&gt; 0 =&gt; 2 =&gt; 3  // 1번 정점은 0, 2, 3번 정점과 연결되어 있다. 2 =&gt; 0 =&gt; 1 =&gt; 4  // 2번 정점은 0, 1, 4번 정점과 연결되어 있다. 3 =&gt; 1 =&gt; 4       // 3번 정점은 1, 4번 정점과 연결되어 있다. 4 =&gt; 2 =&gt; 3       // 4번 정점은 2, 3번 정점과 연결되어 있다.   References  Graph - Wikipedia  Graph - javapoint  ","categories": ["Data Structure"],
        "tags": ["programming","Data Structure"],
        "url": "http://localhost:4000/data%20structure/graph/",
        "teaser":null},{
        "title": "ping coming soon page",
        "excerpt":"Frontend Mentor - ping coming soon page   Frontend Mentor에서 하루에 하나씩 웹 사이트 랜딩 페이지를 만들어 봅시다.      이 프로젝트는 Frontend Mentor 사이트에 있는 프로젝트들을 가지고 진행합니다.   프로젝트 따라하기   다음 링크를 따라가셔서 프로젝트에 필요한 이미지와 텍스트 그리고 가이드라인이 들어있는 파일을 다운로드 할 수 있습니다.   해당 프로젝트 기초파일   결과 프로젝트 실행 방법   다음 링크의 저장소로 가시면 완성된 결과 프로젝트의 파일을 확인 하실 수 있습니다.   프로젝트 완성 파일   저장소를 클론하여, 압축을 푼 다음, index.html 파일을 실행시켜 주세요.   밑은 프로젝트의 README.md 입니다.   Welcome! 👋   Thanks for checking out this front-end coding challenge.   Frontend Mentor challenges allow you to improve your skills in a real-life workflow.   To do this challenges, you need a basic understanding of HTML and CSS.   Where to find everything   Your task is to build out the project to the designs inside the /design folder. You will find both a mobile and a desktop version of the design to work to.   The designs are in JPG static format. This will mean that you’ll need to use your best judgment for styles such as font-size, padding and margin. This should help train your eye to perceive differences in spacings and sizes.   If you would like the Sketch file in order to see sizes etc, it is available to download from the challenge page.   You will find all the required assets in the /images folder. The assets are already optimized.   There is also a style-guide.md file, which contains the information you’ll need, such as color palette and fonts.   Building your project   Feel free to use any workflow that you feel comfortable with. Below is a suggested process, but do not feel like you need to follow these steps:      Initialize your project as a public repository on GitHub. This will make it easier to share your code with the community if you need some help. If you’re not sure how to do this, have a read through of this Try Git resource.   Configure your repository to publish your code to a URL. This will also be useful if you need some help during a challenge as you can share the URL for your project with your repo URL. There are a number of ways to do this, but we recommend using ZEIT Now. We’ve got more information about deploying your project with ZEIT below.   Look through the designs to start planning out how you’ll tackle the project. This step is crucial to help you think ahead for CSS classes that you could create to make reusable styles.   Before adding any styles, structure your content with HTML. Writing your HTML first can help focus your attention on creating well-structured content.   Write out the base styles for your project, including general content styles, such as font-family and font-size.   Start adding styles to the top of the page and work down. Only move on to the next section once you’re happy you’ve completed the area you’re working on.   If you’d like to try making your project fully responsive, we’d recommend checking out Sizzy. It’s a great browser that makes it easy to view your site across multiple devices.   Deploying your project   As mentioned above, there are a number of ways to host your project for free. We recommend using ZEIT Now as it’s an amazing service and extremely simple to get set up with. If you’d like to use ZEIT, here are some steps to follow to get started:      Sign up to ZEIT Now and go through the onboarding flow, ensuring your GitHub account is connected by using their ZEIT Now for GitHub integration.   Connect your project to ZEIT Now from the “Create a new project” page, using the “New Project From GitHub” button and selecting the project you want to deploy.   Once connected, every time you git push, ZEIT Now will create a new deployment and the deployment URL will be shown on your ZEIT Dashboard. You will also receive an email for each deployment with the URL.   Sharing your solution   There are multiple places you can share your solution:      Submit it on the platform so that other users will see your solution on the site. Other users will be able to give you feedback, which could help improve your code for the next project.   Share your repository and live URL in the #finished-projects channel of the Slack community.   Tweet @frontendmentor and mention @frontendmentor including the repo and live URLs in the tweet. We’d love to take a look at what you’ve built and help share it around.   Giving feedback   Feedback is always welcome, so if you have any to give on this challenge please email hi[at]frontendmentor[dot]io.   This challenge is completely free. Please share it with anyone who will find it useful for practice.   Have fun building! 🚀  ","categories": ["Development"],
        "tags": ["HTML","CSS","Web"],
        "url": "http://localhost:4000/development/Ping-coming-soon-page/",
        "teaser":null},{
        "title": "Restful API Authentication App",
        "excerpt":"Restful API Authentication App   Used Packages, Libraris, Dependencies and Database in the project.     Node.js   Express.js: Node.js package   nodemon: To restart server   Mongoose: DB package   MongoDB: To save user data   bcryptjs: Encrypt the user’s password so that 3rd party don’t see   dotenv: Configuration private setting data   @hapi/joi: To validate user input form data   Make sure   Make sure that node.js must be installed in your computer.   Make sure that you must have your own mongoDB cluster.  Make sure that postman which is used to requset get or post method with data to server should be installed.   Usage      clone the repository.   Inside .env file, Replace  with your mongoDB account password.   Open the terminal.   Start Server by typing ‘npm start’ or ‘npm run dev’ in the terminal (Make sure that except for quotation mark in the terminal).   Open the postman   Try to send ‘POST’ request with JSON data(below 6) format with URL - http://localhost:5000/api/user/register   Try with Example JSON data =&gt; { “name”: “lemidia”, “email”: “poiu2186@gmail.com”, “password”:”own password” }   Once you have done this, Try to send ‘POST’ request with JSON data(below 7) format with URL - http://localhost:5000/api/user/login   Try with Example JSON data =&gt; { “poiu2186@gmail.com”, “password”:”&lt;own passowrd” }   Repository   Github - lemidia  ","categories": ["Development"],
        "tags": ["Development","JavaScript","Node.js","API"],
        "url": "http://localhost:4000/development/restfulauth/",
        "teaser":null},{
        "title": "합병 정렬(Merge Sort)",
        "excerpt":"Merge Sort(합병 정렬)   합병 정렬 또는 병합 정렬(merge sort)은 O(n log n) 비교 기반 정렬 알고리즘입니다.  일반적인 방법으로 구현했을 때 이 정렬은 안정 정렬에 속하며, 분할 정복 알고리즘의 하나입니다. 존 폰 노이만이 1945년에 개발했습니다.   Algorithm   밑의 애니메이션을 먼저 보시고 알고리즘을 읽으시면 이해가 빠를 수 있습니다.      리스트의 길이가 1 이하이면 이미 정렬된 것으로 본다. 그렇지 않은 경우에는   분할(divide) : 정렬되지 않은 리스트를 절반으로 잘라 비슷한 크기의 두 부분 리스트로 나눈다.   정복(conquer) : 각 부분 리스트를 재귀적으로 합병 정렬을 이용해 정렬한다.   결합(combine) : 두 부분 리스트를 다시 하나의 정렬된 리스트로 합병한다. 이때 정렬 결과가 임시배열에 저장된다.   복사(copy) : 임시 배열에 저장된 결과를 원래 배열에 복사한다.   Animation - Merge sort      Analysis      Note: 7개의 원소가 들어있는 배열에 재귀적 병합 정렬을 적용했을 때 우리가 상상할 수 있는 그림입니다.  배열의 원소가 1개가 될 때까지 원래 배열의 1/2씩 분할을 계속 진행합니다.  배열의 원소가 1개가 되면 병합을 진행합니다.  [38][27]  38은 27보다 크므로 두 원소가 스왑되어 합병됩니다.  [43][3]  43은 3보다 크므로 두 원소가 스왑되어 합병됩니다.  [27, 38] [3, 43]  27과 3이 스왑되고 38과 43은 그대로 배열에 들어갑니다.  이와 마찬가지로 다른 분할 배열들도 위와 같이 진행됩니다.   Java로 구현 - 재귀적(Top-down, Recursive)   설명: 재귀적으로 서브배열의 크기가 1이 될 때까지 계속 분할을 진행합니다.  분할된 배열들을 정렬하고 합병합니다.  // @author lemidia public class MergeSort {     static void divide(int data[], int p, int r){         if(p &lt; r){             int q = (p+r)/2; // Middle             divide(data, p, q); // Left             divide(data, q+1, r); // Right             merge(data, p, q, r); // Merge         }     }      static void merge(int data[], int p, int q, int r){         int i = p; int j = q+1; int k = p;         int temp[] = new int[data.length];          for (int l = p; l &lt; r+1 ; l++) {             if (i &lt;= q &amp;&amp; (j &gt; r || data[i] &lt; data[j])){                 temp[k++] = data[i++];             }else                 temp[k++] = data[j++];         }         for(int l = p; l &lt;= r; l++){             data[l] = temp[l];         }          /*         while (i&lt;=q &amp;&amp; j&lt;=r){             if(data[i] &lt;= data[j]){                 temp[k++] = data[i++];             }else{                 temp[k++] = data[j++];             }         }         while (i&lt;=q)             temp[k++] = data[i++];         while (j&lt;=r)             temp[k++] = data[j++];         for(int l = p; l&lt;=r; l++){             data[l] = temp[l];         }         */      }      public static void main(String[] args) {         int limit = 10;         int arr[] = new int[limit];          for(int i = limit-1; i &gt;= 0; --i){             arr[i] = limit-i;         }         divide(arr, 0, limit-1);         for (int i = 0; i &lt; arr.length; i++) {             System.out.print(arr[i] + \" \");         }     } }   1 2 3 4 5 6 7 8 9 10    시간복잡도  최악 시간복잡도\tO(n log n) 최선 시간복잡도\tO(n log n) 평균 시간복잡도\t일반적으로, O(n log n)  쉬운 설명: 배열의 원소가 n개일 때 깊이는 log(n)만큼 진행 됩니다. (매번 2개씩 분할 되므로)  각 깊이마다 n개의 원소들이 제자리를 찾아 스왑됩니다.  그래서 시간복잡도는 깊이 * n개의 원소 즉, nlog(n)이 됩니다.   References   Merge Sort - wikipedia  ","categories": ["Algorithm"],
        "tags": ["Sort","Mathematics"],
        "url": "http://localhost:4000/algorithm/merge-sort/",
        "teaser":"http://localhost:4000/assets/images/merge-sort-rec.png"},{
        "title": "pricing component with toggle",
        "excerpt":"Frontend Mentor - pricing component with toggle   하루에 하나씩 웹 컴포넌트 페이지를 만들어 봅시다.   pricing component with toggle - Frontend Mentor   이 프로젝트는 유튜버 Florin pop에 진행되었으며, Frontend Mentor 사이트에 있는 프로젝트들을 가지고 진행합니다.      프로젝트 따라하기   다음 링크를 따라가셔서 프로젝트에 필요한 이미지와 텍스트 그리고 가이드라인이 들어있는 파일을 다운로드 할 수 있습니다.   해당 프로젝트 기초파일   이 프로젝트는 유튜버 Florin pop에 의해서도 실시간으로 진행되었으니 같이 따라하셔도 좋습니다.   유튜브에서 이 프로젝트 같이 실습하기   결과 프로젝트 실행 방법   다음 링크의 저장소로 가시면 완성된 결과 프로젝트의 파일을 확인 하실 수 있습니다.   프로젝트 완성 파일   저장소를 클론하여, 압축을 푼 다음, index.html 파일을 실행시켜 주세요.   밑은 프로젝트의 README.md 입니다.   Welcome! 👋   Thanks for checking out this front-end coding challenge.   Frontend Mentor challenges allow you to improve your skills in a real-life workflow.   To do this challenges, you need a basic understanding of HTML and CSS.   Where to find everything   Your task is to build out the project to the designs inside the /design folder. You will find both a mobile and a desktop version of the design to work to.   The designs are in JPG static format. This will mean that you’ll need to use your best judgment for styles such as font-size, padding and margin. This should help train your eye to perceive differences in spacings and sizes.   If you would like the Sketch file in order to see sizes etc, it is available to download from the challenge page.   You will find all the required assets in the /images folder. The assets are already optimized.   There is also a style-guide.md file, which contains the information you’ll need, such as color palette and fonts.   Building your project   Feel free to use any workflow that you feel comfortable with. Below is a suggested process, but do not feel like you need to follow these steps:      Initialize your project as a public repository on GitHub. This will make it easier to share your code with the community if you need some help. If you’re not sure how to do this, have a read through of this Try Git resource.   Configure your repository to publish your code to a URL. This will also be useful if you need some help during a challenge as you can share the URL for your project with your repo URL. There are a number of ways to do this, but we recommend using ZEIT Now. We’ve got more information about deploying your project with ZEIT below.   Look through the designs to start planning out how you’ll tackle the project. This step is crucial to help you think ahead for CSS classes that you could create to make reusable styles.   Before adding any styles, structure your content with HTML. Writing your HTML first can help focus your attention on creating well-structured content.   Write out the base styles for your project, including general content styles, such as font-family and font-size.   Start adding styles to the top of the page and work down. Only move on to the next section once you’re happy you’ve completed the area you’re working on.   If you’d like to try making your project fully responsive, we’d recommend checking out Sizzy. It’s a great browser that makes it easy to view your site across multiple devices.   Deploying your project   As mentioned above, there are a number of ways to host your project for free. We recommend using ZEIT Now as it’s an amazing service and extremely simple to get set up with. If you’d like to use ZEIT, here are some steps to follow to get started:      Sign up to ZEIT Now and go through the onboarding flow, ensuring your GitHub account is connected by using their ZEIT Now for GitHub integration.   Connect your project to ZEIT Now from the “Create a new project” page, using the “New Project From GitHub” button and selecting the project you want to deploy.   Once connected, every time you git push, ZEIT Now will create a new deployment and the deployment URL will be shown on your ZEIT Dashboard. You will also receive an email for each deployment with the URL.   Sharing your solution   There are multiple places you can share your solution:      Submit it on the platform so that other users will see your solution on the site. Other users will be able to give you feedback, which could help improve your code for the next project.   Share your repository and live URL in the #finished-projects channel of the Slack community.   Tweet @frontendmentor and mention @frontendmentor including the repo and live URLs in the tweet. We’d love to take a look at what you’ve built and help share it around.   Giving feedback   Feedback is always welcome, so if you have any to give on this challenge please email hi[at]frontendmentor[dot]io.   This challenge is completely free. Please share it with anyone who will find it useful for practice.   Have fun building! 🚀  ","categories": ["Development"],
        "tags": ["HTML","CSS","Web"],
        "url": "http://localhost:4000/development/Intro-component-with-sign-up-form/",
        "teaser":null},{
        "title": "큐(Queue)",
        "excerpt":"Queue  큐(queue)는 컴퓨터의 기본적인 자료 구조의 한가지로, 먼저 집어 넣은 데이터가 먼저 나오는 FIFO (First In First Out)구조로 저장하는 형식을 말한다. 영어 단어 queue는 표를 사러 일렬로 늘어선 사람들로 이루어진 줄을 말하기도 하며, 먼저 줄을 선 사람이 먼저 나갈 수 있는 상황을 연상하면 된다.      Representation     Array: 기본적으로 배열을 사용해서 큐를 구현할 수 있다.   Linked List: 링크드 리스트를 이용하면 배열에 비해 쉽게 구현이 가능하다.   Note: 이번 포스트에서는 자바로 Linked List를 이용해서 큐를 구현해 본다.   Queue Node - 큐 원소를 표현하기 위한 노드 클래스   // A linked list (LL) node to store a queue entry  class QNode {      int key;      QNode next;         // constructor to create a new linked list node      public QNode(int key)      {          this.key = key;          this.next = null;      }  }   Queue Node - 큐를 표현하는 클래스   class Queue {      QNode front, rear;         public Queue()      {          this.front = this.rear = null;      }  }   Note: 큐는 맨 처음 원소를 가리키는 front와 맨 끝 원소를 가리키는 rear 포인터를 가지고 있다.   Operation  큐가 지원하는 연산들을 알아보자.      Enqueue: 큐의 맨 끝에 원소를 추가하는 연산.   Dequeue: 큐의 맨 처음의 원소를 삭제하고 반환하는 연산. 큐가 비었으면 null을 반환한다.   Enqueue - 원소 추가 연산  void enqueue(int key) {      // Create a new LL node      QNode temp = new QNode(key);       // If queue is empty, then new node is front and rear both      if (this.rear == null) {          this.front = this.rear = temp;          return;      }       // Add the new node at the end of queue and change rear      this.rear.next = temp;      this.rear = temp;  }   Dequeue - 원소 삭제 연산   QNode dequeue() {      // If queue is empty, return NULL.      if (this.front == null)          return null;       // Store previous front and move front one node ahead      QNode temp = this.front;      this.front = this.front.next;       // If front becomes NULL, then change rear also as NULL      if (this.front == null)          this.rear = null;      return temp;  }   Queue Implementation - 전체 코드   // A linked list (LL) node to store a queue entry  class QNode {      int key;      QNode next;         // constructor to create a new linked list node      public QNode(int key)      {          this.key = key;          this.next = null;      }  }   // A class to represent a queue  // The queue, front stores the front node of LL and rear stores the  // last node of LL  class Queue {      QNode front, rear;         public Queue()      {          this.front = this.rear = null;      }         // Method to add an key to the queue.      void enqueue(int key)      {             // Create a new LL node          QNode temp = new QNode(key);             // If queue is empty, then new node is front and rear both          if (this.rear == null) {              this.front = this.rear = temp;              return;          }             // Add the new node at the end of queue and change rear          this.rear.next = temp;          this.rear = temp;      }         // 큐에서 원소를 삭제하는 연산     QNode dequeue()      {          // If queue is empty, return NULL.          if (this.front == null)              return null;             // Store previous front and move front one node ahead          QNode temp = this.front;          this.front = this.front.next;             // If front becomes NULL, then change rear also as NULL          if (this.front == null)              this.rear = null;          return temp;      }  }     // Driver class  public class Test {      public static void main(String[] args)      {          Queue q = new Queue();          q.enqueue(10);          q.enqueue(20);          q.dequeue();          q.dequeue();          q.enqueue(30);          q.enqueue(40);          q.enqueue(50);             System.out.println(\"Dequeued item is \" + q.dequeue().key);      }  }    Queue q = new Queue();  빈 큐가 생성이 된다.  현재: q = []  q.enqueue(10);  q.enqueue(20);  (10, 20)이 들어온다.  현재: q = [10, 20];  q.dequeue();  q.dequeue();  (10, 20)이 나간다.  현재: q = [];  q.enqueue(30);  q.enqueue(40);  q.enqueue(50);  (30, 40, 50)이 차례대로 들어온다.  현재: q = [30, 40, 50];  System.out.println(\"Dequeued item is \" + q.dequeue().key);  디큐 연산으로 인해 맨앞의 30이 삭제되고 반환된다.  Output: Dequeued item is 30   자바가 제공하는 큐   자바에서는 Queue Interface를 구현한 Linked List Class를 제공한다.   큐 선언: Queue&lt;T&gt; queue = new LinkedList&lt;T&gt;();  큐 연산: queue.offer(); // 삽입 연산 queue.pop();   // 삭제하고 원소 반환 queue.peek();  // 큐의 맨 앞 원소 반환 queue.isEmpty(); // 큐가 비었는지 확인   Time Complexity  Algorithm   Average  WorstCase Space       O(n)     O(n) Search      O(n)     O(n) Insert      O(1)     O(1) Delete      O(1)     O(1)   References  Queue - Wikipedia   Queue - Geeks  ","categories": ["Data Structure"],
        "tags": ["programming","Data Structure"],
        "url": "http://localhost:4000/data%20structure/queue/",
        "teaser":null},{
        "title": "자바스크립트를 이용한 날씨 웹 앱",
        "excerpt":"앱 개요   웹 화면 상으로 사용자의 지역 날씨 상태를 보여주는 웹 어플리케이션.   Look      설명   사용자가 웹 앱에 접속하면 사용자로부터 위치정보 엑세스에 대한 허용 여부를 묻는다.  허용이 되면 자바스크립트의 navigator.geolocation으로 부터 사용자의 위도와 경도 값을 읽어낸다.  DarkSky API로 부터 받은 사용자 키 값에 위도와 경도값을 넣어준다.  API로 부터 읽어낸 JSON 데이터를 자바스크립트 객체로 변환하여 앱에서 필요한 데이터를 얻는다.   사용되는 것들     HTML - 웹 엘리먼트 구조   CSS - 스타일 꾸미기 및 레이아웃   Pure JavaScript - 사용자 위치정보, Dom Tree 조작, 온도 계산   DarkSky Api - 날씨 정보를 받아오기 위해 사용 (월 1000건 까지의 쿼리는 무료)   SkyCons - DarkSky Api에서 제공하는 날씨 아이콘   실행 방법   하나의 폴더에 밑의 index.html, style.css, app.js파일을 넣어준다.  그리고, 날씨 데이터 사이트에 가서 Try For Free를 눌러 가입하여 API키 값을 얻어낸 다음  app.js 파일의 “자신의 키” 부분에 API 키 값을 넣어준다.  // app.js파일의 &lt;자신의 키&gt; 부분에 API 키 값을 넣어준다. const api = `${proxy}https://api.darksky.net/forecast/&lt;자신의 키&gt;/${lat}, ${long}`;   Source Code   index.html   &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt;     &lt;meta charset=\"UTF-8\"&gt;     &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;     &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt;     &lt;link rel=\"stylesheet\" href=\"./style.css\"&gt;     &lt;title&gt;Weather&lt;/title&gt; &lt;/head&gt; &lt;body&gt;      &lt;div class=\"location\"&gt;         &lt;h1 class=\"location-timezone\"&gt;Loading Location Data ...&lt;/h1&gt;         &lt;canvas id=\"icon1\" width=\"128\" height=\"128\"&gt;&lt;/canvas&gt;     &lt;/div&gt;     &lt;div class=\"temperature\"&gt;         &lt;div class=\"degree-section\"&gt;             &lt;h2 class=\"temperature-degree\"&gt;?&lt;/h2&gt;             &lt;span class=\"transition\"&gt;C&lt;/span&gt;         &lt;/div&gt;         &lt;div class=\"temperature-description\"&gt;Loading Data ... &lt;/div&gt;     &lt;/div&gt;     &lt;script src=\"./app.js\"&gt;&lt;/script&gt;     &lt;script src=\"skycons.js\"&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt;  style.css  *{     margin: 0;     padding: 0;     box-sizing: border-box; }  body{     height: 100vh;     display: flex;     justify-content: center;     flex-direction: column;     align-items: center;     background: linear-gradient(rgb(47,150,163), rgb(48, 62, 143));     font-family: sans-serif;     color: white; }  .location, .temperature{     height: 20vh;     width: 50%;     display: flex;     justify-content: space-around;     align-items: center; }  .temperature{     flex-direction: row;     align-items: baseline; }  .temperature-description{     font-size: 2rem;     transform: translateX(20%); }  .degree-section{     display: flex;     align-items: center;     cursor: pointer;     transform: translateX(30%); }  .degree-section span{     margin: 7px;     font-size: 35px; }  .degree-section h2{     font-size: 40px; }  @media screen and (max-width:550px){     .location-timezone{         margin-right: 3rem;     }      .degree-section{         margin-right: 6rem;         font-size: 30px;     }      .temperature-description{         transform: translateX(-20%);     } }  app.js  window.addEventListener('load', () =&gt;{     let long;     let lat;     let temperatureDescription = document.querySelector('.temperature-description');     let temperatureDegree = document.querySelector('.temperature-degree');     let locationTimezone = document.querySelector('.location-timezone');          if (navigator.geolocation) {         navigator.geolocation.getCurrentPosition( position =&gt; {             long = position.coords.longitude;             lat = position.coords.latitude;             const proxy = 'https://cors-anywhere.herokuapp.com/';             const api = `${proxy}https://api.darksky.net/forecast/&lt;자신의 키&gt;/${lat}, ${long}`;              fetch(api)                 .then(response =&gt; {                  return response.json();                 })                  .then(data =&gt; {                    console.log(data);                    const {dewPoint, summary, icon} = data.currently;                    // Set DOM Elements from the API                    temperatureDegree.textContent = Math.round((dewPoint - 32) / 1.8);                    temperatureDescription.textContent = summary;                    locationTimezone.textContent = data.timezone.replace(\"/\", \" / \");                    setIcons(icon, \"icon1\");                   });         }, () =&gt; {             alert(\"You have denied or please confirm location\");         });     } else{         alert(\"Geolocation is not supported by your browser\");     }     function setIcons(icon, iconID){         const skycons = new Skycons({color : \"white\"});         const weatherCondition = icon.replace(/-/g, \"_\").toUpperCase();         skycons.set(iconID, Skycons[weatherCondition]);         skycons.play();     }      let degreeSection = document.querySelector('.degree-section');     let transition = document.querySelector('.transition');     let isCelsius = true;     degreeSection.addEventListener('click', () =&gt; {         if (isCelsius) {             temperatureDegree.textContent              = Math.round(parseInt(temperatureDegree.textContent) * 1.8 + 32);             transition.textContent = 'F';             isCelsius = false;         }else{             temperatureDegree.textContent              = Math.round((parseInt(temperatureDegree.textContent) - 32) / 1.8);             transition.textContent = 'C';             isCelsius = true;         }     }) });  References   [Dev Ed - Youtube]  ","categories": ["Development"],
        "tags": ["JavaScript","Web","API"],
        "url": "http://localhost:4000/development/weather-app/",
        "teaser":null},{
        "title": "비선형 구조와 탐색(Non-linear Structure and Search)",
        "excerpt":"비선형 구조와 탐색   비선형 구조란 i번째 원소를 탐색한 다음 그 원소와 연결된 다른 원소를 탐색하려고 할 때, 여러 개의 원소가 존재하는 탐색구조를 말한다.   일반적으로 자료가 트리나 그래프로 구성되어 있을 경우를 비선형 구조라 하고 이러한 트리나 그래프의 모든 정점을 탐색하는 것을 비선형 탐색이라고 이해하면 된다.   비선형 구조는 선형과 달리 자료가 순차적으로 구성되어 있지 않으므로 단순히 반복문을 이용하여 탐색하기에는 어려움이 있다. 그러므로 비선형구조는 스택이나 큐와 같은 자료구 조를 활용하여 탐색하는 것이 일반적이다.   비선형 구조의 탐색은 크게 깊이우선탐색(depth first search, dfs)과 너비우선탐색 (breadth firth search, bfs)으로 나눌 수 있으며, 이 두 가지 탐색법에 대해서 알아본다.   비선형 구조   비선형 구조의 탐색을 다루기 전에 그래프와 트리에 대해서 간단히 알아보자.  트리와 그래프를 이루는 기본 요소를 정점(vertex)과 간선(edge)이라고 한다.      원은 정점, 선분은 간선을 나타내며, a-b는 보통간선, a-&gt;b는 방향간선, b-d는 가중치가 15인 양방향통행 간선, d-&gt;e는 가중치가 7인 일방통행 간선(방향간선)을 나타낸다.  정점은 점 또는 원으로 표현하며, 일반적으로 상태나 위치를 표현한다. 간선은 정점들을 연결하는 선으로 표현하며, 정점들 간의 관계를 표현한다.   경로(path)와 회로(cycle)   그래프에서 임의의 정점 s에서 임의의 정점 t로 이동할 때, s에서 t로 이동하는데 사용한 정점들을 연결하고 있는 간선들의 순서로 된 집합을 경로라고 한다. 회로는 그래프에서 임 의의 정점 s에서 같은 정점 s로의 경로들을 말한다.      자기간선(loop)과 다중간선(multi edge)   임의의 정점에서 자기 자신으로 연결하고 있는 간선을 자기간선, 임의의 정점에서 다른 정점으로 연결된 간선의 수가 2개 이상일 경우를 다중간선이라고 한다.      그래프의 차수(degree)  그래프의 임의의 한 정점에서 다른 정점으로 연결된 간선의 수를 차수라고 한다.      그래프의 구현   그래프를 구현하는 방법은 인접행렬(adjacency matrix)과 인접리스트(adjacency list)로 크게 나눌 수 있다.   tip: 프로그래밍 대회에서 그래프는 보통 정점의 수, 간선의 수, 각 간선들이 연결하고 있는 정점 2개로 이루어진 정보가 주어진다.   다음과 같은 그래프가 주어질 때, 이를 표현하는 2가지 방법을 알아본다.      위 그래프의 입력 형식과 입력 데이터의 예   입력 형식: 첫 번째 줄에 정점의 수 n과 간선의 수 m 이 공백으로 구분되어 입력된다. 두 번째 줄부터 m개의 줄에 걸쳐서 간선으로 연결된 두 정점의 번호와 가중치가   공백으로 구분되어 입력된다.  입력 데이터: 7 11 1 2 47  1 3 69  2 4 57  2 5 124  3 4 37  3 5 59  3 6 86  4 6 27  4 7 94  5 7 21  6 7 40   인접행렬의 구현   입력예시를 인접행렬로 받기 위해서는 2차원 배열을 이용한다.  먼저 최대 정점의 수에 맞추어 2차원 배열을 선언하고 각 배열의 칸에 연결된 정보를 저장한다.  앞 그래프를 2차원 행렬을 이용하여 다음과 같이 저장한다.      2차원 행렬을 이용하여 저장하는 소스코드는 다음과 같다. 단 최대 정점의 수는 100개 로 가정한다.   C language #include &lt;stdio.h&gt;  int n, m, G[101][101]; int main() {     scanf(\"%d %d\",&amp;n,&amp;m);     for(int i=0; i&lt;m; i++) {         int a, b, w;         scanf(\"%d %d %d\", &amp;a, &amp;b, &amp;w);         G[a][b]=G[b][a]=w;     }  }   인접리스트의 구현   인접행렬로 표현할 때에는 연결되지 않았던 부분까지 모두 표현이 된다. 즉, 각 칸에 0 이라고 기록된 부분은 연결이 되지 않은 부분을 의미한다. 사실 일반적인 그래프에서 행렬 상에서 0이라고 표현되는 부분이 많을 가능성이 크다.   알고리즘을 구현할 때에도 이 0이라고 표시된 부분까지 모두 조사를 해야 하므로 효율 이 떨어지는 경우가 많다. 이러한 단점을 극복하기 위하여 제안된 방법이 인접리스트이고 이 방법은 인접행렬에서 0으로 표시된 부분은 저장하지 않으므로 효율을 높이고 있다.         위의 입력 예시를 인접리스트로 구현하기 위해서는 [그림-10], [그림-11]과 같이 연결리스트로 구현할 수 있지만 STL에서 제공하는 C++의 std::vector()를 이용하면 보다 더 간단하게 구현할 수 있다. 위의 입력예시를 인접리스트로 구현하면 다음과 같은 그림이 된다.      C++의 std::vector()를 이용한다면 위와 같이 인접행렬로 구현하는 것보다 공간을 더 적게 사용한다. 따라서 전체탐색법을 구현할 때, 당연히 탐색시간도 줄일 수 있다. 계산량으로 표현하자면, 인접행렬로 모든 정점을 탐색하는데 O($n^2$)의 시간이 드는데 반해, 인접리스트로 표현하면 O(n+m)의 시간이 든다.   여러 가지 장점으로 인해 인접리스트를 이용한 방법을 활용하는 경우가 많으므로 반드시 익혀둘 수 있도록 하자.   비선형 구조의 탐색   깊이우선탐색(dfs)   그래프 중 회로(cycle)가 없는 그래프를 트리라고 한다. 다음 그림은 트리를 나타낸다. 이 트리의 가장 위에 있는 정점에서 출발하여 모든 정점들을 깊이우선으로 탐색하며, 탐색 하는 순서를 알아보자.      출발 정점을 트리의 가장 위에 있는 정점으로 하고, 한 정점에서 이동 가능한 정점이 여 러 개 있을 경우 왼쪽의 정점부터 방문한다고 가정하면, 단계별 탐색 과정은 다음과 같다.      깊이우선탐색과정에서 3단계 이후 더 이상 진행할 수 있는 정점이 없다. 그 이유는 간선 으로 연결된 정점들 중 아직 방문하지 않은 정점을 방문하기 때문이다.   이처럼 더 이상 진행할 수 없을 때는 다시 이전 정점으로 되돌아가는 과정이 필요하다. 일반적으로 이 과정을 백트랙(backtrack)이라고 한다. 백트랙은 비선형 구조의 탐색에서 매 우 중요하다. 백트랙은 스택(stack)이나 재귀함수(recursion)를 이용하면 쉽게 구현할 수 있다.      4, 5, 6단계는 연속으로 백트랙이 발생한다. 이는 더 이상 진행할 수 없는 정점까지 도달 했다는 것을 의미한다. 계속 해서 다음 단계로 진행하는 과정은 다음과 같다.      위 단계에서 마지막 정점을 방문하면 깊이우선탐색이 완료된다.      깊이우선탐색을 정리하여 설명하면 먼저 시작 정점에서 간선을 하나 선택하여 진행할 수 있을 때까지 진행하고 더 이상 진행할 수 없다면 백트랙하여 다시 다른 정점으로 진행 하여 더 이상 진행할 정점이 없을 때까지 이 과정을 반복하는 탐색법으로, 간선으로 연결 된 모든 정점을 방문할 수 있는 탐색법이다.   깊이우선탐색의 알고리즘은 다음과 같다. 이 탐색법은 백트래킹(backtracking)이라는 알 고리즘 설계 기법의 중심이 되며 백트래킹 기법은 모든 문제를 해결할 수 있는 가장 기본 적인 방법이므로 꼭 익혀둘 필요가 있다.   깊이우선탐색   bool visited[101]; //방문했는지 체크해 두는 배열 void dfs(int k){     for(int i=0; i&lt;G[i].size(); i++){ // 정점 k와 연결된 모든 정점 방문         if(!visited[G[k][i].to]){ // 만약 아직 방문하지 않았으면             visited[G[k][i].to]=true; // 방문했다고 체크하고             // 깊이우선탐색 진행             dfs(G[k][i]);         }     }     return; //더 이상 갈 길이 없으면 backtrack }   이 방법은 그래프를 인접리스트에 저장했을 경우에 활용할 수 있다. 전체를 탐색하는데 있어서 반복문의 실행횟수는 모두 m 번이 된다. 일반적으로 인접행렬 보다 속도가 더 빠르기 때문에 자주 활용된다.     너비우선탐색(bfs)   너비우선탐색은 깊이우선탐색과는 달리 현재 정점에서 깊이가 1인 정점을 모두 탐색한 뒤 깊이를 늘려가는 방식이다. 위에서 다룬 ‘10개의 정점과 9개의 간선을 가진 트리’를 통해서 너비우선탐색을 살펴보자.      먼저 1단계부터 4단계까지를 살펴보면 1에서 출발하여 깊이가 1인 세 정점을 모 두 순차적으로 방문한다. 계속해서 너비우선탐색의 결과를 살펴보면 다음과 같다.         너비우선탐색은 백트랙을 하지 않는다. 대신에 현재 정점에서 깊이가 1인 정점을 모두 방문해야 하므로 큐(queue)라는 선입선출(FIFO) 자료구조를 활용하여 현재 정점에서 깊이가 1 더 깊은 모든 정점을 순차적으로 큐에 저장하여 탐색에 활용한다.  따라서 STL에서 제 공하는 std::queue()를 활용하는 방법을 익힐 필요가 있다.   너비우선탐색 알고리즘은 다음과 같다.   #include &lt;queue&gt; bool visited[101]; void bfs(int k){     std::queue&lt;int&gt; Q;     Q.push(k), visited[k]=1;     while(!Q.empty()){         int current=Q.front();         Q.pop();         for(int i=0; i&lt;G[current].size(); i++){             if(!visited[G[current][i]]) {                 visited[G[current][i]]=1;                 Q.push(G[current][i]);             }         }     } }   이 방법은 그래프를 인접리스트에 저장했을 경우에 활용할 수 있으며, 전체를 탐색하는 데 있어서 반복문의 실행횟수는 모두 m번이 된다. 따라서 일반적으로 속도가 인접행렬 보다 더 빠르기 때문에 자주 활용된다.   References      문제해결을 위한 창의적 알고리즘  ","categories": ["Algorithm"],
        "tags": ["DFS","BFS","Data structure","programming"],
        "url": "http://localhost:4000/algorithm/%EB%B9%84%EC%84%A0%ED%98%95%EA%B5%AC%EC%A1%B0%EC%9D%98-%ED%83%90%EC%83%89/",
        "teaser":"http://localhost:4000/assets/images/creativealgorithm1.png"},{
        "title": "에라토스테네스의 체(Eratosthenes's Sieve)",
        "excerpt":"에라토스테네스의 체   수학에서 에라토스테네스의 체는 보다 빠르게 소수를 찾는 방법입니다.  고대 그리스 수학자 에라토스테네스가 발견하였습니다.     선행지식: 수학에서 소수란?   소수: 1을 제외한 수 중에서 1과 자기 자신을 제외하고 약수를 가지지 않는 수를 말합니다.   예)   예1) 2는 1과 자기 자신(2)을 제외하고는 약수를 가지지 않습니다. 소수입니다. 예2) 5는 1과 자기 자신(5)을 제외하고는 약수를 가지지 않습니다. 소수입니다. 예3) 13은 1과 자기 자신(13)을 제외하고는 약수를 가지지 않습니다. 소수입니다. 예4) 15는 1과 자기자신(15)를 제외하고도 3, 5의 약수를 가집니다. 소수가 아닙니다.   Algorithm   밑의 애니메이션을 먼저 보시고 알고리즘을 읽으시면 이해가 빠를 수 있습니다.      2부터 소수를 구하고자 하는 구간의 모든 수를 나열한다. 그림에서 회색 사각형으로 두른 수들이 여기에 해당한다.   2는 소수이므로 오른쪽에 2를 쓴다. (빨간색)   자기 자신을 제외한 2의 배수를 모두 지운다.   남아있는 수 가운데 3은 소수이므로 오른쪽에 3을 쓴다. (초록색)   자기 자신을 제외한 3의 배수를 모두 지운다.   남아있는 수 가운데 5는 소수이므로 오른쪽에 5를 쓴다. (파란색)   자기 자신을 제외한 5의 배수를 모두 지운다.   남아있는 수 가운데 7은 소수이므로 오른쪽에 7을 쓴다. (노란색)   자기 자신을 제외한 7의 배수를 모두 지운다.   위의 과정을 반복하면 구하는 구간의 모든 소수가 남는다.      Note: 만약 x까지의 소수를 구한다고 하면 우리는 x까지 검사하여 일일히 지울 필요가 없습니다.  x는 &gt;= $\\sqrt {x}$ * $\\sqrt {x}$으로 표현 할 수 있고, $\\sqrt {x}$까지 수를 지우면, 그 이후의 수들은 이미 $\\sqrt {x}$까지의 수에서 지워졋기 때문입니다.  예) x를 16 이라고 해봅시다. $\\sqrt {x}$은 4 입니다.  8은 16의 약수입니다. 하지만 8은 이미 전 단계 2에서 지워졌습니다. 2 * 8이기 때문입니다.  예제에서는 120까지 구하고 있으므로 120의 제곱근 $\\sqrt {120}$ = 10까지만 지워도 됩니다.  왜냐하면 $\\sqrt {120}$ = 10 이후의 배수들은 이미 전 단계에서 지워졋기 때문입니다.   Java로 구현  import java.util.Arrays;  public class Eratosthenes {     private static final int MAX = 30;      public static void main(String[] args) {          boolean [] flag = new boolean[MAX];         Arrays.fill(flag, true);         eratosthenes(flag, MAX);         for (int i = 2; i &lt; flag.length; i++){             if (flag[i]){                 System.out.println(i + \" is prime number\");             }         }     }      public static void eratosthenes(boolean[] flag, int k){         for (int i = 2; i*i &lt; k ; i++) {             if (flag[i]){                 for (int j = i*i; j &lt; k ; j+=i) {                     flag[j] = false;                 }             }         }     } }   2 is prime number 3 is prime number 5 is prime number 7 is prime number 11 is prime number 13 is prime number 17 is prime number 19 is prime number 23 is prime number 29 is prime number   References   Eratothenes - wikipedia  ","categories": ["Algorithm"],
        "tags": ["Data Structure","Mathematics"],
        "url": "http://localhost:4000/algorithm/eratosthenes-sieve/",
        "teaser":"http://localhost:4000/assets/images/Sieve_of_Eratosthenes_animation.gif"},{
        "title": "전체탐색법(Brute force)",
        "excerpt":"전체탐색법   전체탐색법은 모든 문제해결의 기초가 되는 가장 중요한 설계법 중 하나라고 할 수 있다. 주어진 문제에서 해가 될 수 있는 모든 가능성을 검사하여 해를 구하기 때문에 항상 정확한 해를 구할 수 있다는 점이 장점이다. 하지만 탐색해야할 내용이 너무 많으면 문제에서 제시한 시간 이내에 해결할 수 없다는 점을 유의해야 한다.   하지만 전체탐색을 기반으로 한 다양한 응용들이 있으며, 이러한 응용들을 통하여 탐색 해야할 공간을 배제해 나가면서 시간을 줄일 수 있는 다양한 방법들이 존재하기 때문에 잘 응용하면 많은 문제를 해결할 수 있는 강력한 도구가 될 수 있다. 따라서 전체탐색법을 잘 익혀두면 다른 알고리즘 설계법을 학습하는데 많은 도움이 된다.   전체탐색법은 선형구조의 탐색, 비선형구조의 탐색을 기반으로 하여 문제를 해결한다.   선형구조와 비선형구조의 전체탐색   선형구조의 전체탐색은 반복문을 이용하여 접근할 수 있다.  1차 원 뿐만 아니라 2차원 이상의 다차원 구조에 대해서도 선형구조로 탐색할 수 있다.   비선형구조의 전체탐색은 문제해결의 가장 기본이 되는 알고리즘 설계법인 백트래킹을 이용한다.  백트래킹 기법은 재귀함수를 이용하여 간단하게 구현할 수 있고, 다양한 문제를 해결하는데 많이 응용되는 방법이므로 반드시 익혀둘 필요가 있다.   주어진 문제들을 통하여 선형구조, 비선형구조의 전체탐색법을 익힐 수 있도록 하자.   선형 구조에서의 전체탐색   약수의 합   한 정수 n을 입력받아서 n의 모든 약수의 합을 구하는 프로그램을 작성하시오.  예를 들어 10의 약수는 1, 2, 5, 10이므로 이 값들의 합인 18이 10의 약수의 합이 된다.  입력 첫 번째 줄에 정수 n이 입력된다. (단, 1 &lt;= n &lt;= 100,000)  출력 n의 약수의 합을 출력한다. ------------------- 입력 예 10  출력 예 18   이 문제는 기본적으로 수학적인 아이디어를 이용하여 해결할 수 있는 문제이지만 이 단 원에서는 전체탐색법을 다루는 단원이므로 전체탐색법으로 해결해보자.   일단 n을 입력받으면 1부터 n까지의 모든 수를 차례로 반복문을 이용하여 선형으로 탐색하면서 n의 약수들을 검사한다. 만약 현재 탐색 중인 수가 n의 약수라면 누적하여 구할 수 있다. 이렇게 구한다면 계산량은 O(n)이 된다. 이 문제에서는 n의 최댓값이 100,000이므로 충분히 해결할 수 있는 문제가 된다.   어떤 수 x가 n의 약수라면 다음 조건을 이용해 구할 수 있다.   n % x == 0   이를 이용하여 문제를 해결한 소스코드는 다음과 같다.   #include &lt;stdio.h&gt; int n; int solve() {     int ans=0;     for(int i=1; i&lt;=n; i++ )         if(n%i==0)             ans+=i;     return ans; }  int main() {     scanf(\"%d\", &amp;n);     printf(\"%d\\n\", solve()); }   이문제는 이와 같은 방법으로 쉽게 해결할 수 있으나, n이 10억 이상의 값으로 커질 때는 다른 방법을 생각해야 한다.  아마 다른 포스트에서 다루게 될 것이므로 한 번 생각해보자.   최댓값   다음과 같이 9×9 격자판에 쓰여진 81개의 자연수가 주어질 때, 이들 중 최댓 값을 찾고 그 최댓값이 몇 행 몇 열에 위치한 수인지 구하는 프로그램을 작성하시오.  예를 들어, 다음과 같이 81개의 수가 주어질 경우에는 이들 중 최댓값은 90이고, 이 값은 5행 7열에 위치한다.    열 1  2  3  4  5  6  7  8  9 행 1    3 23 85 34 17 74 25 52 65 2   10  7 39 42 88 52 14 72 63 3   87 42 18 78 53 45 18 84 53 4   34 28 64 85 12 16 75 36 55 5   21 77 45 35 28 75 90 76  1 6   25 87 65 15 28 11 37 28 74 7   65 27 75 41  7 89 78 64 39 8   47 47 70 45 23 65  3 41 44 9   87 13 82 38 31 12 29 29 80  입력 첫째 줄부터 아홉째 줄까지 한 줄에 아홉 개씩 자연수가 주어진다. 주어지는 자연 수는 100보다 작다.  출력 첫째 줄에 최댓값을 출력하고, 둘째 줄에 최댓값이 위치한 행 번호와 열 번호를 빈칸을 사이에 두고 차례로 출력한다. 최댓값이 두 개 이상인 경우 그 중 한 곳의 위치를 출력한다. ---------------------------- 입력 예 3 23 85 34 17 74 25 52 65 10 7 39 42 88 52 14 72 63 87 42 18 78 53 45 18 84 53 34 28 64 85 12 16 75 36 55 21 77 45 35 28 75 90 76 1 25 87 65 15 28 11 37 28 74 65 27 75 41 7 89 78 64 39 47 47 70 45 23 65 3 41 44 87 13 82 38 31 12 29 29 80  출력 예 90 57    이 문제는 2차원 구조를 선형으로 모두 탐색하면 쉽게 해결할 수 있는 문제이다.  2차원 구조는 행 우선으로 탐색하는 방법과 열 우선으로 탐색하는 방법이 있는데, 이 문제는 어떤 방법으로 탐색해도 관계없으며, 일반적으로는 행 우선 탐색을 많이 사용한다.   다음은 행 우선을 반복문으로 구현한 소스코드이다.   for(int row=0; row&lt;5; row++) {     for(int col=0; col&lt;4; col++)         printf(\"[%d, %d]\", row, col);     uts(\"\"); }   이제 문제를 해결하는 방법에 대해서 알아보자.   탐색하기 전 먼저 해를 저장할 변수인 ans를 0으로 초기화한다. 여기서 주의할 점은 각 원소들 중 음수값이 존재할 경우 최댓값을 구하기 위해 ans를 0으로 초기화하면 안 된다는 점이다. 이 문제는 음수값이 존재하지 않기 때문에 ans를 0으로 초기화하고 문제를 해결한다.   참고로 어떤 변수에 값을 초기화하는 몇 가지 방법을 소개한다. 일단 int형의 최댓값은 0x7fffffff(2,147,483,647)이며, 최솟값은 0x80000000(-2,147,483,648)이다. 엄밀하게 최대, 최소를 지정할 때 이 값을 이용하면 되며, 16진법을 이용하면 쉽게 처리할 수 있다.   여기서 주의할 점은 위 값들을 설정한 후 값을 증가시키거나 감소시키면 오버플로 (overflow)로 인하여 답이 잘못될 수 있다.  예를 들어 다음 명령을 보자.   int max = 0x7fffffff; max=max+1;   위 예의 경우에 max값이 최댓값이었는데, 여기서 1을 증가하면 오버플로가 발생하 여 max값은 음수가 된다.  따라서 이런 점을 방지하기 위하여 적어도 2배 정도라 하더 라도 오버플로가 발생하지 않도록 처리하는 경우가 많다.  이럴 때는 주로 최댓값을 987654321 등의 자릿수도 쉽게 알 수 있고 2배를 하더라도 정수 범위에 있는 수 등을 활용하는 경우가 많다. 문제에 따라서는 탐색하고자 하는 데이터 중에서 임의의 한 값 을 최댓값 또는 최솟값으로 결정하는 방법도 있다.   위 문제를 해결하는 소스코드는 다음과 같다.   #include &lt;stdio.h&gt; int A[10][10], ans, mi, mj; void input() {     for(int i=0; i&lt;9; i++)         for(int j=0; j&lt;9; j++)         scanf(\"%d\", &amp;A[i][j]); } int solve() {     for(int i=0; i&lt;9; i++)         for(int j=0; j&lt;9 ; j++)             if(ans &lt; A[i][j]) {                 ans=A[i][j];                 mi=i+1; mj=j+1;             } } int main() {     input();     solve();     printf(\"%d\\n%d %d\\n\", ans, mi, mj);     return 0; }   가장 일반적으로 해결할 수 있는 방법이고 이 경우 계산량은 O(row x column)이 된다.  이를 보다 효율적으로 바꾸기 위해서, 입력받으면서 바로 처리할 수도 있으며, ans, mi, mj를 모 두 쓰지 않고 mi, mj만 가지고 처리하는 방법을 소개한다.   #include &lt;stdio.h&gt; int A[10][10], mi, mj; void input_solve() {     for(int i=0; i&lt;9; i++)         for(int j=0; j&lt;9; j++) {             scanf(\"%d\", &amp;A[i][j]);             if(A[mi][mj]&lt;A[i][j])                 mi=i, mj=j;         } } int main() {     printf(\"%d\\n%d %d\\n\", A[mi][mj], mi+1, mj+1);     return 0; }   고기잡이   우리나라 최고의 어부 정올이가 이번에 네모네모 배 고기잡이 대회에 참가한다.  이 대회에는 3개의 라운드가 있는데, 첫 번째 라운드는 1차원 형태로 표현될 수 있는 작은 연못에서 길쭉한 그물을 던져서 최대한 많은 고기를 잡는 것이 목적이다.  1라운드의 예를 들면 연못의 크기가 1*6이고 물고기의 위치와 가치가 다음과 같다고 하자.  1 0 2 0 4 3  여기서 그물의 크기는 1*3이라고 할 때, 잡을 수 있는 방법은 (1 0 2), (0 2 0), (2 0 4), (0 4 3)의 4가지 방법이 있다.  이 중 가장 이득을 보는 방법은 마지막 방법 0 + 4 + 3 = 7이다. 따라서 주어진 경우의 최대 이득은 7이 된다. 정올이는 최대한 가치가 큰 물고기를 잡아서 우승하고 싶어 한다.  연못의 폭과 각 칸에 있는 물고기의 가치, 그물의 가로의 길이와 세로의 길이가 주어질 때, 잡을 수 있는 물고기의 최대이득을 구하는 프로그램을 작성하시오.  입력 첫 번째 줄에 연못의 폭 N이 입력된다. ( N &lt;= 100 인 자연수 ) 두 번째 줄에 그물의 폭 W가 입력된다. ( W &lt;= N 인 자연수 ) 세 번째 줄 W개의 물고기의 가치가 공백으로 구분되어 주어진다. 각 물고기의 가 치는 7이하의 자연수이다. 0일 경우에는 물고기가 없다는 의미이다.  출력 잡을 수 있는 물고기의 최대 가치를 출력한다. --------------------------------- 입력 예 6 3 1 0 2 0 4 3  출력 예 7   이 문제는 전체탐색법을 이용하여 간단하게 해결할 수 있다.  폭이 n인 연못에서 폭이 w인 그물을 던졌을 때 최대 이득을 얻을 수 있는 구간을 찾는 문제이다.  가장 단순한 방 법으로 n개의 주어진 수들 중 연속된 w개의 수들을 탐색하여 합을 구한 다음 최댓값을 갱신하는 방법으로 접근할 수 있다.  먼저 첫 번째 데이터부터 탐색하여 w개의 합을 구한 다음 최댓값을 갱신하고, 두 번째 데이터부터 탐색하여 w개의 합을 구하여 최댓값을 갱신한다. 이런 방법으로 모든 구간을 전체탐색법으로 확인할 수 있다.   입출력 예의 경우 다음과 같은 과정으로 해를 구해나간다.      위의 과정을 보면 탐색을 시작하는 지점이 0번으로부터 시작하여 1씩 증가하는 것을 알 수 있으며, 시작점을 지정하면 그물의 폭인 w만큼 탐색을 진행한다. 따라서 마지막 탐색 의 시작 지점은 n - w + 1 이 된다. 핵심 탐색 부분을 구현하면 다음과 같다.   for(int i=0; i&lt;N‐W+1; i++) {     for(int j=0; j&lt;W; j++)         printf(\"%d \", i+j);     puts(\"\"); }   n = 8 이고 w = 5 일 때, 위 탐색방법의 출력결과는 결과는 다음과 같다.   0 1 2 3 4 1 2 3 4 5 2 3 4 5 6 3 4 5 6 7   즉, [0, 4] 구간, [1, 5]구간, [2, 6]구간, [3, 7]구간으로 모두 4번을 검사한다.   위 소스코드에서 n - w + 1 을 생각하기 어려운 경우에는 배열을 좀 더 크게 잡은 후 다음과 같이 작성해도 관계없다.   for(int i=0; i&lt;N; i++) {     for(int j=0; j&lt;W; j++)         printf(\"%d \", i+j);     puts(\"\"); }   위와 같이 작성하면 생각하기 쉽기 때문에 빠른 시간에 코딩이 가능하다. 위의 코드의 출력결과는 다음과 같다.   0 1 2 3 4 1 2 3 4 5 2 3 4 5 6 3 4 5 6 7 4 5 6 7 8 5 6 7 8 9 6 7 8 9 10 7 8 9 10 11   위의 아이디어 들을 이용하여 문제를 해결한 소스코드는 다음과 같다.   #include &lt;stdio.h&gt; int data[101], N, W, ans = 0; int main() {     scanf(\"%d%d\", &amp;N, &amp;W);     for(int i=0; i&lt;N; i++)         scanf(\"%d\", data+i);      for(int i=0; i&lt;N+W‐1; i++) {         int sum=0;         for(int j=0; j&lt;W; j++)             sum+=data[i+j];         if(sum&gt;ans) ans=sum;     }     printf(\"%d\", ans); }   이 알고리즘의 계산량은 1~N의 각 위치에 대해서 W만큼 탐색을 하므로 O(NW)가 됨 을 알 수 있다.  문제에서 제시한 N의 최대치가 100,000이 입력되고 그물의 크기가 적당히 크면 수행시 간이 많이 걸리므로 좀 더 효율적인 알고리즘이 필요하다.   비선형 구조에서의 전체탐색   계단 오르기   길동이는 n개의 단으로 구성된 계단을 오르려고 한다. 길동이는 계단을 오를 때 기분에 따라서 한 번에 1단 또는 2단을 올라갈 수 있다. 계단의 크기 n이 주어질 때, 길동이가 이 계단을 올라갈 수 있는 모든 경우의 수를 구하는 프로그램을 작성하시오.  만약 계단이 3개라면 길동이는 1, 1, 1로 올라가는 법과 1, 2로 올라가는 법, 2, 1로 올라가는 법의 3가지 서로 다른 방법이 있다. ----------------------------------------- 입력 계단의 수 n이 입력된다(단 n은 20보다 작은 자연수).  출력 길동이가 계단을 오르는 모든 방법의 수를 출력한다.  입력 예         출력 예 3              3    이 문제도 비선형구조로 전체탐색을 하여 해를 구할 수 있다.  현재 상태에서 1칸 또는 2 칸을 올라갈 수 있으므로, 탐색구조를 다음과 같이 설정할 수 있다.   단, 주의할 점은 정확 하게 n칸에 도착했을 때만 한 가지 경우로 처리해야한다는 점이다.  예를 들어 도착점까지 한 칸 남았을 경우에는 2칸을 올라갈 수 없다.      위의 탐색 과정으로 5칸의 계단을 오르는 과정을 보면 다음과 같다.      위와 같은 트리를 구성하면서 전체탐색을 하면 n은 5일 때, 방법은 8임을 알 수 있다.  이와 같은 구조의 탐색을 소스코드로 구현하면 다음과 같다.   #include &lt;stdio.h&gt; int n, ans; void solve(int v) {     if(v&gt;n) return; // --- (a)     if(v==n){ // 현재 n칸이면         ans++;         return;     }     solve(v+1); // 1칸 오르기     solve(v+2); // 2칸 오르기 } int main() {     scanf(\"%d\", &amp;n);     solve(0);     printf(\"%d\\n\", ans); }   Warning: (a)행의 조건은 마지막 계단을 넘어가는 경우를 처리한다. 이 구문이 없으면 무한 재귀에 빠지게 된다.   거스름 돈   여러분은 실력을 인정받아 전 세계적으로 사용할 수 있는 자동판매기용 프로그램의 개발을 의뢰받았다. 거스름돈에 사용될 동전의 수를 최소화하는 것이다.  입력으로 거슬러 줘야할 돈의 액수와 그 나라에서 이용하는 동전의 가짓수 그리고 동전의 종류가 들어오면 여러 가지 방법들 중 가장 적은 동전의 수를 구하는 프로그램을 작성하시오.  ----------------------------------------- 입력 첫 번째 줄에는 거슬러 줘야할 돈의 액수 m이 입력된다. ( 10 &lt;= m &lt;= 10,000 ) 다음 줄에는 그 나라에서 사용되는 동전의 종류의 수 n이 입력된다. ( 1 &lt;= n &lt;= 10 ) 마지막 줄에는 동전의 수만큼의 동전 액수가 오름차순으로 입력된다. ( 10 &lt;= 액수 &lt;= m )  출력 최소의 동전의 수를 출력한다.  입력 예 730 5 10 50 100 500 1250  출력 예 6   이 문제는 매우 잘 알려진 유명한 문제 중 하나로 다양한 방법으로 해결할 수 있는 대표적인 문제이다. 이 단원에서는 전체탐색법을 기반으로 하여 해결하는 방법에 대해서 소개한다. 대부분의 문제들에서도 마찬가지지만 문제를 전체탐색으로 구조화하는 방법에 따라 해법의 계산량이 달라질 수 있다.   이 문제에서는 2가지 서로 다른 구조화로 해결하는 방법을 소개한다. 먼저 첫 번째 방법은 문제의 상태를 지금까지 지불한 액수로 설정하고, 서로 다른 동전 1개를 이용하여 지불하는 경우를 간선으로 생각할 수 있다.   이 방법으로 구조화하는 방법은 다음 그림과 같다. 이 때 $x$의 값은 지금까지 지불한 액수이며 사용 가능한 동전은 4가지 종류로 10원, 50원, 100원, 500원일 때를 가정한 것이다.      처음에 0원으로 출발하여 각 동전을 지불해 나가며, 지불할 금액과 일치할 때의 깊이가 지불한 동전의 개수이므로, 지불할 금액과 일치하는 최소 깊이를 구하는 문제가 된다. 만약 지불할 금액과 일치했거나 금액을 초과했을 경우에는 백트랙하면서 탐색을 진행하도록 코드를 작성하면 된다.   지불해야할 금액이 120원이고, 사용가능한 동전이 30원, 50원, 60원, 100원일 때의 전체 탐색구조는 다음과 같다. 먼저 처음 깊이 1까지의 구조이다.      다음은 30원 이하의 정점들의 전체적인 구조이다. 파란색 정점은 120원 지불에 성공한 것을 나타낸다.      계속해서 50원과 60원 정점의 전체 탐색구조를 나타낸다. 100원 이하에서는 더 이상의 탐색이 불가능하다.      #include&lt;stdio.h&gt; int m, n, coin[10], ans=987654321; void solve(int mon, int d) {     if(mon&gt;m) return;     if(mon==m){         if(d&lt;ans) ans=d;         return;     }     for(int i=0; i&lt;n; i++)         solve( mon+coin[i], d+1 ); } int main() {     scanf(\"%d %d\", &amp;m, &amp;n);     for(int i=0; i&lt;n ; i++ )         scanf(\"%d\", coin+i);     solve(0, 0);     printf(\"%d\\n\", ans);     return 0; }   위 프로그램에서의 solve()함수는 다음과 같은 상태를 표현하고 있다.   solve(mon, d) = “d개의 동전으로 mon원을 사용한 상태”   이 방법은 정확하게 해를 구할 수는 있으나 이론상으로 최대 금액이 10,000원이고 최소 액수가 10원이므로 최대 깊이가 1,000까지 갈 수 있기 때문에 시간 내에 해결할 수 없다.   시간을 줄이기 위한 다양한 방법이 있지만, 이번에는 다른 구조를 이용하여 해결할 수 있는 방법을 소개한다. 탐색구조를 어떻게 설계하느냐에 따라서 해법의 계산량이 달라질 수 있다는 것을 알고, 문제를 해결할 때, 탐색구조를 어떻게 구성해야하는지 먼저 고민하는 것이 중요하다.   이번에 소개하는 구조는 이전과는 달리 같은 깊이에서는 같은 동전으로만 지불하는 방법으로 구조를 구성한다. 한 깊이에서 간선의 수는 해당 깊이의 동전을 0개로부터 해당 금액을 최대한 지불할 수 있는 최대한의 수로 설정하여 진행한다. 다음 그림을 통하여 자세히 알아보자. 동전은 30원, 50원, 60원, 100원이다.      실제 지불할 금액은 120원, 지불가능한 동전의 수는 50원, 60원, 100원일 때의 경우 전체 구조는 다음과 같다.      이 방법으로 구현한 소스코드는 다음과 같다.   #include &lt;stdio.h&gt; int n, m, coin[10], ans=987654321; void solve(int mon, int k, int cnt) {     if(mon==m){         if(ans&gt;cnt) ans=cnt;         return; // 백트랙     }     if(k==n) return; // 더 이상 깊이 진행 X, 백트랙     for(int i=0; mon+coin[k]*i&lt;=m; i++) // 조건 만족하지 않을 시 백트랙         solve(mon+coin[k]*i, k+1, cnt+i); } int main() {     scanf(\"%d %d\", &amp;m, &amp;n);     for(int i=0; i&lt;n; i++)         scanf(\"%d\", coin+i);     solve(0, 0, 0);     printf(\"%d\\n\", ans);     return 0; }   위 프로그램에서의 solve()함수는 다음과 같은 상태를 표현하고 있다.   solve(mon, k, cnt )= “k번째 이하의 동전을 cnt개 사용하여 mon원을 거슬러 준 상태”   이 방법은 앞에서 시도했던 방법보다 속도가 획기적으로 빨라진다. 그 이유는 전체 상태를 그려보면 앞의 방법보다 이번에 구조화한 방법의 정점의 수가 훨씬 적기 때문이다. 이와 같이 구조를 어떻게 설계하느냐에 따라 알고리즘의 계산량이 달라지기 때문에, 문제를 해결할 때 먼저 최적의 구조를 설계하는 것이 중요하다.   연구활동 가는 길      *위의 그래프를 참고하여 문제를 풀어보자*  정올이는 GSHS에서 연구활동 교수님을 뵈러 A대학교를 가려고 한다. 출발점과 도착점을 포함하여 경유하는 지역 n개, 한 지역에서 다른 지역으로 가는 방법이 총 m 개이며 GSHS는 지역 1이고 A대학교는 지역 n이라고 할 때 대학까지 최소 비용을 구하시오.  단, n은 10 이하, m은 30 이하, 그리고 한 지역에서 다른 지역으로 가는 데에 필요한 비용은 모두 200 이하 양의 정수이며 한 지역에서 다른 지역으로 가는 어떠한 방법이 존재하면 같은 방법과 비용을 통해 역방향으로 갈 수 있다.  위의 그래프는 예를 보여준다. (단, 정점 a -&gt; 정점 b로의 간선이 여러 개 있을 수 있으 며, 자기 자신으로 가는 정점을 가질 수도 있다.)  최소 비용이 드는 경로 : 1→3→5→7, 최소 비용 : 69+59+21=149  입력 첫 번째 줄에는 정점의 수 n과 간선의 수 m이 공백으로 구분되어 입력된다. 다음 줄부터 m개의 줄에 걸쳐서 두 정점의 번호와 가중치가 입력된다. (자기 간선, 멀티 간선이 있을 수 있다.)  출력 대학까지 가는 데 드는 최소 비용을 출력한다. 만약 갈 수 없다면 “-1”을 출력.  ---------------------------- 입력 예 7 11 1 2 47 1 3 69 2 4 57 2 5 124 3 4 37 3 5 59 3 6 86 4 6 27 4 7 94 5 7 21 6 7 40  출력 예 149    이 문제는 그래프 상의 최단경로를 구하는 매우 유명한 문제이다.  이 문제를 해결하는 알고리즘은 여러가지가 알려져 있지만, 어려운 알고리즘을 모르더라도 전체탐색법을 통하여 해결할 수 있다.   이 문제는 그래프 구조이므로 비선형탐색법으로 해를 구할 수 있다.  먼저 출발정점에서 깊이우선탐색을 이용하여 출발점으로부터 도착점까지 가능한 모든 경로에 대해서 구해본다.   하나의 경로를 구할 때마다 해를 갱신하면서 최종적으로 가장 적합한 해를 출력한다.  주어진 예를 통하여 전체탐색하는 과정을 간단하게 살펴보자.            Warning: 중간에 몇개의 과정이 생략되었음에 유의      따라서 위의 경우 전체탐색법으로 탐색한 결과 최소 이동거리는 149가 됨을 알 수 있다.  위의 과정과 같은 방법으로 코딩한 결과는 다음과 같다.   #include&lt;stdio.h&gt; int n, m, G[11][11], sol = 0x7fffffff, chk[11]; void solve(int V, int W) {     if(V==n){ // 도착 여부를 확인하여 현재 정점이 도착점이라면         if(W&lt;sol) sol=W; // 더 좋은 해가 있으면 해를 갱신             return; // 백트랙     }     for(int i=1; i&lt;=n; i++)         if(!chk[i] &amp;&amp; G[V][i]) {             chk[i]=1; // 다음 정점으로 진행할 때 다음 방문할 정점을 체크             solve(i, W+G[V][i]); // 다음 정점으로 진행             chk[i]=0; // 백트랙해서 돌아오면 체크를 해제         } }  int main(void) {     scanf(\"%d %d\", &amp;n, &amp;m);     for(int i=0; i&lt;m; i++) {         int s,e,w;         scanf(\"%d %d %d\", &amp;s, &amp;e, &amp;w);         G[s][e]=G[e][s]=w;     }     solve(1, 0);     printf(\"%d\\n\", sol==0x7fffffff ? ‐1:sol);     return 0; }   이 문제의 경우 정점과 간선의 수가 많지 않으므로 인접행렬로도 충분히 처리가 가능하기 때문에 인접행렬로 처리한다.  solve(a, b)는 현재 a정점까지 방문한 상태로 이동거리가 b라고 정의하고 있으며, chk배 열이 현재까지 방문한 정점들의 정보를 가지고 있다.  다음 정점으로 진행할 때 chk[i]=1 같이 chk배열에 다음 방문할 정점을 체크하고 만약 백트랙해서 돌아온다면, chk[i]=0 같이 체크를 해제하며 전체탐색을 진행한다.   if(V==n) 부분에서 도착 여부를 확인하여 현재 정점이 도착점이라면, 지금까지의 이동 거리와 현재 까지 구한 해를 비교하여 더 좋은 해가 있으면 해를 갱신한다. 이와 같이 작성할 경우 도시의 수가 n개라고 할 때 O(n!)의 계산이 필요하다.   다른 포스트에서 탐색배제를 이용하여 계산복잡도를 향상해본다.   References      문제해결을 위한 창의적 알고리즘  ","categories": ["Algorithm"],
        "tags": ["DFS","BFS","Data structure","programming","Brute force"],
        "url": "http://localhost:4000/algorithm/%EC%A0%84%EC%B2%B4%ED%83%90%EC%83%89%EB%B2%95/",
        "teaser":"http://localhost:4000/assets/images/creativealgorithm25.png"},{
        "title": "탐색공간의 배제(Exclusion of Search Space)",
        "excerpt":"Notice: 이 글은 전체탐색법의 후행 내용으로서, 먼저 제 블로그의 전체탐색법을 보시고 이 포스트를 보시는 것을 추천드립니다!   탐색공간의 배제   전체탐색법은 대부분의 경우 해를 구할 수 있는 알고리즘이다. 하지만 실행시간이 너무 길어 제한 시간 내에 문제를 해결할 수 없는 경우가 많다. 탐색공간의 배제는 전체탐색 알고리즘을 구현하는 데 있어서 더 이상 탐색하지 않더라도 해를 구하는 데 문제가 없는 부분을 판단하여 이 부분에 대해서 탐색을 하지 않으므로 탐색의 효율을 높이고자 하는 방법이다.   탐색공간의 배제는 전체탐색에서 불필요한 탐색공간을 탐색하지 않음으로써 알고리즘의 효율을 향상시킨다. 이와 같이 탐색공간을 배제하는 방법은 다양하며 가장 기본 전략은 전체탐색설계와 같이 탐색으로 시작하여 모든 공간을 탐색하는 것이 아니라 일정한 조건을 두어 탐색영역을 배제하는 것이다.   배제되는 탐색공간의 크기에 따라 알고리즘의 성능의 향상 폭이 달라진다. 하지만 잘못 설계를 하여, 해가 있는 상태를 배제하면 해를 구할 수 없는 경우가 발생한다. 따라서 탐색 영역을 배제할 때는 엄밀한 수학적 접근이 필요하다. 이 설계방법은 탐색영역을 배제하는 방법에 따라서 수학적 배제, 경험적 배제, 구조적 배제로 나눌 수 있다.   각 방법에 대해서 자세히 알아보자.   수학적 배제를 이용한 설계   탐색 공간 중 배제할 영역을 수학적 증명으로 결정하는 방법으로는 이분탐색 알고리즘 이 있다. 이는 일종의 수학적 배제를 이용하여 탐색공간을 줄여나가는 알고리즘 설계방법 이라고 할 수 있다.   오름차순으로 정렬된 상태의 이분탐색에서 현재 탐색한 값이 목표하는 값보다 작다면, 현재 탐색 위치의 왼쪽 영역에는 해가 존재할 가능성이 없다. 이는 수학적으로 쉽게 증명 할 수 있다.   따라서 왼쪽 영역에 대해서는 탐색할 필요가 없음을 알 수 있다. 그러므로 다음 탐색영역은 이를 배제하고 오른쪽 영역만 탐색하는 방법이다. 이와 같이 수학적으로 탐색할 필요가 없음이 증명된 공간들을 배제해 나가며 탐색하는 것과 같은 접근법이 수학적 배제를 이 용한 방법이라고 할 수 있다.   수학적 배제로 알고리즘을 설계할 경우, 공간을 배제할 원리를 수학적으로 증명한 후, 이 방법을 반복적으로 해를 찾을 때까지 적용해 나가며 해를 찾는다. 탐색공간에서 선택 배제된 부분은 수학적으로 탐색할 필요가 없으므로, 일반적으로 탐색법이긴 하지만 백트랙 없이 선형으로 진행되는 경우가 많다.   수학적으로 공간을 배제해 나가는 이 방법은 일종의 탐욕법(greedy)이라고 할 수 있으며, 엄밀하게 수학적으로 증명을 하기 때문에 수학적 탐욕법(mathematical greedy)라고 할 수 있다.   하지만 수학적 증명 없이, 직관적으로 현재 상태만으로 잘못된 판단을 하게 되면 올바른 해를 구할 수 없는 가능성을 가지는 단순 탐욕법이 될 수 있으므로 주의해야 한다. 하지만 단순 탐욕법의 경우에도 다양한 응용법이 있으므로 다음에 다루도록 한다.   다음 예는 루트 정점에서 출발하여 각 정점의 값을 누적하며 마지막 정점까지의 합을 최대화하는 최적화문제이다. 이 문제의 목적은 값을 최대화 하는 것이므로 다음 [영역배제의 규칙]을 적용하여 탐색 영역을 배제해 나가보자.   영역배제의 규칙: 현재 상태에서 다음으로 탐색할 수 있는 정점들 중 더 높은 점수가 있는 정점으로 탐색한다.  (즉, 더 작은 점수가 있는 정점의 영역을 배제한다.)   이 규칙은 수학적으로 설득력이 있어 보인다. 왜냐하면 값을 최대화하기 위해서는 작은 값보다는 큰 값이 이득이 되기 때문이다. 하지만 엄밀한 수학적 증명은 하지 않았다. 이 방법으로 탐색을 진행하는 과정은 다음과 같다.      처음 출발점이 루트이므로 루트에 적힌 3점을 획득하여 현재 점수는 3점이다.  다음으로 이동할 수 있는 정점들은 왼쪽 아래로 연결된 8점이 기록된 정점과 오른쪽 아래로 연결된 2점이 기록된 정점의 2가지이다. 이 상태에서 [영역배제의 규칙]을 적용하여 값이 더 큰 8점이 기록된 정점을 선택하고 2점이 기록된 정점을 배제하고 진행한다.      이 규칙을 적용하여 마지막까지 탐색한 결과는 위 그림에서 구한 해는 3-8-4-5를 선택하게 되며 이 때 얻은 점수는 3+8+4+5 이 된다. 과연 20점 이상을 획득할 수 있는 경로는 존재하지 않을까? 다음 그림을 보자.      위 결과를 보면 알 수 있듯이 3+2+9+8=22의 경로가 존재하며 앞 에서 영역을 배제했던 규칙이 잘못됐음을 알 수 있다. 수학적 배제는 엄밀한 수학적 접근 없이, 단순히 직관적으로 배제의 규칙을 결정하면 최적해를 구할 수 있음을 보장할 수 없다. 하지만 구현이 간단하며, 일반적으로 최적해와의 차이가 크지 않은 해를 구할 수 있다는 장점을 이용하여 다른 설계법에 응용할 수 있으므로 나중에 다시 살펴보기로 하자.   주어진 문제들을 통하여 수학적 배제 방법으로 알고리즘을 설계해보자.   약수의 합   한 정수 n을 입력받아서 n의 모든 약수의 합을 구하는 프로그램을 작성하시오.    예를 들어 10의 약수는 1, 2, 5, 10이므로 이 값들의 합인 18이 10의 약수의 합이 된다.    입력   첫 번째 줄에 정수 n이 입력된다. (단, 1 &lt;= n &lt;= 10,000,000,000(100억))    출력   n의 약수의 합을 출력한다. ------------------- 입력 예 10  출력 예 18   이 문제는 전체탐색법 - 약수의 합과 동일한 문제이다. 차이점은 앞의 문제가 입력값의 정의역이 100,000이었던 것에 반해,이 문제에서는 입력값이 100억으로 커졌다는 것이다.   앞의 문제에서 작성했던 풀이는 다음과 같다.   #include &lt;stdio.h&gt; int n; int solve() {     int ans=0;     for(int i=1; i&lt;=n; i++ )         if(n%i==0)             ans+=i;     return ans; }  int main() {     scanf(\"%d\", &amp;n);     printf(\"%d\\n\", solve()); }   이 소스코드는 1부터 n까지의 모든 원소들을 탐색하여, 탐색 대상인 수 i가 n의 약수 라면 취하는 방식으로 진행된다.  따라서 계산량은 O(n)이다.   이번 문제는 n의 최댓값이 100억이므로 이 방법으로는 너무 많은 시간이 걸린다. 따라서 탐색영역을 배제해야 할 필요가 있다.   먼저 간단한 수학적인 원리들을 생각해보자. 먼저 다음 정리를 이용하자.   모든 자연수 n에 대하여 1과 n은 항상 n의 약수이다.  이 원리를 이용하면 위 소스코드의 8행의 탐색범위를 줄여서 다음과 같이 표현할 수 있다.   for(int i=2; i&lt;n; i++)    if(n%i==0)     ans+=i;   원래 소스코드보다 탐색공간이 줄어들긴 했으나 효율을 높이기에는 너무 미미하기 때문에 효율향상을 느낄 수 없다. 하지만 위 아이디어를 조금 응용하면 탐색공간을 많이 줄일 수 있다.   위 아이디어를 응용하기 위해서 다음 원리를 적용할 수 있다.   모든 자연수 n에 대하여, 2이상 n미만의 자연수들중 가장 큰 n의 약수는 n/2를 넘지 않는다.  이 원리를 적용하면 다음과 같이 탐색영역을 줄일 수 있다.   for(int i=2; i&lt;n/2; i++)    if(n%i==0)     ans+=i;   이 알고리즘은 탐색영역이 처음의 소스코드의 반이하로 줄어든 것이다. 따라서 실행시간 은 2배 이상 빨라질 것을 예상할 수 있다.   수학적인 아이디어로 탐색 영역을 반 정도 줄였지만 아직도 매우 큰 입력 값을 처리하기에는 시간이 너무 오래 걸린다. 탐색 공간을 더 배제할 수 있는 아이디어를 생각해보자.   임의의 자연수 n의 약수들 중 두 약수의 곱은 n되는 약수 a와 약수 b는 반드시 존재한 다. 단, n이 완전제곱수일 경우에는 약수 a와 약수 b가 같을 수 있다. 자연수 10의 약수를 통해서 알아보자. 자연수 10의 약수의 개수는 4개이며 다음과 같다.   { 1, 2, 5, 10}   위 집합을 살펴보면 아래와 같은 관계를 찾을 수 있다.        |--| { 1, 2, 5, 10}   |_________|     10의 약수 관계   위 그림에서 알 수 있듯이 1과 10의 곱은 10이고 2와 5의 곱은 10이다. 약수의 개수를 $c$개라고 하고, $d_i$를 $n$의 약수 중 $i$번째 약수라 하면 다음과 같은 식이 성립한다.   Expression: $ n = d_k * d_{c-k+1}$   즉, $k$번째 원소와 $c-k+1$번째 원소의 곱은 항상 $n$이다. 이 원리를 적용하면 10의 약수 를 구할 때, 1과 2만 탐색하면 5와 10을 알 수 있으므로 모든 약수를 구할 수 있다.   단, $n$이 완전제곱수 일 경우에는 약수의 개수가 홀수이므로 $d_k$번째 원소와 $d_{c-k+1}$번째 원소가 같을 경우가 한 건 존재한다. 완전제곱수인 16의 약수를 살펴보자.        |-----| { 1, 2, 4, 8, 16}   |____________|      16의 약수 관계   위 그림에서 알 수 있듯이 완전제곱수인 경우에는 $\\lceil{c\\over2}\\rceil$번째 원소는 짝이 없다.  따라서$d_{\\lceil{c\\over2}\\rceil} * d_{\\lceil{c\\over2}\\rceil} = n$이 된다. 즉 4와 4를 곱하여 16을 만들 수 있다.   이 원리를 적용하면 최악의 경우 2부터 $\\sqrt{n}$까지만 탐색하면 모든 약수를 알 수 있다.   즉 100의 모든 약수를 구하려면 2부터 10까지만 조사해 보면 된다.   {2, 3, 4, 5, 6, 7, 8, 9, 10}   이 수들 중 10의 약수인 것만 찾아보면 다음과 같다.  {2, 4, 5, 10}  위 약수들을 이용하여 짝을 찾아서 정리하면 다음과 같다  {2, 4, 5, 10, 20, 25, 50}   여기에 1과 100은 당연히 100의 약수이므로 문제의 해는 다음과 같다.   1 + 2 + 4 + 5 + 10 + 20 + 25 + 50 + 100 = 217   탐색영역을 [2, $\\sqrt{n}$]로 설정할 때 일반적으로 다음과 같이 프로그램을 작성한다.   // include &lt;math.h&gt; for( i = 1 ; i &lt;= sqrt(n) ; i++ ) // 또는 for(i=1;i*i&lt;=n; i++)   이와 같이 간단한 수학적인 아이디어를 활용하면 효율적인 소스코드를 작성할 수 있으 므로 항상 이런 아이디어를 활용할 수 있도록 익혀두자.   이처럼 탐욕적인 방법을 이용하면 큰 범위의 수도 컴퓨터 없이 쉽게 계산할 수 있다. 그런데 이 방법을 프로그래밍으로 표현하기 위해서 주의할 점이 있다.   입력값 n이 100억 이기 때문에 자료형 int로는 이 값을 처리할 수 없다. 따라서 64bit형 정수인 long long int형을 활용해야 된다. 이 방법을 알고리즘으로 표현하면 다음과 같다.   #include &lt;stdio.h&gt; long long int n; long long int solve() {     long long int i, ans = 0;     for(i=1; i*i&lt;n; i++)       if(n%i==0)         ans+=(i+n/i);      if(i*i==n)        ans += i;     return ans; } int main() {   scanf(\"%lld\", &amp;n);   printf(\"%lld\\n\", solve());   return 0; }   소수 구하기   한 정수 n을 입력받는다. n번째로 큰 소수를 구하여 출력한다. 예를 들어 n이 5라면 자연수들 중 소수는 2, 3, 5, 7, 11, 13, ...이므로 구하고자 하는 5번째 소수는 11 이 된다.  ----------------------------------- 입력 첫 번째 줄에 정수 n이 입력된다.   ( 단, 1 &lt;= n &lt;= 100,000 ) 출력 n 이하의 소수들의 합을 구하여 출력한다.  입력 예         출력 예 5 11          77 389  일반적으로 소수를 구하는 방법은 약수가 2개라는 성질을 이용하는 경우가 많다. 이 성질을 이용하여 임의의 정수 $k$가 소수인지 판단하는 알고리즘을 다음과 같이 만들 수 있다.   bool isPrime(int k) {   int cnt=0;   for(int i=1; i&lt;=k; i++)     if(k%i==0) cnt++;   return cnt==2; }  이 방법은 계산량이 O($n$)이므로 효율이 좋지 않다. 결국 $k$번째 소수를 구하는 알고리즘은 O($nk$)정도의 계산량이 요구되므로 원하는 시간 내에 답을 구하지 못할 가능성이 크다.  효율을 높이기 위해서는 탐색공간의 배제가 필요하다. 어떤 아이디어로 탐색공간을 줄 일 수 있을까?   먼저 위 함수는 소수인지 판단하는 함수이며, 소수가 아니라면 약수가 몇 개이건 합성수인 것은 변함이 없으므로, 약수가 2개를 초과한다면 더 이상 탐색할 필요가 없다. 따라서 다음과 같이 isPrime 함수를 수정하여 탐색공간을 줄일 수 있다.   bool isPrime(int k) {   int cnt=0;   for(int i=1; i&lt;=k; i++) {     if(k%i == 0) cnt++;     if(cnt&gt;2) break;   }   return cnt==2; }   이와 같이 처리하면 대부분의 합성수는 매우 빠른 시간 내에 소수가 아님을 판정할 수 있다. 그리고 위 알고리즘을 다음과 같이 표현해도 된다. 각자 코딩스타일에 맞추어 원하는 방법을 익힐 수 있도록 한다.  bool isPrime(int k) {   int cnt=0;   for(int i=1; i&lt;=k &amp;&amp; cnt&lt;=2; i++) {     if(k%i == 0) cnt++;   }   return cnt==2; }  이번에 소스코드는 3행의 반복문의 반복조건을 바꾸어 처리하고 있다. 이렇게 하여 합성수를 빠르게 검사할 수 있지만 결국은 $k$번째 소수를 찾는 것이 목적이므로 소수를 검사할 때는 여전히 많은 시간이 걸린다.   소수를 보다 빠르게 검사할 수 있는 방법은 무엇일까?   다음 명제를 생각해보자.   임의의 자연수 $n$이 소수라면 $n$의 약수는 1과 n만 존재한다.   위 명제를 조금 변경하면 다음과 같은 원리를 생각할 수 있다.   임의의 자연수 $n$이 소수라면 구간 [2, $n-1$]에서 약수는 존재하지 않는다.   따라서 소수 판정 알고리즘을 다음과 같이 줄일 수 있다.   bool isPrime(int k) {   int cnt=0;   for(int i=2; i&lt;k; i++) {     if(k%i == 0) false;   }   return true; }   이 방법도 합성수는 매우 빠르게 판정할 수 있지만 소수 판정은 시간이 많이 걸리는 단점이 있다.   하지만 이 방법으로부터 소수를 매우 빠르게 판정할 수 있는 방법을 만들 수 있다.   주어진 범위에서 약수가 없어야 하므로, 약수의 존재성만 파악하면 된다. 약수의 존재성을 파악하기 위해서 모든 범위를 검사할 필요는 없다. 앞서 약수 문제에서 다루었던 것과 같이 $n$의 약수를 구하기 위해서 탐색을 $\\sqrt{n}$까지만 탐색하면 된다. 소수판정 에서도 이 원리를 그대로 적용할 수 있다. 이 원리를 적용하여 소수 판정 알고리즘을 완성 하면 다음과 같다.   bool isPrime(int k) {   int cnt=0;   for(int i=2; i*i&lt;=k; i++)     if(k%i == 0) return false;   return true; }   이 알고리즘은 매우 빠른 시간에 소수를 판정할 수 있다. O($\\sqrt{n}$)으로 처리할 수 있다. 이 방법보다 더 빠른 방법이 있다. “에라토스테네스의 체”라는 방법을 이용하 면 더 빠른 시간에 $k$번째 소수를 구할 수 있다. “에라토스테네스의 체”는 다음과 같은 단계를 거쳐 소수를 구한다.   준비. 2부터 n까지 차례로 숫자를 쓰고, 2부터 탐색을 시작한다. 1단계. 현재 탐색 중인 수가 지워지지 않았으면 그 수는 소수이다. 2단계. 1단계에서 그 수가 소수이면 그 수의 배수를 모두 지운다. 3단계. 만약 아직 탐색이 끝나지 않았으면 다음 수를 탐색할 준비를 하고 1단계로 간다. 4단계. 지워지지 않은 모든 수는 소수, 지워진 수는 합성수이다.   이 “에라토스테네스의 체”를 이용해도 빠른 시간에 $k$번째 소수를 구할 수 있다.   다음 포스트를 참고하면 좋다. - 에라토스테네스의 체   경험적 배제를 이용한 설계   경험적 배제는 전체탐색법을 기본으로 한 알고리즘 설계 방법이다. 처음 시작은 전체탐색과 마찬가지로 해가 될 수 있는 모든 공간을 탐색해 나간다. 차이점은 특정 조건을 두고, 이 조건을 기준으로 다음 상태를 계속 탐색할지의 여부를 결정 한다.   여기서의 특정 조건이란, 더 이상 탐색하더라도 해를 구할 수 없음을 판단할 수 있는 조건을 말한다. 이 조건의 설정은 알고리즘이 시작될 때는 정할 수 없고, 탐색을 진행하는 중 에 조건을 설정하고, 탐색한 영역이 넓어질수록 상황에 따라 조건이 갱신된다. 따라서 탐색 한 정보, 즉 경험한 정보를 이용해서 배제할 조건을 정하기 때문에 경험적 배제라고 한다.   경험적 배제는 일반적으로 가지치기(branch &amp; bound)라고 한다. 이는 마치 탐색구조를 나무로 비유하고, 탐색하지 않는 분기에 대해서 자르는 것이 마치 나무를 관리할 때 가치 를 쳐내는 것과 유사하여 붙여진 이름이다.   다음과 같은 탐색구조가 가지는 문제가 있다.      위 구조에서 각 번호는 탐색할 순서이다. 만약 2번에서 3번으로 진행하려고 할 때, 3번 정점이 알고리즘에서 설정한 조건을 만족한다면 3번 정점 이하의 모든 정점들을 더 이상 탐색할 필요가 없으며, 바로 9번으로 진행할 수 있다.      위 그림은 더 이상 필요 없음을 판단한 영역을 배제하고 탐색한 결과를 나타낸다. 이는 결과적으로 11회 탐색해야 할 문제를 6회의 탐색으로 동일한 결과를 얻을 수 있기 때문에 알고리즘의 효율을 향상시킬 수 있다.   일반적으로 더 이상 탐색할 정점이 없어서 되돌아오는 것을 백트랙 or 백트래킹(Backtracking)이라고 한다. 하지만 위의 예와 같이 3번 정점에서 되돌아 온 흐름은 백트랙과는 다르다.  이렇듯 어떤 조건에 의해서 더 탐색할 공간이 있음에도 불구하고 돌아오는 흐름을 바운딩(bounding) 혹은 커팅(cutting)라고 한다.   바운딩은 우리가 공을 벽에 던지면 튕겨 나오는 상태를 말한다. 마치 3번 정점이 벽과 같이서 흐름이 튕기는 것처럼 느껴지기 때문에 바운딩이라는 용어를 쓴다. 이 용어를 이해하면 branch &amp; bound라는 이름의 의미를 알 수 있다.   경험적 배제 기법의 핵심은 더 이상 탐색할 필요가 없는 지점을 판단하는 기준을 정하는 것이다. 이 판단의 근거는 일반적으로 탐색 중에 얻을 수 있는 정보를 활용하는 경우가 대부분이다. 앞에서 다루었던 전체탐색법의 예제들 중 분기한정으로 효율을 향상시킬 수 있는 예제를 통하여 조건을 설정하는 방법을 익혀보자.   연구활동 가는 길      *위의 그래프를 참고하여 문제를 풀어보자*  정올이는 GSHS에서 연구활동 교수님을 뵈러 A대학교를 가려고 한다. 출발점과 도착점을 포함하여 경유하는 지역 n개, 한 지역에서 다른 지역으로 가는 방법이 총 m 개이며  GSHS는 지역 1이고 A대학교는 지역 n이라고 할 때 대학까지 최소 비용을 구하시오.  단, n은 10 이하, m은 30 이하, 그리고 한 지역에서 다른 지역으로  가는 데에 필요한 비용은 모두 200 이하 양의 정수이며 한 지역에서 다른 지역으로 가는 어떠한 방법이 존재하면  같은 방법과 비용을 통해 역방향으로 갈 수 있다.  위의 그래프는 예를 보여준다. (단, 정점a-&gt;정점b로의 간선이 여러 개 있을 수 있으 며, 자기 자신으로 가는 정점을 가질 수도 있다.)  최소 비용이 드는 경로 : 1→3→5→7, 최소 비용 : 69+59+21=149  입력 첫 번째 줄에는 정점의 수 n과 간선의 수 m이 공백으로 구분되어 입력된다. 다음 줄부터 m개의 줄에 걸쳐서 두 정점의 번호와 가중치가 입력된다. (자기 간선, 멀티 간선이 있을 수 있다.)  출력 대학까지 가는 데 드는 최소 비용을 출력한다. 만약 갈 수 없다면 “-1”을 출력.  ---------------------------- 입력 예  7 11 1 2 47 1 3 69 2 4 57 2 5 124 3 4 37 3 5 59 3 6 86 4 6 27 4 7 94 5 7 21 6 7 40  출력 예 149    이 문제는 앞에서 전체탐색법으로 이미 해결했던 문제이다. 하지만 여기서 탐색을 배제 할 조건을 설정하여 탐색영역을 줄여보자. 먼저 탐색배제 조건을 설정해야 한다. 이 문제에서는 전체의 최소 이동거리를 구하는 것이므로 탐색 중 임의의 한 경로를 찾았을 때마다 새로운 거리를 구할 수 있으므로 탐색 중 다음과 같은 배제 조건을 설정할 수 있다.   현재 탐색한 거리 &gt; 지금까지 구한최소 경로의 거리  위 조건을 만족할 경우, 더 이상 탐색하지 않더라도 해를 구하는 데 전혀 문제가 없음을 알 수 있다. 이 조건을 적용하여 탐색하는 과정의 일부를 살펴보자.      위와 같은 단계를 거치면서 진행하게 되면 해는 점점 더 좋아지고 커팅의 효율은 더 높아진다.  위의 방법으로 작성한 소스코드는 다음과 같다.   #include &lt;stdio.h&gt; int n, m, G[11][11], sol=0x7fffffff, chk[11]; void solve(int V, int W) {   if(W&gt;sol) return;   if(V==n) {     if(W&lt;ol) sol=W;     return;   }   for(int i=1; i&lt;=n; i++)     if(!chk[i] &amp;&amp; G[V][i]) {       chk[i]=1;       solve(i, W+G[V][i]);       chk[i] = 0;       }    } int main(void) {   scanf(\"%d %d\", &amp;n, &amp;m);    for(int i=0; i&lt;m; i++) {     int s,e,w;     scanf(\"%d %d %d\", &amp;s, &amp;e, &amp;w);      G[s][e]=G[e][s]=w;   }   solve(1, 0);   printf(\"%d\\n\", sol==0x7fffffff ? ‐1:sol);   return 0; }   성능 검증을 하기 위하여 counter이라는 변수를 이용하여 해를 구하기까지 몇 개의 상태를 탐색하는지 카운팅하는 프로그램을 작성하고, 3번의 임의의 입력데이터를 이용하여 테스트를 해 보자.   검증하는 프로그램과 검증 데이터 셋은 다음과 같다.   #include &lt;stdio.h&gt; int n, m, G[11][11], sol=0x7fffffff, chk[11]; int counter; // 추가 void solve(int V, int W) {   if(W&gt;sol) return;   counter++;  // 추가   if(V==n) {     if(W&lt;ol) sol=W;     return;   }   for(int i=1; i&lt;=n; i++)     if(!chk[i] &amp;&amp; G[V][i]) {       chk[i]=1;       solve(i, W+G[V][i]);       chk[i] = 0;       }    } int main(void) {   scanf(\"%d %d\", &amp;n, &amp;m);    for(int i=0; i&lt;m; i++) {     int s,e,w;     scanf(\"%d %d %d\", &amp;s, &amp;e, &amp;w);      G[s][e]=G[e][s]=w;   }   solve(1, 0);      printf(\"%d\\n\", sol==0x7fffffff ? ‐1:sol);   printf(\"[탐색한 정점 수 %d개]\\n\", counter);    return 0; }   다음은 테스트 한 입력데이터 3개이다.   입력 1  5 7 1 2 2 1 3 10 1 4 7 2 5 4 2 3 6 4 5 3 3 5 4  입력 2 5 8 1 2 2 1 3 1 1 4 3  2 5 2 2 3 1 4 5 3 3 5 2  1 5 14  입력 3 7 11 1 2 47 1 3 69 2 4 57 2 5 124 3 4 37 3 5 59 3 6 86 4 6 27 4 7 94  5 7 21  6 7 40    위 3개의 데이터에 대한 결과이다.      다음은 배제된 공간의 비율을 보여준다.      위 표에서 알 수 있듯이 탐색한 정점의 수가 많이 줄어든 것을 알 수 있다. 대략적으로 원래 방법보다는 2배 이상 빨라졌음을 알 수 있다. 이는 데이터의 특성에 따라 달라질 수 있으니 참고하기 바란다.   이와 같은 알고리즘의 효율은 처음에 구한 해가 얼마나 질이 좋은 해인가에 따라 결정된다. 그렇다면 초반에 질이 좋은 해를 어떻게 구할 수 있을까? 앞에서 다룬 내용 중에 단순 탐욕법이라는 것이 있었다. 이는 현재 상태에서 수학적인 검증 없이 가장 유리한 상태만을 탐색하는 방법이다. 이 방법이 최적해를 구할 수는 없지만 비교적 질이 좋은 해를 구할 수 있다는 사실을 다루었다.   따라서 단순 탐욕법을 이용하여 처음에 하나의 해를 구한다. 일반적으로 이 해가 품질이 좋을 확률이 높으므로 이 해를 처음해로 탐색배제 조건의 기준이 된다. 그리고 위 알고리즘을 실행하면 평균적인 효율이 향상될 가능성이 크다.   단순 탐욕법으로 처음 해를 구하는 소스코드를 추가한 알고리즘은 다음과 같다.   #include &lt;stdio.h&gt; int n, m, G[1001][1001], sol, chk[1001], greedy_chk[1001];  void greedy_ans(int V) {   int W=0, t;   greedy_chk[V]=1;    while(V!=n) {     int min=0x7fffffff;     for(int i=1; i&lt;=n; i++)       if(!greedy_chk[i] &amp;&amp; G[V][i] &amp;&amp; G[V][i]&lt;min) {         greedy_chk[i]=1;         min=G[V][i];         t=i;       }     sol+=G[V][t];     V=t;   } }  void solve(int V, int W) {   if(W&gt;sol) return; // bounding (cutting)   if(V==n) {     if(W&lt;sol) sol=W;     return;   }   for(int i=1; i&lt;=n; i++)     if(!chk[i] &amp;&amp; G[V][i]) {       chk[i]=1;       solve(i, W+G[V][i]);       chk[i]=0;     }  }  int main(void) {   scanf(\"%d %d\", &amp;n, &amp;m);   for(int i=0; i&lt;m; i++) {     int s,e,w;     scanf(\"%d %d %d\", &amp;s, &amp;e, &amp;w);     G[s][e]=G[e][s]=w;   }   greedy_ans(1);   solve(1, 0);   printf(\"%d\\n\", sol==0x7fffffff ? ‐1:sol);   return 0; }   위 알고리즘에서 greedy_ans 함수가 처음 해를 단순 탐욕법으로 구하고 있는 과정을 나타낸다. 단순 탐욕법으로 구한 해는 정답이 아닐 가능성이 크지만, 해의 품질이 좋기 때문에 커팅의 조건으로 적합하다. 단순 탐욕법은 이와 같이 다양한 응용이 가능하다.   마지막으로 전체의 효율을 비교한 결과는 다음과 같다.      다음은 배제된 공간의 비율을 보여준다.      이와 같이 원래 알고리즘 보다 4배 이상 효율이 향상되었음을 알 수 있다. 이와 같이 탐색을 배제하는 방법은 정해진 것이 없고, 여기에서 소개한 방법은 가장 기본적인 배제 방법이다.   여기서 소개한 방법 이외에도 다양한 조건을 설정할 수 있으므로 공간을 배제할 방법을 스스로 설정하여 조건을 추가하면 효율이 좋아질 수 있으므로, 항상 창의적인 사고력을 기를 수 있도록 연습하자.  References      문제해결을 위한 창의적 알고리즘  ","categories": ["Algorithm"],
        "tags": ["Backtracking","Greedy","Data structure","Programming","Brute force"],
        "url": "http://localhost:4000/algorithm/%ED%83%90%EC%83%89%EA%B3%B5%EA%B0%84%EC%9D%98-%EB%B0%B0%EC%A0%9C/",
        "teaser":"http://localhost:4000/assets/images/creativealgorithm33.png"},{
        "title": "유니온 파인드(Union Find, Disjoint Set)",
        "excerpt":"Union-Find  컴퓨터 과학에서 서로소 찾기 집합 혹은 병합 찾기 집합이라 불리며 중복되지 않은 부분집합들의 원소 정보를 조작하고 저장하는 자료구조이다.   부분집합(Subset)에서 특정 원소 하나를 A, 또 다른 원소 하나를 B라 하면, 이 A나 B가 어느 부분집합에 속하는지, 또 A와 B가 각각 속한 부분집합 다르다면 이 두 부분집합을 하나의 집합으로 합쳐, 원소들이 겹치지 않는(Non-overlapping) 하나의 부분집합을 구성하는 것에 목적이 있다.   Representation  유니온 파인드 자료구조는 트리로 표현이 될 수 있습니다. 처음 N개의 원소 각각은 서로 다른 1개의 트리이자 부분집합이며 자기 자신이 최상위 루트이다. 각각의 부분집합을 구별할 땐 그 부분집합의 루트를 이용한다. 서로 다른 두개의 부분집합을 합칠 땐 하나의 부분집합의 루트를 다른 하나의 부분집합의 루트로 가리키게 한다.   Union-Find represented as a tree:      우리는 이를  “1 Dimention Array”로 표현이 가능하다.  index i\t  =  1, 2, 3, 4, 5, 6, 7  parent[i] = [2, 2, 2, 5, 5, 6, 7]  parent[1] = 2 -&gt; 원소 1은 원소 2를 부모로 한다.  parent[6] = 6 -&gt; 원소 6은 6 즉, 자기 자신을 부모로 한다.   Operations   다음은 유니온 파인드 자료구조를 위한 연산들이다.   Make set (Initialization)  유니온 파인드 자료구조를 위한 새로운 집합을 생성한다.  노드 각각이 자기 자신을 가리키도록 설정한다. (처음에는 자기 자신이 트리의 최상위 노드)   public void makeSet() {    for (int i = 0; i &lt; n; i++)      parent[i] = i; }   Make set operation:      배열의 상태는 아래와 같다.   index i   =  1, 2, 3, 4, 5, 6, 7 parent[i] = [1, 2, 3, 4, 5, 6, 7]   Find  우리는 두 원소가 서로 다른 부분집합에 속해있으면 두 부분집합을 Union 할 수 있다.  두 원소가 서로 같은 부분집합에 포함되어 있는지 아닌지 확인하기 위해 두 원소의 루트를 확인해야 한다.  Find 연산은 해당 원소가 속해있는 부분집합의 루트를 반환한다.      원소 x의 부모가 자기 자신이라면 그 부분집합의 루트이므로 x를 반환한다.   아니라면 재귀 호출로 x의 부모를 따라간다.   루트를 찾을 때까지 재귀 호출이 진행되다가 루트를 찾으면 원소 x의 루트를 반환한다.   int find(x) { // Recursive function     if (parent[x] == x)    // 원소 x의 부모가 자기자신이면 그 부분집합의 루트이므로        return x;        // x를 반환합니다.     else           return find(parent[x]); // 아니라면 x의 부모를 다시 재귀호출하여 루트를 찾습니다. }   Find(1) returns 2:      다음은 현재 배열의 상태이다.   index i   =  1, 2, 3, 4, 5, 6, 7 parent[i] = [2, 2, 2, 5, 5, 6, 7]   원소 1이 속한 부분집합의 루트를 알고 싶다면 Find(1)을 수행한다.  parent[1] != 1  두 값이 같지 않다.  그럼 parent[1]을 매개변수로 다시 Find(parent[1])을 재귀 호출한다.// 이는 부모를 따라가는 것이다.  parent[2] == 2 두 값이 같다! 2를 반환한다.   1의 루트는 2 임을 알 수 있다.   5를 보면.  find(5)를 수행하면  parent[5] == 5  두 값이 같다.  5의 부모는 5 자기 자신의 값이 되고, 이 말은 자기 자신이 루트란 말이므로 5를 반환한다.   Union  두 원소가 속한 부분집합이 다르면 두 부분집합을 하나의 부분집합으로 합칠 수 있다.  이를 수행하는 연산이 Union이다.      두 원소(x, y)가 속한 부분집합이 서로 같다면 return 한다.   같지 않다면 두 부분집합을 합친다.   Make set operation:      처음에 이렇게 7개의 서로 다른 부분집합이 있다. (자기 자신이 트리의 루트)   Union:      union(2,1), union(4,3), union(6,5)를 수행하면 위 그림처럼 트리가 구성된다.  2의 루트는 2이고 1의 루트도 1 자기 자신이다.  둘의 값이 다르므로 서로 다른 부분집합이고, 2는 1을 가리킴으로써 부분집합을 합친다.  union(4,3), union(6,5)도 마찬가지이다.   다음은 위 트리의 배열 상태이다.   index i   =  1, 2, 3, 4, 5, 6, 7 parent[i] = [1, 1, 3, 3, 5, 5, 7]   union(2, 4)를 하면 아래 그림처럼 된다.   Union(2, 4):      void union(int x, int y) {     xRoot = find(x) // find로 x의 루트를     yRoot = find(y)      if(xRoot == yRoot) // 두 원소가 속한 부분집합이 같으므로 리턴합니다.       return;     parent[x_root] = y_root; // 두 부분집합을 합칩니다. x의 루트를 y의 루트로 가리키게 합니다. }   2가 속한 부분집합의 루트(find(2))는 1이고, 4가 속한 부분집합의 루트(find(4))는 3이므로, 이 둘의 값이 다르고 1이 3을 가리킴으로써(parent [1] = 3) 같은 부분집합으로 합쳐준다.   아래는 위 트리의 배열 상태이다.   index i   =  1, 2, 3, 4, 5, 6, 7 parent[i] = [3, 1, 3, 3, 5, 5, 7]   Path compression   부분집합을 합치는 연산(유니온)을 수행하면서 아래 그림과 같이 편향적인 트리로 구성될 수 있다.  이때 노드의 개수가 n개일 때 find(n)을 수행하면 시간 복잡도는 $O(n)$가 된다.  아래 그림에서 5번 원소는 자기 부모를 타고 가다가 끝에는 루트 1을 만나게 된다. 링크를 4번 타고 가야 루트를 찾을 수 있다.  4번 원소도 링크를 3번 타고 가야 루트를 찾을 수 있다.   편향 트리:      우리는 여기서 한 가지 개선을 할 수 있다.   5번에서 1번 까지(5 - 4 - 3- 2 - 1)의 경로에 있는 모든 원소는 전부 루트를 1로 갖는다. 그렇다면 5번도 1을, 4번도 1을.. 2번도 1을 가리켜도 이 부분집합을 구성하는 원소는 변함이 없을 것이다. 이렇게 되면 아래 그림처럼 5번에서 2번까지 1번을 루트로서 바로 가리키게 되고 find(n) 연산 수행 시 시간 복잡도는 상수 시간 O(1)이 된다.   이것을 Path compression(경로 압축)이라 한다.   Union-Find with path compression:      find(5) 연산 수행 시 5에서 루트 1로 가는 경로에 있는 모든 원소를 재귀 호출이나 For loop을 이용해서 1을 루트로 바로 가리키게 구현할 수 있다.      x가 x의 부모와 같다면(자기 자신이 루트)라면 x를 반환한다.   다르다면 x의 부모는 x의 부모의 재귀 리턴 값이 된다.   재귀가 진행되면서 루트를 만나게 되면(매개변수로 들어온 값이 자기 자신 = 루트) x를 반환한다.   int find(x){      if (parent[x] != x)         parent[x] = find(parent[x]);      return x; }   Union by Rank   트리의 깊이 또는 높이는 유니온 파인드 연산 실행시간에 영향을 주는데 트리를 합칠 때 높이가 작은 트리를 높이가 큰 트리의 루트에 붙이면 높이가 높아지지 않는다. 이렇게 유니온 바이 랭크(union by rank)는 높이가 작은 트리를 큰 트리의 루트에 붙이는 방법이다.   ※ 단, 높이가 같은 트리를 합칠 땐 높이가 +1 높아진다.   우리는 여기서 랭크라는 표현을 쓰는데, 트리의 높이는 위에서 살펴본 path compresstion에 의해서 줄어들 수 있고 업데이트 되지 않기 때문이다. 그래서 랭크라는 표현을 쓴다.      어떤 원소 u가 한 트리의 루트이고 랭크 $r$을 가진다고 하면 유니온 바이 랭크 연산 하에 그 트리의 노드 수는 최소 $2^r$이 되고, 랭크 $r$로 같은 두 트리를 Union by rank 하면 랭크는 1 높아지게 되고 노드의 수는 $2^r + 2^r = 2^(r+1)$가 된다. 노드의 수는 2배가 되고 랭크는 1 높아지므로 연산 수행 시간이 $O(logn)$으로 보장이 된다.      원소마다 랭크 정보를 유지하기 위해서 Make set의 for loop에 rank [i] = 0을 추가해 준다.   for (i=1; i&lt;=n; i++){     parent[i] = i;     rank[i] = 0; // 처음에는 랭크가 전부 0 }  아래는 union by rank 코드이다.      두 원소의 루트를 구해서 서로 같다면 합치지 않고 유니온 연산을 종료한다.   그렇지 않다면, x의 루트랭크가 y의 루트랭크보다 크거나 같다면 y의 루트를 x의 루트 아래로 붙인다. (else 서로 스왑해서 수행)   두 트리의 랭크가 서로 같다면 랭크+1을 해준다. (두 트리의 랭크가 같으니 합치면 랭크가 +1 된다.)   void union(int x, int y)      xRoot = find(x);      yRoot = find(y);      if xRoot == yRroot          return        if (rank[xRoot] &gt;= rank[yRoot])          parent[yRoot] = xRoot;      else          parent[xRoot] = yRoot;        if (rank[xRoot] == rank[yRoot])          rank[yRoot] = rank[xRroot] + 1   Application   유니온 파인드는 무향 그래프에서의 사이클 존재 유무를 판별할 때 사용될 수 있다. (단, 셀프 루프는 없어야 한다.)   또한, 크루스칼 알고리즘에서 최소 스패닝 트리를 찾는데에 자료구조로서 사용된다.   최소 스패닝 트리는 노드의 수가 n개 일 때 n-1개의 최소 비용의 간선으로 이루어진 트리로서, 그래프에서 최소비용의 간선을 선택하면서 만들어지는 트리에 사이클이 형성되지 않아야 하기에 사이클 형성 유무 판별에 유니온 파인드가 사용된다.   Link: 크루스칼 알고리즘 글 보러가기.   Union by Lank with Path Compression   class unionFind{     private int parent[];     private int rank[];     private int n;       unionFind(int cnt) {         this.n = cnt;         parent = new int[n];         rank = new int[n];     }       public void makeSet() {         for (int i = 0; i &lt; n; i++) {             parent[i] = i;             rank[i] = 0;         }     }       public int find(int x) {         if (parent[x] == x)             return x;         else             return parent[x] = find(parent[x]); // * 경로 압축     }       public void union(int root1, int root2) {         root1 = find(root1);         root2 = find(root2);           if (root1 == root2) // 루트가 같다면 수행하지 않는다.             return;           if (rank[root1] &gt;= rank[root2]) { // 루트1의 랭크가 루트2의 랭크보다 크다면             parent[root2] = parent[root1]; //루트2가 루트1의 밑으로 합친다         } else { // 위의 if문 과 반대             parent[root1] = parent[root2];         }         if (rank[root1] == rank[root2])             rank[root1]+=1;     } }   백준 온라인 저지에 있는 유니온 파인드 문제 1717번 집합의 표현 코드이다.   BOJ - 1717번  import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.StringTokenizer;  public class Main {     public static void main(String[] args) throws IOException {         BufferedReader br = new BufferedReader(new InputStreamReader(System.in));         StringTokenizer st = new StringTokenizer(br.readLine());         StringBuilder sb = new StringBuilder();         int n = Integer.parseInt(st.nextToken());         int m = Integer.parseInt(st.nextToken());         unionFind h = new unionFind(n+1);         h.makeSet();         for (int i = 0; i &lt; m; i++) {             st = new StringTokenizer(br.readLine());             int operation = Integer.parseInt(st.nextToken());             int a = Integer.parseInt(st.nextToken());             int b = Integer.parseInt(st.nextToken());             if(operation == 0)                 h.union(a ,b);             else                 sb = h.find(a) == h.find(b) ?                  sb.append(\"YES\").append(\"\\n\") : sb.append(\"NO\").append(\"\\n\");         }         System.out.println(sb.toString());     } }  class unionFind {     private int parent[];     private int rank[];     private int n;      unionFind(int cnt) {         this.n = cnt;         parent = new int[n];         rank = new int[n];     }      public void makeSet() {         for (int i = 0; i &lt; n; i++) {             parent[i] = i;             rank[i] = 0;         }     }      public int find(int x) {         if (parent[x] == x)             return x;         else             return parent[x] = find(parent[x]); // * 경로 압축     }      public void union(int root1, int root2) {         root1 = find(root1);         root2 = find(root2);          if (root1 == root2) // 루트가 같다면 수행하지 않는다.             return;          if (rank[root1] &gt;= rank[root2]) { // 루트1의 랭크가 루트2의 랭크보다 크다면             parent[root2] = parent[root1]; //루트2가 루트1의 밑으로 합친다         } else { // 위의 if문 과 반대             parent[root1] = parent[root2];         }         if (rank[root1] == rank[root2])             rank[root1]+=1;     } }   References      Union Find - Wikipedia   Union Find - Algocoding  ","categories": ["Data Structure"],
        "tags": ["programming","Data Structure"],
        "url": "http://localhost:4000/data%20structure/unionfind/",
        "teaser":"http://localhost:4000/assets/images/withoutunionbylank.png"},{
        "title": "파이썬/AI 개발환경 준비하기",
        "excerpt":"기본적인 컴퓨터 시스템     파이썬 개발환경을 준비하기에 앞서서 기본적인 컴퓨터 시스템을 알아봅니다. 그 중에서도 크게 운영체제, 파일 시스템 그리고 터미널 환경에 대해서 알아봅니다.   운영체제   Operating System, 줄여서 OS 라고 하며, 컴퓨터에서 여러 프로그램들이 동작될 수 있는 환경을 제공하는 역할을 합니다. 우리가 사용하는 응용 프로그램과 물리적 하드웨어 사이에서 상호작용하는 소프트웨어라고 할 수 있습니다.   대표적으로 마이크로 소프트 사의 윈도우 10, 애플의 매킨토시, Linux가 운영체제의 한 종류들 입니다.   우리가 사용하는 응용 프로그램들은 운영체제에 의존적(dependent)입니다. 이는 특정 프로그램이 특정 운영체제에서만 실행이 가능한 것을 말합니다. 따라서 응용 프로그램은 특정 운영체제에 맞춰서 개발이 됩니다.   파일 시스템   File system, 파일 시스템은 OS에서 파일을 저장하는 트리 구조 저장 체계 입니다.   크게 두 가지 요소인 디렉터리와 파일로 구성되어 있는 것을 볼 수 있습니다.      디렉터리(Directory) : 폴더라고도 하며, 파일 또는 또 다른 디렉터리를 포함 할 수 있는 단위입니다.   파일(File) : 컴퓨터에서 정보를 저장하는 논리적인 단위입니다. 파일 이름은 파일명과 확장자로 구성되고 이 둘 사이에 .(dot)이 들어가게 됩니다. (main.py). 실행, 쓰기, 읽기 등을 할 수 있습니다.   파일 시스템에서는 파일과 디렉터리들이 최상단의 루트(root)디렉터리 부터 위나 옆으로 가지가 뻗는 듯한 트리 구조로 구성이 되어집니다.   윈도우의 경우 C:\\user\\... 에서 user가 루트 디렉터리 입니다.   파일 시스템에서의 경로는 컴퓨터 내에서 파일이나 자원의 고유한 위치를 가르키는 주소와 같습니다. 트리 구조 상 노드간의 연결정도로 봐도 좋을 것 같습니다.   절대 경로와 상대경로      절대 경로 : 루트 디렉터리부터 파일 위치까지의 경로. ex) C:\\user\\codebase\\helloworld.py   상대 경로 : 현재 시스템이 위치해 있는 디렉터리부터 우리가 찾고자하는 파일까지의 경로. ex) ../../index.html   터미널   터미널은 보통 CLI(Command Line Interface)라고도 하며, Mouse가 아닌 키보드를 이용해서 명령어 입력을 통해 컴퓨터를 제어하기 위해 사용하는 툴이라고 볼 수 있습니다.   Graphic User Interface (GUI)와는 달리 키보드를 이용해 text로서 명령을 내리는 인터페이스 체계로서, Graphic User Interface (GUI)환경이 일반화 되기 전까지는 이 CLI가 주로 사용 되었습니다. 지금도 맥과 유닉스 계열 시스템에서는 프로그램을 설치하고 여러 라이브러리를 관리하는 데에 이 CLI를 주로 많이 사용하고 있고, github의 사용이 증가함에 따라 다른 환경에서도 CLI의 사용이 많아 지고 있습니다.   다음은 윈도우와 맥에서 터미널을 실행할 수 있는 방법입니다.      윈도우의 경우 : 윈도우 키 + terminal 또는 윈도우 키 + R -&gt; CMD 입력   맥의 경우 : 빠른실행 terminal 입력   쉘   쉘은 조개 껍데기라는 의미로서 터미널을 사용하고, 여러 프로그램을 작동시키기 위한 소프트웨어 환경을 말합니다. 쉘은 키보드 입력으로 시스템 전반에 걸쳐 필수적인 파일 구조에 대한 연산(폴더 이동, 복사, 생성, 삭제 등)과 스크립트 작성을 지원하는 등 여러 기능을 제공합니다.   윈도우에서는 cmd나 power shell을 사용하고, 맥에서는 bash나 zsh를 쉘로 사용합니다.   다음은 shell의 일부 명령어 리스트 입니다. (셀 별로 명령어가 상이하거나 같습니다.)      디렉터리 이동 : window cmd - cd, bash - cd   텍스트 전부를 지우기 : window cmd - CLS, bash - clear   파일을 다른 위치로 복사 : window cmd - copy, bash - cp   파일 지우기 : window cmd - del, bash - rm   하위 디렉터리와 파일 보기 : window cmd - dir, bash - ls     파이썬(Python)   데이터 과학과 AI분야에서 널리 쓰이는 파이썬에 대해서 간략히 알아보고 그 특징에 대해서 알아봅니다.   파이썬과 그 특징   파이썬(Python)은 1991년 프로그래머인 귀도 반 로섬이 발표한 고급 프로그래밍 언어로, 플랫폼에 독립적이며 인터프리터식, 객체지향적, 동적 타이핑(dynamically typing) 대화형 언어입니다.   python은 그리스 신화속의 괴물 뱀을 뜻하고, 몬티 파이썬이라는 코메디 그룹의 이름에서 유래되었다고 합니다.   파이썬의 주요 특징은 특징은 다음과 같습니다.      동적 타이핑(dynamically typing) : 프로그램의 실행 시간(run time)에 자료형이 검사되고 결정됩니다.   플랫폼에 독립적 : 여기서 플랫폼은 보통 OS를 일컽는데, 파이썬으로 작성된 프로그램은 OS의 종류에 관계없이 어디서나 실행이 될 수 있다는 것을 의미합니다.   인터프리터식 : 소스코드를 바로 실행할 수 있게 지원하는 프로그램 실행 방법으로서, 별도 번역과정 없이 소스코드를 실행시점에 해석하여 컴퓨터가 처리할 수 있도록 하는 방법입니다.   객체 지향적 언어 : 실행 순서가 아닌 단위 모듈(객체)을 중심으로 프로그램을 작성할 수 있도록 고안된 언어를 말합니다. 객체는 실세계에 존재하는 사물과 같은 개념을 컴퓨터에서 표현하는 것으로, 객체는 속성과 목적을 달성하기 위한 행동을 가지고 있습니다.   여기서 컴파일러와 인터프리터를 좀 더 짚고 넘어가 보겠습니다.   컴파일러      작동방식 : 소스코드를 기계어로 먼저 번역하고 해당 플랫폼에 최적화되어 프로그램을 실행 합니다.   장 단점 : 인터프리터에 비해 상대적으로 실행속도가 빠르지만, 한번의 많은 기억장소를 필요로 합니다.   주요 언어 : 대표적으로 C, 자바, C++, C#가 컴파일러 방식을 채택하고 있습니다.   인터프리터      작동방식 : 소스코드를 기계어로 먼저 번역하고 해당 플랫폼에 최적화되어 프로그램을 실행 합니다.   장 단점 : 간단히 작성하여 실행할 수 있고, 컴파일러에 비해 메모리가 적게 필요하지만 실행속도가 다소 느립니다.   주요 언어 : 대표적으로 파이썬과 스칼라가 인터프리터 방식을 채택하고 있습니다.   Why python?   파이썬은 다른 여타 언어와 비교해 상대적으로 쉽고 코드가 간단합니다. 그래서 프로그래밍에 입문하시는 분들도 쉽게 시작해 보실 수 있는 언어입니다.   화면에 Hello, World 찍기 다음은 자바로 Hello World를 출력하는 코드 입니다.   class HelloWorldApp {   public static void main(String[] args) {     System.out.println(\"Hello World!\");   } }   다음은 파이썬으로 Hello World를 출력하는 코드 입니다.   print (\"Hello World\")   파이썬에서의 코드가 비교적 간단하고 명료한 것을 볼 수 있습니다.   파이썬은 또한 이미 다양한 라이브러리가 구현이 되어있고 이것을 손쉽게 가져다가 쓸 수 있습니다. (특히 데이터 사이언스, 분석) 바둑에서 이세돌을 이긴 알파고 부터 중력파 확인과 블랙홀을 탐지하기 위해 지구에서 멀리 떨어져 있는 여러 안테나의 네트워크 통신에 까지 파이썬이 사용되고 있습니다.   그리고 우리가 자주 사용하는 소셜미디어 유튜브, 레딧, 인스타그램 등… 많은 곳에서 파이썬이 사용되고 있습니다.   해외 개발자 사이트 스택 오버플로우의 언어 통계에 따르면 사람들이 지금 가장 많이 사용하는 언어로서 1위를 기록하고 있고, 데이터 사이언스 분야에서는 독보적으로 사용되고 있음을 볼 수 있습니다.   피어세션 정리   오늘은 동료분들과의 첫 만남이었고, 서로 인사하며 얼굴을 트는 기회를 가질 수 있었습니다.   서로 인사하고, 자기소개로 시작하며 피어세션이 진행되었습니다.   공지대로 조 이름, 모더레이터를 정하고, 그라운드 룰은 어떻게 하면 좋을지 서로 논의해 보았습니다.   그리고 동료분들 끼리 이 피어세션 동안 어떤 것을 하면 좋을지에 대해서 토의를 해보는 시간을 가질 수 있었습니다.   피어 플랜으로서, 저희는 딥러닝 백엔드를 하나 선택하여(pandas) 서로 공부하고, 그것을 공유하는 것 하나와 캐글 또 하나는 관련 논문 스터디를 진행하는 쪽으로 의견이 모아졌습니다.   하지만 주차가 지남에 따라 내용이 다소 심화되는 점과 앞으로의 과제를 생각해 볼 때, 피어 플랜을 무리하게 전부 하지 않고 다소 유연하게 하는 쪽으로 가져봄직도 한 것 같습니다.   References      파이선 개발환경 - 최성철 교수님   Python - wikipedia  ","categories": ["Development"],
        "tags": ["AI","Python"],
        "url": "http://localhost:4000/development/boostcamp-week1-day1/",
        "teaser":null},{
        "title": "파이썬 기초 문법",
        "excerpt":"파이썬의 기초 문법     파이썬 언어에서의 값을 담을 수 있는 변수, 코드를 모듈로 묶어서 실행하는 하나의 단위인 함수, 사용자로 부터 입력을 받는 법, 콘솔에 출력하는 법, 조건문과 반복문 그리고 스트링을 조작할 수 있는 빌트인 모듈에 대해서 알아봅니다.   변수   가장 기초적인 프로그래밍 문법개념 입니다. 데이터를 저장하기 위한 메모리 공간의 프로그래밍 상 이름입니다.   다른 프로그래밍 언어와 같이 다음과 같이 선언하고 특정 값으로 초기화 할 수 있습니다.   a = 5 or b = 3   a = 5의 의미는 : “a라는 이름의 변수에 5라는 숫자를 넣어라” 라는 의미와 같습니다.   수학식 $2x + 7y = 14$ 에서 변수는 x와 y를 의미합니다.   프로그래밍에서 변수는 수학과 약간 다른 개념입니다.   프로그래밍에서는 변수는 값을 저장하는 장소이고, 변수는 메모리 주소를 가지고 있고 변수에 들어가는 값은 메모리 주소에 할당됩니다.      선언 되는 순간 메모리 특정영역에 물리적인 공간이 할당   변수에는 값이 할당되고 해당 값은 메모리에 저장   A = 8의 의미는 “A는 8이다”가 아닌 A라는 이름을 가진 메모리주소에 8을 저장하라   변수와 관련된 파이썬 에서의 자료형, 연산자, 형변환     자료형      정수형 integer : 양/음의 정수이고, (1,2,3,100와 같은 것)   실수형 float : 소수점이 포함된 실수이고, (1.0,2.2,3.01 와 같은 것)   문자형 string : 따옴표 (‘ / “)에 들어가 있는 문자형 (abc, a20abc 와 같은 것)   사용 예시   &gt;&gt;&gt; a = 1 # Integer &gt;&gt;&gt; b = 1 # Integer &gt;&gt;&gt; print (a, b) 11 &gt;&gt;&gt; a = 1.5 # Float &gt;&gt;&gt; b = 3.5 # Float &gt;&gt;&gt; print (a, b) 1.5 3.5 &gt;&gt;&gt; a = \"ABC\" # String &gt;&gt;&gt; b = \"101010\" # String &gt;&gt;&gt; print (a, b) ABC 101010 &gt;&gt;&gt; a = True # Boolean 대소문자 구분 &gt;&gt;&gt; b = False # Boolean 대소문자 구분 &gt;&gt;&gt; print (a, b) True False     연산자 피연산자      +,-,*,/같은 기호들을 연산자라고 칭함   연산자에 의해 계산이 되는 숫자들은 피연산자라 칭함   수식에서 연산자의 역할은 수학에서 연산자와 동일   연산의 순서는 수학에서 연산순서와 같음   문자간에도 + 연산이 가능함 -&gt; concatenate   제곱 구하기   &gt;&gt;&gt; print (3 * 3 * 3 * 3 * 3) # 3을 다섯 번 곱함 243 &gt;&gt;&gt; print (3 ** 5) # 3의 5승 243     증가또는감소연산   # 변수 a 에 1을 할당 # a 에 1를 더한 후 그 값을 a에 할당 # a 출력 &gt;&gt;&gt;a=1 &gt;&gt;&gt; a = a + 1 &gt;&gt;&gt; print (a) 2 # a 증가 연산 # a 출력 &gt;&gt;&gt; a += 1 &gt;&gt;&gt; print (a) 3 # a 에 1를 뺀 후 그 값을 a에 할당 # a 감소 연산 # a 출력 &gt;&gt;&gt; a = a – 1 &gt;&gt;&gt; a -= 1 &gt;&gt;&gt; print (a) 1     데이터형변환:정수형↔실수형   # a 변수에 정수 데이터 10을 할당 # a가 정수형으로 출력  &gt;&gt;&gt; a = 10 &gt;&gt;&gt; print (a) 10 # a를 실수형으로 변환 / 정수형은 int() # a를 출력 # a가 실수형으로 출력됨 &gt;&gt;&gt; a = float(10) &gt;&gt;&gt; print (a) 10.0 # b 에 정수 데이터 3 할당 # 실수형으로 a 나누기 b를 출력 # 실수형 결과값 출력 &gt;&gt;&gt; b = 3 &gt;&gt;&gt; print (a / b) 3.33333333333   함수   어떤 일을 수행하는 코드의 덩어리 입니다.   # 사각형의 넓이를 구하는 함수 def calculate_rectangle_area (x , y): return x * y # 가로, 세로를 곱해서 반환      반복적인 수행을 1회만 작성 후 호출   코드를 논리적인 단위로 분리   캡슐화:인터페이스만 알면 타인의 코드사용     함수 선언 문법   def 함수 이름 (parmaeter #1,...,): 수행문 #1(statements) 수행문 #2(statements) return &lt;반환값&gt;     함수 선언 예시   def calculate_rectangle_area(x , y) return x * y rectangle_x = 10 rectangle_y = 20 print (\"사각형 x의 길이: \", rectangle_x) print (\"사각형 y의 길이: \", rectangle_y) # 넓이를 구하는 함수 호출 print (\"사각형의 넓이: \", calculate_rectangle_area(rectangle_x, rectangle_y))   입 출력   input() 함수를 이용해 콘솔창에서 사용자로 부터 입력을 받을 수 있습니다.   예시   print (\"Enter your name:\") somebody = input() # 콘솔창에서 입력한 값을 somebody에 저장 print (\"Hi\", somebody, \"How are you today?\")   실행   python console_test.py Enter your name: Sungchul Choi Hi Sungchul Choi How are you today?     print() 함수는 콘솔창으로 문자열을 출력하는 함수입니다.   콤마(,) 사용할 경우 print 문이 연결됩니다.   예시   &gt;&gt;&gt; print (\"Hello World!\", \"Hello Again!!!\") # , 사용 Hello World! Hello Again!!! # 실행 시 두 문장이 연결 돼서 출력됨     **온도를 입력받고 실수형으로 출력해보기 **   temperature = float(input(\"온도를 입력하세요 :\")) # 입력 시 바로 형 변환 하기 print(temperature)   실행 값   python temperature.py 온도를 입력하세요 : 103 103.0   조건문과 반복문   조건문이란 ?   조건문은 조건을 나타내는 기준과 실행해야 할 명령으로 구성됩니다. 조건의 참,거짓에 따라 실행해야 할 명령이 수행되거나 되지않습니다.   파이썬은 조건문으로 if , else , elif 등의 예약어를 사용합니다.   if-else문 문법   if &lt;조건&gt;: # if를 쓰고 조건 삽입 후 “:” 입력   &lt;수행 명령1-1&gt; # 들여쓰기(indentation)후 수행명령 입력   &lt;수행 명령1-2&gt; # 같은 조건하에 실행일 경우 들여쓰기 유지 else: # 조건이 불일치할 경우 수행할 명령 block   &lt;수행명령2-1&gt; #조건불 일치 시 수행할 명령 입력   &lt;수행 명령2-2&gt; # 조건 불일치 시 수행할 명령 들여쓰기 유지     if-else문의 예시   가장 기본적인 조건문으로 조건에 따른 명령을 실행   print (\"Tell me your age?\") myage = int(input()) # 나이를 입력 받아 myage 변수에 할당 if myage &lt; 30: # myage 가 30 미만일 때     print (\"Welcome to the club\") else: # myage 가 30 이상일 때     print (\"Oh! No. You are not accepted.\")     조건 판단 방법   if 다음에 조건을 표기하여 참 또는 거짓을 판단 그리고 참/거짓의 구분을 위해서는 비교 연산자를 활용      x &lt; y : ~보다 작음   x &gt; y : ~보다 큼   x == y : 같음   x != y : 다름     반복문이란 ?   정해진 동작을 반복적으로 수행하게 하는 명령문 입니다.   다음은 반복문이 쓰여질 수 있는 상황들 입니다.      100명의 학생에 성적을 산출할 때, 검색 결과를 출력해 줄 때   워드에서 단어 바꾸기 명령 실행 반복문은 반복 시작 조건, 종료 조건, 수행 명령으로 구성됨 반복문 역시 반복 구문은 들여쓰기와 block으로 구분됨   파이썬은 반복문으로 for, while 등의 명령 키워드를 사용합니다.     for loop   기본적인 반복문으로서 반복 범위를 지정하여 반복문 안에 구문들을 수행합니다.   예시   for i in [1,2,3]     print('hello)     range() 사용하기   for i in range(0,5)     print('hello)   range(0,5) = [0,1,2,3,4] 와 같은 의미입니다. (End element is exclusive)     반복문 변수명에서의 변수명      임시적인 반복 변수는 대부분 i, j, k로 정함   이것은 수학에서 변수를 x, y, z로 정하는 것과 유사한 관례   0부터 시작하는 반복문      반복문은 대부분 0부터 반복을 시작   이것도 일종의 관례로 1부터 시작하는 언어도 존재   2진수가 0부터 시작하기 때문에 0부터 시작하는 걸 권장 무한 loop   반복 명령이 끝나지 않는 프로그램 오류   CPU와 메모리 등 컴퓨터의 리소스를 과다하게 점유   스트링 함수   다음은 파이썬에서 문자열을 다룰 때 유용하고 많이 쓰이는 Built In 함수입니다.   a 는 스트링 입니다. ex) 'hello world'      len(a) : 문자열의 문자 개수를 반환 -&gt; 5   a.count(‘l’) : 문자열 a에 ‘l’이 들어간 횟수 반환 -&gt; 3   len(a) : 문자열의 문자 개수를 반환 -&gt; 11   a.capitalize() : 첫 문자를 대문자로 변환 -&gt; ‘Hello world’   a.find(‘e’) : 문자열 a에 ‘e’가 들어간 위치(오프셋) 반환 -&gt; 1   a.startswith(‘he’) : 문자열 a는 ‘he’로 시작하는 문자열 여부 반환 -&gt; True   a.split(‘’) : ‘ ‘을 기준으로 나눠 리스트로 반환 -&gt; [‘hello’, ‘world’]   a.strip() : 좌우 공백을 없앰   a.isdigit() : 문자열이 숫자인지 여부 반환 -&gt; False   a.islower() : 문자열에 대문자가 하나라도 포함되어 있으면 False 그 이외에는 True를 반환 -&gt; 예제의 경우는 True 반환   피어세션 정리   오늘은 조원과 만난 두 번째 날이었고, 서로 전날에 공부한 것과 오늘 공부한 것을 얘기하고 궁금한 것을 서로 물어보며 유익한 시간을 가질 수 있었습니다.   오늘은 어제에 비해 강의 영상이 다소 길어졋고, 또한 과제까지 추가 되면서 조원 모두 분주한 기색이 없지 않아 있었던거 같고, 그래서 피어세션 시간에 영상은 어디까지 봤는지, 과제는 어떻게 되가는지에 대해 얘기하는 시간을 가질 수 있었습니다. 오늘은 긴 영상과 더불어 공부한 것을 정리하는 노트와 당일 과제 제출까지 해야하는 바람에 하루 마무리 하는 시간은 약간 늦어질거 같습니다.   피어플랜 계획대로 서로 판다스 비디오를 보면서 각자 진행상황을 확인하는 시간도 가질 수 있었습니다.   과제 진행 상황 정리   오늘 부여된 과제는 총 4개이고      basic math   text processing   text processing   basic baseball   지금 글을 쓰는 시점에서 위에 4가지 과제 전부 완료 하였습니다.   basic math에서는 기본적인 수학 연산과 최대, 최소, 평균 그리고 중앙값을 구하는 연산을 연습할 수 있었습니다. text processing1, 2에서는 문자열 함수를 써봄으로서 문자열을 보다 다양하고 손쉽게 다룰 수 있도록 연습할 수 있었으며 이를 응용해 다양한 문제를 풀 수 있었습니다. basic baseball에서는 여러 가지 함수를 조합함으로서 다소 복잡한 구현 문제를 풀 수 있는 과정을 기를 수 있었던 것 같았습니다.   References      파이선 기본문법 - 최성철 교수님   Python - wikipedia  ","categories": ["Development"],
        "tags": ["AI","Python"],
        "url": "http://localhost:4000/development/boostcamp-week1-day2/",
        "teaser":null},{
        "title": "파이썬 기초 문법 2",
        "excerpt":"파이썬에서의 자료구조와 Pythonic Code   자료를 보다 효율적으로 구성하고 사용을 용이하게 해주는 파이썬에서의 자료구조와 파이썬의 문법적 특징을 잘 살린 pythonic code에 대해서 알아봅니다.   파이썬에서의 자료구조   자료구조는 어떤 데이터를 저장할 때, 그 데이터에 특징에 따라 컴퓨터에 효율적으로 정리하기 위한 데이터의 저장 및 표현 방식을 이야기합니다. 어떤 데이터는 순서가 있다거나, 그 데이터의 나타내는 ID 값과 쌍을 이룬다던가 하는 등의 특징이 나타나게 됩니다. 일반적으로 사용되는 정수, 문자열등의 변수 타입보다는 이러한 특징들에 잘 맞는 형태로 데이터를 저장하게 된다면 훨씬 효율적으로 컴퓨터의 메모리를 사용하고, 프로그래머가 코드를 작성하기에도 용이하게 해줍니다   스택과 큐   스택      나중에 넣은 데이터를 먼저 반환하도록 설계된 메모리 구조   Last In First Out (LIFO)   Data의 입력을 Push, 출력을 Pop이라고 함   리스트를 사용하여 스택 구조를 구현 가능   push를 append(), pop을 pop()를 사용   &gt;&gt;&gt; a = [1,2,3,4,5] &gt;&gt;&gt; a.append(10) &gt;&gt;&gt; a.append(20) &gt;&gt;&gt; a.pop() 20 &gt;&gt;&gt; a.pop() 10 &gt;&gt;&gt;     큐      먼저 넣은 데이터를 먼저 반환하도록 설계된 메모리 구조   First In First Out (FIFO)   Stack과 반대되는 개념   파이썬은 리스트를 사용하여 큐 구조를 활용   put를 append(), get을 pop(0)를 사용   &gt;&gt;&gt; a = [1,2,3,4,5] &gt;&gt;&gt; a.append(10) &gt;&gt;&gt; a.append(20) &gt;&gt;&gt; a.pop(0) # 1 출력 1 &gt;&gt;&gt; a.pop(0) # 2 출력 2 &gt;&gt;&gt;     튜플      값의 변경이 불가능한 리스트   선언시“[]”가 아닌 “() ”를사용   리스트의 연산, 인덱싱, 슬라이싱 등을 동일하게 사용   &gt;&gt;&gt; t = (1,2,3) &gt;&gt;&gt; print (t + t , t * 2) # (1, 2, 3, 1, 2, 3) (1, 2, 3, 1, 2, 3) (1, 2, 3, 1, 2, 3) (1, 2, 3, 1, 2, 3) &gt;&gt;&gt; len(t) # 3 3 &gt;&gt;&gt; t[1] = 5 # Error 발생 Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt; TypeError: 'tuple' object does not support item assignment &gt;&gt;&gt;     &gt;&gt;&gt; t = (1) # 일반 정수로 인식 1 &gt;&gt;&gt;t = (1, ) #값이 하나인 Tuple은 반드시 \",\"를붙여야함 (1,)   왜 쓸까요 ?      프로그램을 작동하는 동안 변경되지 않은 데이터의 저장 Ex) 학번, 이름, 우편번호 등등   함수의 반환 값등 사용자의 실수에 의한 에러를 사전에 방지   set      값을 순서없이 저장, 중복 불허 하는 자료형   set 객체 선언을 이용하여 객체 생성   # set 함수를 사용 1,2,3을 집합 객체 생성 , a = {1,2,3,4,5} 도 가능 &gt;&gt;&gt; s = set([1,2,3,1,2,3]) &gt;&gt;&gt; s {1, 2, 3} &gt;&gt;&gt; s.add(1) &gt;&gt;&gt; s # 한 원소 1만 추가, 추가, 중복불허로 추가 되지 않음 {1, 2, 3} # 1 삭제 &gt;&gt;&gt; s.remove(1) &gt;&gt;&gt; s {2, 3} # [1,4,5,6,7] 추가 &gt;&gt;&gt; s.update([1,4,5,6,7]) &gt;&gt;&gt; s {1, 2, 3, 4, 5, 6, 7} # 3 삭제 &gt;&gt;&gt; s.discard(3) &gt;&gt;&gt; s {1, 2, 4, 5, 6, 7} # 모든 원소 삭제 &gt;&gt;&gt; s.clear()      수학에서 활용하는 다양한 집합연산 가능   &gt;&gt;&gt; s1 = set([1,2,3,4,5]) &gt;&gt;&gt; s2 = set([3,4,5,6,7]) &gt;&gt;&gt; s1.union(s2) &gt;&gt;&gt; s1 | s2 {1, 2, 3, 4, 5, 6, 7} &gt;&gt;&gt; s1.intersection(s2) {3, 4, 5} &gt;&gt;&gt; s1 &amp; s2 {3, 4, 5} &gt;&gt;&gt; s1.difference(s2) {1, 2} &gt;&gt;&gt; s1 - s2 {1, 2}   dict      Key 값을 활용하여, 데이터 값(Value)를 관리함   key와 value를 매칭하여 key로 value를 검색   다른 언어에서는 Hash Table 이라는 용어를 사용   {Key1:Value1, Key2:Value2, Key3:Value3 …} 형태   사전 (dictionary) 다루기   &gt;&gt;&gt; country_code = {} # Dict 생성, country_code = dict() 도 가능 &gt;&gt;&gt; country_code = {\"America\": 1, \"Korea\": 82, \"China\": 86, \"Japan\": 81} &gt;&gt;&gt; country_code {'America': 1, 'China': 86, 'Korea': 82, 'Japan': 81} &gt;&gt;&gt; country_code.items() # Dict 데이터 출력 Dict_items([('America', 1), ('China', 86), ('Korea', 82), ('Japan', 81)]) &gt;&gt;&gt; country_code.keys() # Dict 키 값만 출력 Dict_keys([\"America\", \"China\", \"Korea\", \"Japan\"]) &gt;&gt;&gt; country_code[\"German\"]= 49 # Dict 추가 &gt;&gt;&gt; country_code {'America': 1, 'German': 49, 'China': 86, 'Korea': 82, 'Japan': 81} &gt;&gt;&gt; country_code.values() # Dict Value만 출력 dict_values([1, 49, 86, 82, 81])  # - - - - - - - - - - - - - - -  &gt;&gt;&gt; for k,v in country_code.items(): ... print (\"Key : \", k) ... print (\"Value : \", v) ... Key : America Value : 1 Key : Gernman Value : 49 Key : China Value : 86 Key : Korea Value : 82 Key : Japan Value : 81 &gt;&gt;&gt; \"Korea\" in country_code.keys() # Key값에 \"Korea\"가 있는지 확인 True &gt;&gt;&gt; 82 in country_code.values() # Value값에 82가 있는지 확인 True   collections      List, Tuple, Dict에 대한 Python Built-in 확장 자료 구조(모듈)   편의성, 실행 효율 등을 사용자에게 제공함   아래의 모듈이 존재합니다.      from collections import deque    from collections import Counter    from collections import OrderedDict    from collections import defaultdict    from collections import namedtuple   deque      Stack과 Queue 를 지원하는 모듈   List에 비해 효율적인=빠른 자료 저장 방식을 지원함   rotate, reverse등 Linked List의 특성을 지원함   기존 list 형태의 함수를 모두 지원함   from collections import deque deque_list = deque() for i in range(5):     deque_list.append(i) print(deque_list) deque_list.appendleft(10) print(deque_list)      rotate, reverse등 Linked List의 특성을 지원함   기존 list 형태의 함수를 모두 지원함   deque_list.rotate(2) print(deque_list) deque_list.rotate(2) print(deque_list) print(deque(reversed(deque_list))) deque_list.extend([5, 6, 7]) print(deque_list) deque_list.extendleft([5, 6, 7]) print(deque_list)      deque는 기존 list보다 효율적인 자료구조를 제공   효율적 메모리 구조로 처리 속도 향상   OrderedDict      Dict와 달리, 데이터를 입력한 순서대로 dict를 반환함   그러나 dict도 python 3.6 부터 입력한 순서를 보장하여 출력함   from collections import OrderedDict d = OrderedDict() d['x'] = 100 d['y'] = 200 d['z'] = 300 d['l'] = 500  # x - y - z- l 의 입력한 대로 순서를 보장      Dict type의 값을, value 또는 key 값으로 정렬할 때 사용 가능   for k, v in OrderedDict(sorted(d.items(), key=lambda t: t[0])).items():   print(k, v) for k, v in OrderedDict(sorted(d.items(), key=lambda t: t[1])).items():   print(k, v)   defaultdict   from collections import defaultdict d = defaultdict(object) # Default dictionary를 생성 d = defaultdict(lambda: 0) # Default 값을 0으로 설정합 print(d[\"first\"])   파이썬 스타일 코드 - Pythonic Code      파이썬 스타일의 코딩 기법   파이썬 특유의 문법을 활용하여 효율적으로 코드를 표현함   그러나 더 이상 파이썬 특유는 아님, 많은 언어들이 서로의 장점을 채용   고급 코드를 작성 할 수록 더 많이 필요해짐   &gt;&gt;&gt; colors = ['red', 'blue', 'green', 'yellow'] &gt;&gt;&gt; result = '' &gt;&gt;&gt; for s in colors:       result += s  # - - - - - - - - - &gt;&gt;&gt; colors = ['red', 'blue', 'green', 'yellow'] &gt;&gt;&gt; result = ''.join(colors) &gt;&gt;&gt; result # 'redbluegreenyellow'   Why Pythonic Code?      다른 코드에 대한 이해도가 올라간다.   많은 개발자들이 python 스타일로 코딩한다   단순 for loop append보다 list가 조금 더 빠르다 익숙해지면 코드도 짧아진다.   split &amp; join   split      string type의 값을 “기준값”으로 나눠서 List 형태로 변환   &gt;&gt;&gt; items = 'zero one two three'.split() # 빈칸을 기준으로 문자열 나누기 &gt;&gt;&gt; print (items) ['zero', 'one', 'two', 'three'] &gt;&gt;&gt; example = 'python,java,javascript' # \",\"을 기준으로 문자열 나누기 &gt;&gt;&gt; example.split(\",\") ['python', ‘java', 'javascript'] &gt;&gt;&gt; a, b, c = example.split(\",\") # 리스트에 있는 각 값을 a,b,c 변수로 unpacking &gt;&gt;&gt; example = ‘teamlab.technology.io' &gt;&gt;&gt; subdomain, domain, tld = example.split('.') # \".\"을 기준으로 문자열 나누기 → Unpacking     join      String으로 구성된 list를 합쳐 하나의 string으로 반환   &gt;&gt;&gt; colors = ['red', 'blue', 'green', 'yellow'] &gt;&gt;&gt; result = ''.join(colors) &gt;&gt;&gt; result 'redbluegreenyellow' &gt;&gt;&gt; result = ' '.join(colors) # 연결 시 빈칸 1칸으로 연결 &gt;&gt;&gt; result 'red blue green yellow' &gt;&gt;&gt; result = ', '.join(colors) # 연결 시 \", \"으로 연결 &gt;&gt;&gt; result 'red, blue, green, yellow' &gt;&gt;&gt; result = '-'.join(colors) # 연결 시 \"-\"으로 연결 &gt;&gt;&gt; result 'red-blue-green-yellow'   list comprehension      기존 List 사용하여 간단히 다른 List를 만드는 기법   포괄적인 List, 포함되는 리스트라는 의미로 사용됨   파이썬에서 가장 많이 사용되는 기법 중 하나   일반적으로 for + append 보다 속도가 빠름   # ex1) &gt;&gt;&gt; result = [i for i in range(10)] &gt;&gt;&gt; result [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] &gt;&gt;&gt; result = [i for i in range(10) if i % 2 == 0] &gt;&gt;&gt; result [0, 2, 4, 6, 8]  # --- # ex2) &gt;&gt;&gt; word_1 = \"Hello\" &gt;&gt;&gt; word_2 = \"World\" &gt;&gt;&gt; result = [i+j for i in word_1 for j in word_2]     # Nested For loop &gt;&gt;&gt; result ['HW', 'Ho', 'Hr', 'Hl', 'Hd', 'eW', 'eo', 'er', 'el', 'ed', 'lW', 'lo', 'lr', 'll', 'ld', 'lW', 'lo', 'lr', 'll', 'ld', 'oW', 'oo', 'or', 'ol', 'od']  # ex3) &gt;&gt;&gt; case_1 = [\"A\",\"B\",\"C\"] &gt;&gt;&gt; case_2 = [\"D\",\"E\",\"A\"] &gt;&gt;&gt; result = [i+j for i in case_1 for j in case_2] &gt;&gt;&gt; result ['AD', 'AE', 'AA', 'BD', 'BE', 'BA', 'CD', 'CE', 'CA'] &gt;&gt;&gt; result = [i+j for i in case_1 for j in case_2 if not(i==j)] # Filter: i랑 j과 같다면 List에 추가하지 않음 # [i+j if not(i==j) else i for i in case_1 for j in case_2] &gt;&gt;&gt; result ['AD', 'AE', 'BD', 'BE', 'BA', 'CD', 'CE', 'CA'] &gt;&gt;&gt; result.sort() &gt;&gt;&gt; result ['AD', 'AE', 'BA', 'BD', 'BE', 'CA', 'CD', 'CE']  # ex4) &gt;&gt;&gt; words = 'The quick brown fox jumps over the lazy dog'.split() # 문장을 빈칸 기준으로 나눠 list로 변환 &gt;&gt;&gt; print (words) ['The', 'quick', 'brown', 'fox', 'jumps', 'over', 'the', 'lazy', 'dog'] &gt;&gt;&gt; &gt;&gt;&gt; stuff = [[w.upper(), w.lower(), len(w)] for w in words] # list의 각 elemente들을 대문자, 소문자, 길이로 변 환하여 two dimensional list로 변환  &gt;&gt;&gt; for i in stuff:     print (i)  # 출력 값들 ['THE', 'the', 3] ['QUICK', 'quick', 5] ['BROWN', 'brown', 5] ['FOX', 'fox', 3] ['JUMPS', 'jumps', 5] ['OVER', 'over', 4] ['THE', 'the', 3] ['LAZY', 'lazy', 4] ['DOG', 'dog', 3]   enumerate &amp; zip      enumerate : list의 element를 추출할 때 번호를 붙여서 추출   &gt;&gt;&gt; for i, v in enumerate(['tic', 'tac', 'toe']): # list의 있는 index와 값을 unpacking ... print (i, v) ... 0 tic 1 tac 2 toe &gt;&gt;&gt; mylist = ['a', 'b', 'c', 'd'] &gt;&gt;&gt; list(enumerate(mylist)) # list의 있는 index와 값을 unpacking하여 list로 저장 [(0, 'a'), (1, 'b'), (2, 'c'), (3, 'd')] &gt;&gt;&gt; {i:j for i,j in enumerate('Artificial intelligence (AI), is intelligence demonstrated by machines, unlike the natural intelligence displayed by humans and animals.'.split())} # 문장을 list로 만들고 list의 index와 값을 unpacking하여 dict로 저장 {0: 'Artificial', 1: 'intelligence', 2: '(AI),', 3: 'is', 4: 'intelligence', 5: 'demonstrated', 6: 'by', 7: 'machines,', 8: 'unlike', 9: 'the', 10: 'natural', 11: 'intelligence', 12: 'displayed', 13: 'by', 14: 'humans', 15: 'and', 16: 'animals.'}        zip : 두 개의 list의 값을 병렬적으로 추출함   &gt;&gt;&gt; alist = ['a1', 'a2', 'a3'] &gt;&gt;&gt; blist = ['b1', 'b2', 'b3'] &gt;&gt;&gt; for a, b in zip(alist, blist): # 병렬적으로 값을 추출 ... print (a,b) ... a1 b1 a2 b2 a3 b3 &gt;&gt;&gt; a,b,c =zip((1,2,3),(10,20,30),(100,200,300)) #각 tuple의 같은 index 끼리 묶음 (1, 10, 100) (2, 20, 200) (3, 30, 300) &gt;&gt;&gt; [sum(x) for x in zip((1,2,3), (10,20,30), (100,200,300))] # 각 Tuple 같은 index를 묶어 합을 list로 변환 [111, 222, 333]        enumerate &amp; zip 동시 사용 용례   &gt;&gt;&gt; alist = ['a1', 'a2', 'a3'] &gt;&gt;&gt; blist = ['b1', 'b2', 'b3'] &gt;&gt;&gt; &gt;&gt;&gt; for i, (a, b) in enumerate(zip(alist, blist)): ... ... 0 a1 b1 1 a2 b2 2 a3 b3 print (i, a, b) # index alist[index] blist[index] 표시   iterable object      Sequence형 자료형에서 데이터를 순서대로 추출하는 object   for city in [\"Seoul\", \"Busan\", \"Pohang\"]:   print(city, end=\"\\t\") for language in (\"Python\", \"C\", \"Java\"):   print(language, end=\"\\t\") for char in \"Python is easy\":   print(char, end = \" \")     Characteristics      내부적 구현으로 iter 와 next 가 사용됨   iter() 와 next() 함수로 iterable 객체를 iterator object로 사용   cities = [\"Seoul\", \"Busan\", \"Jeju\"] iter_obj = iter(cities) print(next(iter_obj)) print(next(iter_obj)) print(next(iter_obj)) next(iter_obj)   generator      iterable object를 특수한 형태로 사용해주는 함수               element가 사용되는 시점에 값을 메모리에 반환       yield를 사용해 한번에 하나의 element만 반환함           def geneartor_list(value):   result = []   for i in range(value):     yield i     generator comprehension      list comprehension과 유사한 형태로 generator 형태의 list 생성   generator expression 이라는 이름으로도 부름   [] 대신 () 를 사용하여 표현   gen_ex = (n*n for n in range(500))   print(type(g))                  list 타입의 데이터를 반환해주는 함수는 generator로 만들어라!       읽기 쉬운 장점, 중간 과정에서 loop 이 중단될 수 있을 때!                       큰 데이터를 처리할 때는 generator expression을 고려하라!       데이터가 커도 처리의 어려움이 없음           파일 데이터를 처리할 때도 generator를 쓰자   피어세션 정리   오늘은 조원과 만난 세 번째 날이었고, 처음으로 김종하 조교님이 피어세션에 자리해 주셔서 너무 좋았습니다.   처음에 조교님께서 먼저 자기소개를 하시고, 뒤이어 피어님들도 한분씩 자기 소개 하는 시간을 가졌습니다. 그리고 바로 조교님께 피어님들이 궁금했던거나 앞으로의 방향에 대해서 여러가지를 질문하셧고, 조교님은 열심히 하나하나 답변해주셧습니다.   남은 시간 30분은 서로 어제 공부한 것을 공유하고, 오늘의 공부 계획을 공유하는 시간을 가질 수 있었습니다.   References      파이선 기본문법 - 최성철 교수님   Python - wikipedia  ","categories": ["Development"],
        "tags": ["AI","Python"],
        "url": "http://localhost:4000/development/boostcamp-week1-day3/",
        "teaser":null},{
        "title": "파이썬 기초 문법 3",
        "excerpt":"Python Object-Oriented Programming &amp; module and project   파이썬에서의 코드를 객체지향적으로 작성하는 방법을 알아보고, 또한 파이썬의 모듈과 패키지를 알아봅니다.   파이썬에서의 객체지향 프로그래밍   Object-Oriented Programming, OOP 라고도 하며 실생활에서 존재하는 존재나 물건을 코드에서의 객체로 표현하는 방법입니다. OOP에서 이러한 객체 개념은 속성의 변수(variable), 행동은 함수(method)로 표현됩니다.      객체: 실생활에서 일종의 물건. 속성(Attribute)와 행동(Action)을 가짐   클래스는 객체를 설계하는 청사진과도 같다고 볼 수 있습니다. 또는 붕어빵틀.   다음은 축구 선수 정보를 Class로 구현한 것입니다.   class SoccerPlayer(object):     def __init__(self, name, position, back_number):         self.name = name         self.position = position self.back_number = back_number     def change_back_number(self, new_number):         print(\"선수의 등번호를 변경합니다 : From %d to %d\" % (self.back_number, new_number)) self.back_number = new_number   class SoccerPlayer(object):에서 맨 앞 키워드는 클래스를 정의하는 예약어, 그 다음은 클래스명, 그다음은 상속받는 객체명입니다. __init__은 객체 초기화 예약 함수는 객체 초기화 예약 함수입니다.   파이썬에서 __ 의미   예) __는 특수한 예약 함수나 변수 그리고 함수명 변경(맨글링)으로 사용합니다.   class SoccerPlayer(object):     def __str__(self):           return \"Hello, My name is %s. I play in %s in center \" % \\         (self.name, self.position)  jinhyun = SoccerPlayer(\"Jinhyun\", \"MF\", 10) print(jinhyun)     클래스에서 method(Action) 추가는 기존 함수와 같으나, 반드시 self를 추가해야만 class 함수로 인정됩니다.   Object 이름 선언과 함께 초기값 입력 하는 방법은 다음과 같습니다. jinhyun = SoccerPlayer(\"Jinhyun\", \"MF\", 10)     상속   상속은 부모 클래스로 부터 속성과 함수를 물려받은 자식 클래스를 생성 하는 것이라고 말할 수 있습니다.   다음은 Korean 클래스가 Person 클래스를 상속하는 코드입니다.   class Person(object):     def __init__(self, name, age):         self.name = name         self.age = age  class Korean(Person):     pass  first_korean = Korean(\"Sungchul\", 35) print(first_korean.name)   polymorphism   다형성이란 하나의 메소드나 클래스가 있을 때 이것들이 다양한 방법으로 동작할 수 있다는 것을 의미합니다.  객체 선언시 여러개의 부모 객체가 각기 다른 자식 클래스 종류의 인스턴스를 가지고 있음으로 표현할 수 있습니다.   다른 언어에서는 메소드 오버로딩 이라고 해서 클래스 내에 함수명이 같고 패러메터의 갯수나 타입이 다른것을 의미하는 것이 있습니다. 여기서 메소드를 부를 때 같은 함수 호출 명이 같더라도 패러메터 갯수나 타입을 다르게 해서 호출을 하면 특정 조건에 맞는 함수가 호출이 되는데 이 때 이것을 다형성이라고 할 수 있습니다.   Encapsulation   캡슐화라고 하며 객체의 속성(data fields)과 행위(메서드, methods)를 하나로 묶고, 실제 구현 내용 일부를 외부에 감추어 은닉하는 방법론 입니다.   Inner function   파이썬에서는 함수 내에 또 다른 함수를 선언하여 사용할 수 있습니다.   다음은 Inner function의 한 예 입니다.   먼저 맨 바깥 함수를 호출하면 print_msg 함수는 안에 있는 printer 함수를 호출합니다.  이 때, 안에 있는 함수는 바깥에 있는 매개변수를 참조하여 사용할 수 있습니다.   def print_msg(msg):     def printer():         print(msg)     printer()  print_msg(\"Hello, Python\")   closures   클로저는 위에서 봐던 inner function을 return값으로 반환하는 개념입니다.  another는 inner function를 참조하게 되고, another() 하면 printer()함수가 실행됩니다.   def print_msg(msg):     def printer():       print(msg)     return printer another = print_msg(\"Hello, Python\") another()   Module and Project   모듈은 파이썬 정의와 문장들을 담고 있는 파일입니다. 파일의 이름은 모듈 이름에 확장자 .py 를 붙입니다.  프로그램에서는 작은 프로그램 조각들을 모듈이라고 할 수 있고,이 모듈들을 모아서 하나의 큰 프로그램을 개발합니다.   예를 들어 )   파이썬에서는 Built-in Module 중 하나인 난수를 생성할 수 있는 Random 모듈이 있습니다. 코드에서 랜덤한 값이 필요할 때, 이러한 랜덤 모듈을 레고 블럭 처럼 가져다가 쓸 수 있습니다.   모듈을 가져가 쓸 때는 import 문을 사용해서 module을 호출할 수 있습니다.   import random print (random.randint (0,100)) # 0~100사이의 정수 난수를 생성 print (random.random()) # 일반적인 난수 생성   사용자가 정의한 모듈을 쓰는 예를 보겠습니다.   fah_converter.py 모듈입니다.   def covert_c_to_f(celcius_value):     return celcius_value \\* 9.0 / 5 + 32   그 다음은 module_ex.py 모듈입니다.   import fah_converter  print (\"Enter a celsius value: \"), celsius = float(input()) fahrenheit = fah_converter.covert_c_to_f(celsius) print (\"That's \", fahrenheit, \" degrees Fahrenheit\")   이 프로그램은 사용자로 부터 온도 값을 입력받고 섭씨를 화씨로 변환하는 프로그램입니다.  위에서 보듯이 두개의 .py 파일은 서로 다른 두개의 모듈이라고 볼 수 있습니다.  module_ex.py에서는 섭씨를 화씨로 변환하는 함수를 쓰기 위해 먼저 import fah_converter라고 함으로써 fah_converter.py 모듈을 부릅니다. 그리고 fah_converter.covert_c_to_f(celsius) 모듈명 + . + 쓸 함수명 함으로써 그 기능을 이용하고 있습니다.     패키지   패키지는 하나의 대형 프로젝트를 만드는 코드의 묶음이라고 볼 수 있습니다.  패키지는 모듈을 담을 수 있고, 또 다른 패키지를 담을 수 있습니다.   Package 내에서 다른 폴더의 모듈을 부를 때는 절대 호출과 상대호출 방법이 있습니다.   절대 참조는 루트 디렉터리 부터 타켓이 되는 모듈이나 패키지까지 경로를 적는 방법을 말합니다.  상대 참조는 현재 디렉토리 기준으로 타켓이 되는 모듈이나 패키지까지 경로를 적는 방법을 말합니다.      절대 참조로 호출하는 방법(루트 디렉터리 ) : from game.graphic.render import render_test()   상대 참조로 호출하는 방법(현재 디렉터리는 graphic) : from .render import render_test()   상대 참조로 부모 디렉터리로 갔다가 형재 노드의 패키지로 가는 법 : from ..sound.echo import echo_test()   가상환경   프로젝트 진행 시 필요한 패키지만 설치하는 환경이라고 볼 수 있습니다.  가상환경에는 기본적으로 필요한 인터프리터가 있고, 프로젝트 목적에 따라 각각 필요한 패키지를 설치하여 운용할 수 있습니다.  가상환경은 다양한 패키지 관리 도구를 가지고 있고 사용하고 있습니다.   대표적인 도구 virtualenv와 conda가 있습니다.      virtualenv + pip : 가장 대표적인 가상환경 관리 도구, 레퍼런스 + 패키지 개수   conda : 상용 가상환경도구 miniconda 기본 도구, 설치의 용이성   conda 가상환경을 만들고 사용하는 방법은 다음과 같습니다.   터미널에서 conda create -n my_project python=3.8 를 입력하면 됩니다.  그리고 conda activate my_project를 호출하면 가상환경을 쓸 수 있게 됩니다.   해제할 때는 conda deactivate를 해주면 됩니다.   필요한 패키지를 설치할 때는 conda install &lt;패키지명&gt;를 쓸 수 있습니다.   피어세션 정리   오늘은 조원과 만난 네 번째 날이었고, 서로 인사하며 각자 어제 자기가 공부한 내용이라든지 궁금했던 내용을 서로 발표하며 유익한 세션 시간을 가질 수 있었습니다.   삼일이 지나고 나니 서로 좀 더 친해지고 알아가게 되어서 그런지, 전날 보다 조원들 간의 사이가 좀 더 화목하게 되고, 한 마디에 한 번 웃었다면 이번엔 두 번 웃는 그런 사이가 되어 가는거 같아 좋았습니다.   과제 진행 상황 정리   오늘은 강의도 그렇게 길지 않았고, 둘째 날에 비교해 과제의 개수가 줄어 시간 상 정리 노트를 쓰기 전에 과제를 해결할 수 있었습니다.  이번 과제도 유익한 시뮬레이션/구현 문제가 주어졌고 애매했던 스트링함수 개념을 한 번 더 연습해보고 문제에 접목해 볼 수 있는 좋은 기회였습니다.  문제 조건에 특수문자와 공백 처리를 해야하는 약간의 까다로움이 있었지만, 이때까지 공부한 내용을 바탕으로 잘 해결해 풀 수 있었습니다.   References      파이선 기본문법 3- 최성철 교수님   Python - wikipedia  ","categories": ["Development"],
        "tags": ["AI","Python"],
        "url": "http://localhost:4000/development/boostcamp-week1-day4/",
        "teaser":null},{
        "title": "파이썬 기초문법 4",
        "excerpt":"Exception/File/Log Handling   파이썬에서의 예외처리, 파일 읽고 쓰는 법 그리고 로그 핸들링에 대해서 알아봅니다.   Exception   프로그램 실행되고 런타임 상황에서 여러가지 예상치 못한 예외 상황이 생길 수 있습니다.  예를 들어 배열의 인덱스 범위를 초과해서 접근한다던지, 무한루프에 빠진다던지, 숫자를 0으로 나눈다던지 하는 상황이 있을 수 있습니다.   예외는 크게 두가지로 분류합니다.      예상가능한예외   예상이 불가능한 예외   예상 가능한 예외는 발생여부를 사전에 인지할 수 있는 예외로서 개발자가 명시적으로 정의 할 수 있습니다.  예상 불가능한 예외는 인터프리터 과정에서 발생하는 예외나 리스트의 범위를 넘어가는 값 호출,정수 0 으로 나눔을 들 수 있습니다.   이러한 예외가 발생할 경우 후속 조치 등 대처가 필요합니다.   이것을 Exception Handling이라 합니다.   파이썬의 예외 처리   try:     예외 발생 가능 코드 except &lt;Exception Type&gt;:     예외 발생시 대응하는 코드   0으로 숫자를 나눌 때 예외 처리하기   for i in range(10):     try:         print(10 / i)     except ZeroDivisionError:         print(\"Not divided by 0\")   try ~ except ~ else   for i in range(10):    try:      result = 10 / i    except ZeroDivisionError:      print(\"Not divided by 0\")    else:      print(10 / i)   raise 구문 : 필요에 따라 강제로 Exception을 발생      raise &lt;Exception Type&gt;(예외정보)   while True:     value = input(\"변환할 정수 값을 입력해주세요\")     for digit in value:       if digit not in \"0123456789\":         raise ValueError(\"숫자값을 입력하지 않으셨습니다\")     print(\"정수값으로 변환된 숫자 -\", int(value))   File Handling   파이썬에서는 파일을 불러오기, 쓰기, 읽기, 수정하기 등이 가능합니다.   파일의 종류      기본적인 파일 종류로 text 파일과 binary 파일로 나눔   컴퓨터는 text 파일을 처리하기 위해 binary 파일로 변환시킴 (예: pyc 파일)   모든 text 파일도 실제는 binary 파일,   Binary 파일   컴퓨터만 이해할 수 있는 형태인 이진(법)형식으로 저장된 파일 (엑셀파일, 워드 파일 등등)   Text 파일   인간도 이해할 수 있는 형태인 문자열 형식으로 저장된 파일 (메모장에 저장된 파일, HTML 파일)   Python File I/O   파이썬은 파일 처리를 위해 “open” 키워드를 사용합니다.   f = open(\"&lt;파일이름&gt;\", \"접근 모드\") f.close()      r - 읽기모드 - 파일을 읽기만 할 때 사용   w - 쓰기모드 - 파일에 내용을 쓸 때 사용   a - 추가모드 - 파일의 마지막에 새로운 내용을 추가 시킬 때 사용   파이썬의 File Read   read() txt 파일 안에 있는 내용을 문자열로 반환   f = open(\"i_have_a_dream.txt\", \"r\" ) contents = f.read() print(contents) f.close()  # or  with open(\"i_have_a_dream.txt\", \"r\") as my_file:     contents = my_file.read()     print (type(contents), contents)   파이썬의 File Write   mode는 “w”, encoding=“utf8”   f = open(\"count_log.txt\", 'w', encoding=\"utf8\") for i in range(1, 11):     data = \"%d번째 줄입니다.\\n\" % i     f.write(data)     f.close()   Logging   로그를 남기는 것으로 프로그램이 실행되는 동안 일어나는 정보를 기록하는 것입니다.  특정 유저의 접근이나, 프로그램의 Exception이 발생할 때 또는 특정 함수의 사용을 로그로 남길 수 있습니다.  방법은 Console 화면에 출력, 파일에 남기기, DB에 남기기 등등이 있습니다.   기록을 print로 남기는 것도 가능은 하나 Console 창에만 남기는 기록은 분석시 사용이 불가하다는 단점이 있습니다. 따라서 모듈별로 별도의 logging을 남겨 따로 파일에 저장해 기록을 유지할 필요가 있습니다.   이러한 기능을 체계적으로 지원하는 모듈이 Logging 모듈입니다.   Logging 모듈은 Python의 기본 Log 관리 모듈입니다.   import logging logging.debug(\"틀렸잖아!\") logging.info(\"확인해\") logging.warning(\"조심해!\") logging.error(\"에러났어!!!\") logging.critical (\"망했다...\")   logging level   Log관리 시 가장 기본이 되는 설정 정보로서, 프로그램 진행 상황에 따라 다른 Level의 Log를 출력할 수 있게 합니다. DEBUG &gt; INFO &gt; WARNING &gt; ERROR &gt; Critical      debug : 개발시 처리 기록을 남겨야하는 로그 정보를 남김   info : 처리가 진행되는 동안의 정보를 알림   warning : 사용자가 잘못 입력한 정보나 처리는 가능하나 원래 개 발시 의도치 않는 정보가 들어왔을 때 알림   error : 잘못된 처리로 인해 에러가 났으나, 프로그램은 동작할 수 있음을 알림   critical : 잘못된 처리로 데이터 손실이나 더이상 프로그램이 동 작할 수 없음을 알림   Python data handling   데이터는 여러 형태로 저장이 될 수 있습니다.  csv, html, xml json 등..  오늘은 여기서 csv와 json 데이터 형식을 다루는 방법을 알아봅니다.   Comma Separate Value   CSV, 필드를 쉼표(,)로 구분한 텍스트 파일입니다.  엑셀 양식의 데이터를 프로그램에 상관없이 쓰기 위한 데이터 형식이라고 생각하면 쉽습니다.  탭(TSV), 빈칸(SSV) 등으로 구분해서 만들기도 합니다.   CSV 파일 예시 )   학번,이름,성별,나이,사는곳 01,권아름,여자,23,서울 23,서아인,여자,21,부산 35,박희원,남자,23,인천   다음은 CSV 파일 읽기 예제입니다   line_counter = 0 #파일의 총 줄수를 세는 변수 data_header = [] #data의 필드값을 저장하는 customer_list = [] #cutomer 개별 List를 저장하는 List  with open (\"customers.csv\") as customer_data: #customer.csv 파일을 customer_data 객체에 저장  while True:     data = customer_data.readline() #customer.csv에 한줄씩 data 변수에 저장     if not data: break #데이터가 없을 때, Loop 종료     if line_counter==0: #첫번째 데이터는 데이터의 필드         data_header = data.split(\",\") #데이터의 필드는 data_header List에 저장, 데이터 저장시 “,”로 분리     else:         customer_list.append(data.split(\",\")) #일반 데이터는 customer_list 객체에 저장, 데이터 저장시 “,”로 분리     line_counter += 1  print(\"Header :\\t\", data_header) #데이터 필드 값 출력 for i in range(0,10): #데이터 출력 (샘플 10개만)   print (\"Data\",i,\":\\t\\t\",customer_list[i]) print (len(customer_list)) #전체 데이터 크기 출력   CSV 객체로 CSV 처리   위에서 보았듯이, Text 파일 형태로 데이터 처리 시 문장 내에 들어가 있는 “,” 등에 대해 전처리 과정이 필요한데요, 파이썬에서는 간단히 CSV파일을 처리하기 위해 csv 객체를 제공합니다.   CSV 객체 활용      delimiter: 글자를 나누는 기준   quotechar: 문자열을 둘러싸는 신호 문자   quoting: 데이터 나누는 기준이 quotechar에 의해 둘러싸인 레벨   import csv reader = csv.reader(f,           delimiter=',', quotechar='\"',           quoting=csv.QUOTE_ALL)   JSON   JavaScript Object Notation이라고 하며, 웹의 동적성을 표현하는데 쓰이는 언어인 Java Script의 데이터 객체 표현 방식입니다.  주로 서버와 클라이언트 사이에서 http 통신을 하며 데이터를 주고 받는 데, 그 때 들어가는 패싱 데이터로 많이 쓰입니다.  간결성으로 기계/인간이 모두 이해하기 편합니다.   JSON은 key:value 쌍으로 표현이 됩니다.   ```java script {“employees”:[     {“firstName”:”John”,     “lastName”:”Doe”     },     {“firstName”:”Anna”,     “lastName”:”Smith”     },     {“firstName”:”Peter”,     “lastName”:”Jones”     } ]}   **JSON Read**  파이썬에서는 JSON을 불러와 읽고, 처리할 수 있습니다.   JSON 파일의 구조를 확인 후 읽고, Dict Type 처럼 처리하면 됩니다.  1. json을 처리할 수 있는 모듈을 임포트 합니다. 2. with open으로 파일을 엽니다. 3. 파일을 읽어 이를 contens에 넣습니다. 4. 모듈을 이용해 json파일을 파이선에서 쓸 수 있도록 dict type으로 로드합니다. 5. 이제 json_data를 dict처럼 쓸 수 있습니다.  ```python # json_example.json  {\"employees\":[     {\"firstName\":\"John\",     \"lastName\":\"Doe\"     },     {\"firstName\":\"Anna\",     \"lastName\":\"Smith\"     },     {\"firstName\":\"Peter\",     \"lastName\":\"Jones\"     } ]}  #######  import json  with open(\"json_example.json\", \"r\", encoding=\"utf8\") as f:     contents = f.read()     json_data = json.loads(contents)     print(json_data[\"employees\"])   JSON Write   위와 비슷하게 사전에 dict를 정의하고, 이를 json으로 변환하여 처리할 수 있습니다. Dict Type으로 데이터 저장 후 josn 모듈로 Write      json을 처리할 수 있는 모듈을 임포트 합니다.   Dict Type으로 데이터를 정의합니다.   data.json 파일을 쓰기 모드로 엽니다.   json.dump를 이용해 쓰기를 실행합니다.   import json dict_data = {'Name': 'Zara', 'Age': 7, 'Class': 'First'} with open(\"data.json\", \"w\") as f:     json.dump(dict_data, f)   피어세션 정리   드디어 부스트 캠프 1주차가 마무리 되었습니다.   오늘도 각자 조원이 돌아가며 어제 자신이 했던 공부와 오늘 할 공부 계획을 발표하고, 서로 좋았던 내용이나 참고할 만한 내용이 있다면 그것을 공유하는 시간을 가질 수 있었습니다.   어떤분은 자신이 정리한 노트를 사용해 발표를 하셧고, 어떤분은 공부에 도움이 될만한 좋은 리소스 자료를 공유해 주셧습니다.   저는 일주일 동안 배운 내용 중 약간 애매하거나 혼동이 오는 개념들을 다시 한번 쭉 보면서 이것을 모아 그림판에 스크린샷으로 정리해서 조원들에게 설명을 하는 시간을 가졌었습니다.   확실히, 전날 보다 조금 더 친해진 모습으로 다같이 협동하여 세션을 진행할 수 있음에 기분이 좋았습니다.   그리고 저희 조는 1주일 간격으로 모더레이터를 맡게 되는데, 그래서 다음주를 담당할 모더레이터를 정하는 시간을 가졌었습니다.   References      파이선 - 최성철 교수님   Python - wikipedia  ","categories": ["Development"],
        "tags": ["AI","Python"],
        "url": "http://localhost:4000/development/boostcamp-week1-day5/",
        "teaser":null},{
        "title": "Numpy / 벡터 / 행렬",
        "excerpt":"Numpy / 벡터 / 행렬   넘파이는 과학계산에서 많이 사용하는 선형대수의 계산식을 파이썬으로 구현할 수 있도록 도와주는 라이브러리입니다. 모든 데이터 분석과 인공지능 학습에 있어 가장 필수적으로 사용되고 이용되므로 간단한 예제들과 함께 알아봅니다.   벡터는 딥러닝에서 매우 중요한 선형대수학의 기본 단위가 되고, numpy에서도 굉장히 많이 사용되는 연산이기 때문에 확실하게 알 필요가 있습니다.   행렬은 딥러닝에서 가장 핵심적인 연산이라고 볼 수 있을만큼 중요하고, 자주 사용됩니다.  행렬이 가지는 기하학적 의미와 머신러닝에서 어떻게 사용되는지 알아봅니다.   Numpy   넘파이는 과학계산에서 많이 사용하는 선형대수의 계산식을 파이썬으로 구현할 수 있도록 도와주는 라이브러리입니다.      Numerical Python   파이선의 고성능 과학 계산용 패키지   Matrix와 Vector 와 같은 Array 연산의 사실상의 표준   특징      일반 리스트에 비해 빠르고 효율적   반복문 없이 데이터 배열에 대한 처리 지원   선형대수와 관련된 다양한 기능을 제공   import   넘파이의 호출 방법입니다.  일반적으로 np라는 별칭을 이용해서 호출합니다. (세계적인 약속 같은 것)   import numpy as np   array creation   test_array = np.array([1, 4, 5, 8], float) print(test_array) # array([1., 4., 5., 8.])  넘파이는 np.array라는 함수를 활용해서 배열을 생성합니다. 넘파이에는 하나의 데이터 타입만 배열에 넣을 수 있습니다.   array shape      shape : array의 크기, 형태 등에 대한 정보   다른 프로그래밍 언어와 같이 다음과 같이 선언하고 특정 값으로 초기화 할 수 있습니다.   arr_shape = np.array([[1,2,3,4],[1,2,3,4]]).shape print(arr_shape) # (2,4)      ndim - number of dimension   size - number of data(element)   array type      array의 single element가 가지는 데이터 타입   각 element가 차지는 메모리의 크기가 결정됨   int8, int16, float32, float64, str 등이 있습니다.   array reshape      reshape : Array의 shape의 크기를 변경할 수 있습니다. size는 동일.   다음은 2x4의 매트릭스를 1차원의 원소 8개를 가지는 벡터로 변환하는 코드입니다.   arr = np.array([[1,2,3,4],[1,2,3,4]]) np.array(arr).shape # (2, 4) np.array(arr).reshape(8,) # array([1, 2, 3, 4, 1, 2, 3, 4]) np.array(arr).reshape(8,).shape # (8,)   indexing for numpy array   리스트와 달리 2차원 배열에서 [0, 0]표기법을 제공합니다.  매트릭스일 경우는 앞은 row, 뒤는 column을 의미합니다.   a = np.array([[1, 2, 3], [4.5, 5, 6]], int) print(a) print(a[0,0]) # Two dimensional array representation #1 print(a[0][0]) # Two dimensional array representation #2 a[0,0] = 12 # Matrix 0,0 에 12 할당 print(a) a[0][0] = 5 # Matrix 0,0 에 12 할당 print(a)   리스트와 달리 행과 열 부분을 나워서 슬라이싱이 가능합니다.  이는 매트릭스의 부분집합을 추출할 때 유용합니다.   a = np.array([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]], int) a[:,2:] # 전체 Row의 2열 이상 # array([[3, 4, 5], [8, 9, 10]]) a[1,1:3] # 1 Row의 1열 ~ 2열 # array([7, 8, 9]) a[1:3] # 1 Row ~ 2Row의 전체 # array([6, 7, 8, 9, 10])   arange   array의 범위를 지정하여, 값의 list,fmf 생성하는 명령어 입니다.   np.arange(5) # array([0, 1, 2, 3, 4]) np.arange(1, 5) # array([1, 2, 3, 4])  np.arange(1,5).reshape(2, 2) # array([[1, 2], [3, 4]])   zeros, ones   0또는, 1로 채워진 ndarray를 생성하는 함수   #zeros : np.zeros(shape=(5,)) # array([0, 0, 0, 0, 0]) np.zeros(shape=(2,2)) # array([[0, 0], #        [0, 0]])  #ones : np.ones(shape=(3,)) # array([1,1,1])   sum / mean / std   ndarray의 element들 간의 합을 구하거나 평균 또는 표준편차를 구하는 기능의 함수입니다.   arr = np.arange(1,5).sum(dtype=np.int) # 10  test_array np.arange(1, 13).reshape(3, 4) test_array # array([[1,2,3,4], #         5,6,7,8], #         9,10,11,12)  test_array.mean() # 6.5  test_array.std() # 3.4520525295346629   이 외에도 다양한 수학 연산자 함수를 제공합니다.   ex) exp, log, log10, power, sqrt, sin cos, tan, cosh…   Dot product   매트릭스의 dot product 계산에 쓰이는 함수입니다.   test_a = np.arange(1, 7).reshape(2, 3) test_b = np.arange(7, 13).reshape(3, 2)  test_a.dot(test_b) # array([[58, 64], [139, 154]])   broadcasting   shape이 다른 배열 간 연산을 지원하는 기능입니다.   test_matrix = np.array([[1,2,3],[4,5,6]]) scalar = 3 #덧셈 test_matrix + scalar # array([[4, 5, 6], #        [7, 8, 9]])  # 곱셈 test_matrix * scalar # array([[3, 6, 9], #        [12, 15, 18]])   All &amp; Any   a = np.arange(10) a # array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) np.any(a&gt;5), np.any(a&lt;0) # (True, False) np.all(a&gt;5), np.any(a&lt;10) # (False, True)   벡터   벡터는 숫자를 원소로 가지는 리스트 또는 배열이라고 볼 수 있습니다.      벡터는 공간에서 한점을 나타냅니다.      벡터는 숫자르 원소로 가지는 리스트로서 백터끼리 같은 모양을 가지면 덧셈, 뺄셈, 성분곱이 가능합니다.      벡터의 뺄셈   두 벡터의 뺄셈은 다른 벡터로 부터 상대적 위치이동을 표현합니다.  벡터의 뺄셈은 방향을 뒤집은 덧셈입니다.  대수적으로 보면 : x = [1 ,2], y = [5, 3] 이란 두개의 벡터가 있을 때 y - x 뺄셈을 하면 -&gt; [4, 1]이 됩니다.      백터의 노름   벡터의 노름은 원점에서부터의 거리를 말합니다.   L1 노름과 L2노름이 있습니다.      L1-노름은 각 성분의 변화량의 절대값을 모두 더합니다.   L2-노름은 피타고라스 정리를 이용해 유클리드 거리를 계산합니다.      두 벡터 사이의 각도 구하기   두 벡터 사이의 거리는 제2 코사인 법칙에 의해 두 벡터 사이의 각도를 계산 가능  그리고 분자는 더욱 간단히 내적으로 구할 수 있다.      내적 해석하기   내적은 정사영된 벡터의 길이와 관련 있다.  proj(x)의 길이는 코사인 법칙에 의해 x의 노름 x cos(theta)가 된다.  내적은 정사영의 길이를 벡터 y의 길이 만큼 조정한 값이 된다.      행렬      행렬(matrix)은 벡터를 원소로 가지는 2차원 배열입니다.   행렬은 행(row)과 열(column)이라는 인덱스(index)를 가집니다.   행렬의 특정 행(열)을 고정하면 행(열)벡터라 부릅니다.         벡터가 공간에서 한 점을 의미한다면 행렬은 여러 점들을 나타냅니다.   행렬의 행벡터 xi 는 i 번째 데이터를 의미합니다.   행렬의 xij 는 i 번째 데이터의 j 번째 변수의 값을 말합니다.      행렬에서의 스칼라곱      성분곱은 벡터와 똑같습니다. 스칼라곱도 벡터와 차이가 없습니다.      행렬에서의 곱셈   행렬 곱셈은 i번째 행벡터와 j번째 열벡터 사이의 내적을 성분으로 가지는 행렬을 계산합니다.      역행렬 이해하기      어떤 행렬 A 의 연산을 거꾸로 되돌리는 행렬을 역행렬(inverse matrix)이 라 부르고 A−1 라 표기한다.  역행렬은 행과 열 숫자가 같고 행렬식(determinant)이 0이 아닌 경우에만 계산할 수 있다. (ad-bc != 0)         만일 역행렬을 계산할 수 없다면 유사역행렬(pseudo-inverse) 또는 무어-펜로즈(Moore-Penrose) 역행렬 A+ 을 이용한다.      피어세션 정리   두번째 주차 첫 날 모임이었습니다.  오늘은 새로운 모더레이터가 선출되고, 부스트캠프의 시간표가 조금 바뀜에 따라 피어 플랜을 다시 재정비 하기로 했습니다.  회의를 통해 의견이 모아졌고, 기존에 하던 “어제 무엇을 하였고, 오늘의 공부 계획은?” 계속 진행하고, 이제 edwith에는 오늘 다룬 토픽에 대해 좀 더 알아보기란 목록으로 “further question”이 추가 된다고 하여, 이와 묶어 당일 다뤄진 내용 중 다소 어렵거나 이해가 안간 내용과 같이 피어들과 같이 회의하고 공부하기로 하였습니다.   퀴즈 정리   벡터           다음 백터의 L-1 노름을 구하라.       x=[−1,2,−3]       각 요소의 절대값의 합이 답이 됩니다.            다음 백터의 L-2 노름을 구하라.       x = [-6, -8]x=[−6,−8]       각 요소의 제곱의 총합에 제곱근을 취한 값이 답이 됩니다.            L2-노름을 이용하여 다음 두 벡터 사이의 거리를 구하시오 (정수값으로 입력).       x=[−3,0]  y=[0,4]       두 벡터의 뺄셈을 하여 L-2 노름을 취한 값이 거리가 됩니다.            다음 두 벡터 사이의 각도를 구하시오 (라디안 단위: 0 이상, 7 미만의 정수값으로 입력)       x=[0,1] y=[0,2]       theta = arccos * (x와y의 내적) / (x의 노름 * y의 노름)으로 구해도 되고,  이 벡터의 경우에는 두 벡터가 정확히 같은 방향(포개어져 있음)이므로 각이 0도 입니다.            내적이 다음과 같이 정의될 때, 다음 두 벡터 ( x, y )의 내적을 구하시오 (정수값으로 입력).       x=[1,−1,1,−1] y=[4,−4,4,−4]       [x, y] 의 내적 = x의 노름 * y의 노름 * cos(theta)로 구할 수 있습니다.       행렬           다음 보기 중 행렬 X 의 올바른 전치행렬을 고르시오.       T한 행렬을 구하라는 의미입니다.  성분 i와j를 서로 바꾸어준 위치를 생각하면 됩니다.            두 행렬의 곱셈은 각 행렬의 모양과 상관없이 가능하다? (O,X) 문제       두 행렬의 곱셈은 앞의 행렬의 열과 뒤의 행렬의 행의 개수가 맞아야 합니다.            어떠한 행렬의 역행렬은 항상 계산할 수 있다. (O,X) 문제       2차원 정사각행렬을 예로 들면, ad-bc = 0 이 아니면 역행렬이 존재하지 않습니다.            다음 보기 중 행렬 XX 의 올바른 역행렬을 고르시오.       수반행렬을 사용해 구해도 되고, 가우스 조던 소거법을 이용해 풀어도 좋습니다.  어떤분은 넘파이 함수를 이용해 푸셧다고 합니다.            다음 보기 중 행렬 X 의 올바른 무어-펜로즈 역행렬을 고르시오.       저는 강의에서 배운대로 $A = A^{+}b = A^{T} \\big(AA^{T}\\big)^{-1}b$를 하여 답을 구할 수 있었습니다.       References      Mathematics for Artificial Intelligence - Unist 임성철 교수님  ","categories": ["Development"],
        "tags": ["AI","Python"],
        "url": "http://localhost:4000/development/boostcamp-week2-day6/",
        "teaser":null},{
        "title": "경사하강법 (Gradient Descent)",
        "excerpt":"경사법   경사법은 최솟값을 찾나, 최댓값을 찾나에 따라 경사하강법과 경사상승법으로 나뉩니다.   기계학습 문제 대부분은 학습 단계에서 최적의 매개변수를 찾아야 합니다. 최적이란 손실 함수가 최솟값이 될 때의 매개변수 값 입니다.   기울기를 잘 이용해 손실 함수의 최솟값을 찾으려는 것이 경사하강법 입니다.   미분   우리가 찾는 손실 함수의 최솟값을 만들기 위해서는 특정 지점에서의 함수 값을 미분하고, 이를 학습률과 곱한 값을 매개변수에서 빼주게 됩니다. 미분한 값이 기울기인데, 이 기울기가 음수인지 양수인지에 따라 우리가 찾고자 하는 목적함수의 최솟값으로의 최적 매개변수의 방향을 알려줍니다.      미분(differentiation)은 변수의 움직임에 따른 함수값의 변화를 측정하기 위한 도구로 최적화에서 제일 많이 사용하는 기법입니다.   최근에는 미분을 손으로 계산하기 보다는 잘 만들어진 프로그램을 이용해 미분 값을 계산합니다.      미분 값은 함수 f의 주어진 점 (x, f(x)) 에서의 접선의 기울기라고 할 수 있습니다.  한 점에서 접선의 기울기를 알면 어느 방향으로 점을 움직여야 함수값이 증가하는지/감소하는지 알 수 있습니다.   경사상승법   미분값을 더하면 경사상승법(gradient ascent)이라 하며 함수의 극대값의 위치를 구할 때 사용합니다.      밑의 그림에서 볼 수 있듯이, 미분 값인 기울기가 음수인데, 이는 x가 감소하면 f(x)의 값은 증가를 하게 된다는 말입니다.   그래서, 경사상승법에서는 x에서 f’(x) &lt; 0 을 더해주게 되면 x값은 감소하고, f(x)값은 증가를 하게 됩니다.      경사하강법   미분값을 빼면 경사하강법(gradient descent)이라 하며 함수의 극소값의 위치를 구할 때 사용합니다.      밑의 그림에서 볼 수 있듯이, 이번에는 미분 값이 양수인데, 이는 x가 감소하면 f(x)의 값도 감소를 하게 된다는 말입니다.   그래서, 경사하강법에서는 x에서 f’(x)를 빼주게 되면 x값은 감소하고, f(x)값도 감소를 하게 됩니다.        미분 값 = 기울기 = 0   경사상승/경사하강 방법은 극값에 도달하면 움직임을 멈추게 됩니다.      변수가 벡터라면   벡터가 입력인 다변수 함수의 경우 편미분(partial differentiation)을 사용하게 됩니다.   편미분이란, 미분하고자 하는 변수 이외의 다른 변수는 전부 상수로 보고 미분하는 것을 말합니다.   밑의 왼쪽식은 f(x,y)에서, 변수 x에 대해서 편미분을 한 계산입니다.  밑의 오른쪽 코드는 sympy를 이용해 다항함수의 편미분을 계산하는 것입니다.      그리고, 각 변수 별로 편미분을 계산한 그레디언트(gradient) 벡터를 이용하면 경사하강/경사상승법에 사용할 수 있습니다.   경사하강법으로 선형회귀 계수 구하기   우리가 찾고자 하는 최적의 매개변수의 개수보다 데이터의 개수가 더 많을 때 즉, n &gt; m일 때, XW = Y 에서, 우리는 W를 X의 유사역행렬을 구해 다음과 같은 식으로 구할 수 있었습니다. $W = X^{+}Y$   또 다른 방법은 경사하강법을 이용하여 구할 수도 있습니다.  선형회귀의 목적식은 ∥y − Xβ∥2 (손실 함수) 이고 이를 최소화하는 β를 찾음으로 구할 수 있고, 우리는 이 β를 구하기 위해 다음과 같은 그레디언트 벡터를 구해야 합니다.      주의할 점은 y-Xβ의 L2 노름과 비슷하지만, 여기서는 레이블 값(y)과 예측 값(Xβ)의 차이의 제곱을 한다음 전부를 더해 전체 데이터의 개수로 나누어줬다는 점입니다.  이렇게 기존의 L2 노름에서 전체 데이터의 개수로 나누주었을 때는, 이 손실 함수를 평균이 들어간 평균 최소 제곱 오차 - mean square error 라고 합니다.   위의 식에 대해서 모든 매개변수 벡터에 대해 각각 편미분을 해서 정리하면 밑의 그림과 같은 식을 얻을 수 있습니다.      복잡해 보이지만, 기본적인 미분(겉미분, 속미분)과 편미분을 할줄 알고 스칼라 백터 미분을 할줄 아신다면 충분히 식을 유도해 낼 수 있습니다.   그리고 목적식을 최소화하는 β를 구하는 경사하강법은 위에서 본 것과 똑같이 적용할 수 있습니다.   경사하강법의 문제   이론적으로 경사하강법은 미분가능하고 볼록(convex)한 함수에 대해선 적절한 학습률과 학습횟수를 선택했을 때 수렴이 보장되어 있습니다.   특히 선형회귀의 경우 목적식 ∥y − Xβ∥2 은 회귀계수 β 에 대해 볼록함 수이기 때문에 알고리즘을 충분히 돌리면 수렴이 보장됩니다.      하지만 비선형회귀 문제의 경우 목적식이 볼록하지 않을 수 있으므로 수렴이 항상 보장되지는 않습니다.  전역 최적해가 아닌 지역 최적해에 빠질 수도 있기 때문입니다.      확률적 경사하강법   위에서 본, 경사하강법의 문제를 보완하기 위해 나온 것이 확률적 경사하강법이란 것입니다.   확률적 경사하강법(stochastic gradient descent)은 모든 데이터를 사용해 서 업데이트하는 대신 데이터 한개 또는 일부 활용하여 업데이트합니다.   그래서, 볼록이 아닌(non-convex)목적식도 SGD를 통해 최적화할 수 있습니다      즉, 확률적 경사하강법의 원리는 미니배치 연산에 있습니다.   경사하강법은 전체데이터 𝒟 = (X, y) 를 가지고 목적식의 그레디언트 벡터인 ∇θL(𝒟,θ)를 계산하는 데 반해, SGD 는 미니배치 𝒟(b) = (X(b), y(b)) ⊂ 𝒟 를 가지고 그레디언트 벡터를 계산합니다.그래서, 미니배치는 확률적으로 선택하므로 목적식 모양이 랜덤하게 바뀌게 됩니다.      만역 목적함수가 Non convex한 함수이고, 일반적인 경사하강법을 적용하면 전역최적해에 도달하기 전에 지역 최적해에 빠져 계산이 멈출 수도 있습니다. 이는 모든 데이터 셋을 활용하여 계산한 값으로서 더 이상 이 지역 최적해에서 벗어날 수가 없습니다.   하지만 확률적 경사하강법은 매 연산마다 랜덤한 샘플의 미니배치를 뽑아 그레디언트를 계산 하므로, 우리의 목적 함수의 형태가 매번 바뀌게 되고, 이는 확률적으로 지역 최적해 에서 벗어나 전역 최적해에 도달하게 합니다.   피어세션 정리   두 번째 주차 둘째 날 모임이었습니다.  오늘은 어제의 룰에 따라 다 같이, further question 논의 해보기로 하였습니다.  오늘의 further question은 주어진 목적함수의 그레디언트를 손으로 계산해보기 였습니다.  이 문제에 대해 각자 어떻게 방법을 적용하였는지 논의 할 수 있었고, 또 이 문제가 어렵다는 분도 다른 분의 해설과 해결 방법을 듣고 “아하” 소리가 나올 만큼 의미가 있는 시간이 되었던거 같습니다.  나머지 시간은 앞으로 다뤄질 역전파, 통계학 등등에 대해 논의하였고, 서로 공부하기 전에 찾아보거나 좋은 리소스가 있으면 공유하는 시간을 가졌었습니다.   퀴즈 정리   벡터           $f(x,y)$가 다음과 같이 정의될 때, $\\frac{ \\delta f(x,y) }{ \\delta x }$를 구하시오 (정수값으로 입력).       $f(x,y)=9y^{2}+3y+9x+3$       이는 x에 대해서 편미분 하라는 뜻이고, x 이외의 나머지 변수에 대해서는 전부 상수로 보고 미분을 진행하면 되는 문제였습니다.            미분이 가능한 함수 $f$ 에 대해, 주어진 점 $(x, f(x))(x,f(x))$ 에서의 접선의 기울기가 음수라면, $x$ 를 증가시키면 함수값 $f(x)$가 증가한다? (O,X 문제)       기울기가 음수라면, x값이 증가할 때는 반대로 함수의 값은 감소하게 됩니다.            다음 보기 중 함수의 극소값의 위치를 구할 때 사용하는 방법을 고르시오.       여러개의 보기 중 위에서 우리는 함수의 극소값의 위치를 구할 때 사용하는 방법을 공부했고, 이에 따라 배운 내용을 고르면 되는 문제였습니다.            경사하강법을 사용하여 구한 함수의 극소값의 위치는 해당 함수의 최소값의 위치가 아닐 수 있다.       경사하강법을 이용한 극소값은 Non convex(볼록하지 않은 함수)에서 지역해에도 해당이 될 수 있습니다. 그래서 최소값의 위치가 아닐 수도 있습니다.            다음 보기 중 $f(x, y, z)$의 올바른 그래디언트 벡터를 고르시오.       $f(x,y,z)=9x^{2}+5y^{3}−3z$       변수 $x,y,z$에 대해 각각 편미분 한 값의 벡터가 답이 됩니다.       $x$에 대해서 편미분하면 첫 번째 텀인 $18x$가 계산되고 나머지는 상수 취급되어 사라집니다.  $y$에 대해서 편미분하면 두 번째 텀인 $15y^{2}$가 계산되고 나머지는 상수 취급되어 사라집니다.  $z$에 대해서 편미분하면 세 번째 텀인 $-3$이 계산되고 나머지는 상수 취급되어 사라집니다.       References      Mathematics for Artificial Intelligence - Unist 임성철 교수님  ","categories": ["Development"],
        "tags": ["AI","Python"],
        "url": "http://localhost:4000/development/boostcamp-week2-day7/",
        "teaser":null},{
        "title": "Pandas / 딥러닝 학습방법 이해하기",
        "excerpt":"판다스 / 역전파 알고리즘   판다스는 구조화된 데이터의 처리를 지원하는 Python 라이브러리입니다.  고성능 array 계산 라이브러리인 numpy와 통합하여, 강력한 “스프레드시트” 처리 기능을 제공하므로 Data science 분야애서 널리 쓰이는 판다스를 알아봅니다.     기계학습 문제 대부분은 학습 단계에서 최적의 매개변수를 찾아야 합니다. 최적의 매개변수란 손실 함수가 최솟값이 될 때의 매개변수 값 입니다.   그런데 딥러닝에서는 여러 뉴런들이 여러 층을 형성하여 구성이 될 수 있고, 끝 출력층의 매개변수 뿐만 아니고 뒤의 각 층에 할당된 매개변수가 업데이트 되어야 올바른 학습이 될 수 있는데, 이 각각의 매개변수들을 학습시키는 것이 역전파법 이라고 할 수 있습니다.   판다스   구조화된 데이터의 처리를 지원하는 Python 라이브러리로서 고성능 array 계산 라이브러리인 numpy와 통합하여, 강력한 “스프레드시트” 처리 기능을 제공합니다.   데이터를 잘라서 볼 수 있는 인덱싱, 각종 연산에 필요한 함수, 데이터를 알맞게 다듬을 수 있는 전처리 함수 등을 제공하고 있습니다.   주로, 데이터 처리 및 통계 분석을 위해 사용되고 있습니다.   판다스 설치      conda에서 가상환경을 생성하고, 그 환경 안에 판다스를 설치합니다.   jupyter notebook에서 작업하기 위해 jupyter notebook이라고 입력합니다.   conda create -n ml python=3.8 # 가상환경생성 activate ml # 가상환경실행 conda install pandas # pandas 설치  jupyter notebook # 주피터 실행하기   데이터 로딩   밑의 그림에서 볼 수 있듯이, 판다스를 임포트하고 데이터가 있는 주소를 가져와 판다스의 csv를 읽는 객체에 연결시켜준 모습을 볼 수 있습니다.      pandas의 구성   판다스의 데이터셋은 크게 두가지인 시리즈 객체와 데이터프레임 객체로 볼 수 있습니다.      Series : DataFrame 중 하나의 Column에 해당하는 데이터의 모음 Object, column vector를 표현하는 object   DataFrame : DataTable 전체를 포함하는 Object, Series를 모아서 만든 Data Table = 기본 2차원      dataframe indexing   데이터 프레임에서 인덱스를 이용하여 자유자제로 데이터를 인덱싱 해볼 수 있습니다.      loc : 행의 인덱스 값 자체(이름)를 이용해 인덱싱을 수행합니다.   iloc – 행의 인덱스(위에서 부터 순서대로 0, 1, 2…)를 이용해 인덱싱을 수행합니다.      Selection with column names   데이터 프레임 객체에서 여러 칼럼이 있을거지만, 특정 칼럼 네임만 특정해서 데이터를 모아 볼 수 있습니다.   형식은 DataFrame_name['col_name'] or DataFrame_name[['col_name1', 'col_name2',]] 입니다.   특정 한개의 칼럼네임으로만 지정한다면 시리즈 객체로 데이터가 반환이 되고, 여러개는 데이터 프레임 객체로 반환이 됩니다.      df[\"account\"][:3] 처럼, column 이름과 함께 row index 사용 시 몇번 째 데이터 까지만 가져올지 정할 수 있습니다.      data drop   데이터 프레임 객체에서 행의 데이터를 삭제하는 방법은 drop이라는 빌트인 함수를 씀으로 수행이 가능합니다.   하나의 행만 삭제하고자 할 때는 삭제하고자 하는 행의 인덱스 넘버를, 한 개 이상의 행을 삭제하고자 할 때는 리스트 형식으로 인덱스 넘버를 drop 함수 arguement에 넣어주면 됩니다.       또는 칼럼 네임을 지정해 주어 칼럼 전체를 삭제할 수도 있습니다.      dataframe operation   판다스는 시리즈 객체끼리 또는 시리즈와 데이터 프레임 객체 끼리의 더하고 빼고 나누는 등의 연산을 지원합니다.      Operation types: add, sub, div, mul   시리즈와 시리즈끼리는 인덱스를 기준으로 연산을 수행합니다.  이 때, 겹치는 인덱스가 없을 경우는 NaN값을 반환합니다.      데이터 프레임 객체 끼리는 column과 index를 모두 고려합니다.  서로 column과 index 겹치는 구간이 없을 때는 NaN으로 채워지게 됩니다.  fill_value를 씀으로써 NaN을 특정 값으로 매핑할 수도 있습니다.      pandas map   pandas의 series type의 데이터에도 map 함수가 사용이 가능합니다.   통상 map의 기능은 어떤 값을 받아서 map 안에서 정의된 함수나 여러 프로시저에 의해 그 값이 변화되어 반환되게 하는 함수를 의미합니다. 이를 전체 데이터에 대해 수행합니다.   예제는 0-9까지의 값을 가지는 시리즈 객체를 만들고, 앞에서 부터 5개를 조회하는 연산입니다.  그 다음, map 함수에 익명 함수 람다를 넣어 각 시리즈 객체의 값 들을 전부 제곱하게 됩니다.      map 함수에 function 대신 대신 dict, sequence형 자료등으로 대체 가능합니다.      역전파 알고리즘   기계학습 문제 대부분은 학습 단계에서 최적의 매개변수를 찾아야 합니다. 최적의 매개변수란 손실 함수가 최솟값이 될 때의 매개변수 값 입니다.   그런데 딥러닝에서는 여러 뉴런들이 여러 층을 형성하여 구성이 될 수 있고, 끝 출력층의 매개변수 뿐만 아니고 뒤의 각 층에 할당된 매개변수가 업데이트 되어야 올바른 학습이 될 수 있는데, 이 각각의 매개변수들을 학습시키는 것이 역전파법 이라고 할 수 있습니다.   신경망을 수식으로 분해해보기      위의 그림과 같은 신경망 모델은 다음과 같은 백터와 행렬들의 조합으로 표현될 수 있습니다.      O 행렬은 해당 층에서의 출력 값을 의미하게 됩니다.  이는 행렬 X와 학습 매개변수 W의 내적 값 그리고 바이어스 텀을 더함으로써 계산이 되게 됩니다.   각 행벡터 oi 는 데이터 xi 와 가중치 행렬 W 사이의 행렬곱과 절편 b 벡터의 합으로 표현이 됩니다.   oi = xi (행렬곱) W + bias vector   oi 백터의 값의 계산을 풀어쓰면 다음과 같습니다.   o1 벡터의 첫 번째 값의 계산은 먼저 x1벡터와 w11 ~ wd1까지의 벡터의 내적 값 + b1로 계산이 됩니다.   o1 벡터의 두 번째 값의 계산은 x1벡터와 w12 ~ wd2까지의 벡터의 내적 값 + b2로 계산이 됩니다.   나머지 데이터에 대해서도 이와 마찬가지로 계산이 수행됩니다.   데이터가 바뀌면 결과값도 바뀌게 됩니다. 이 때 출력 벡터의 차원은 d 에서 p 로 바뀌게 됩니다.   소프트맥스 연산   소프트맥스(softmax) 함수는 모델의 출력을 확률로 해석할 수 있게 변환해 주는 연산입니다 분류 문제를 풀 때 선형모델과 소프트맥스 함수를 결합하여 예측합니다.      이와 같이 출력 값(벡터, 행렬)에 비선형 함수인 소프트맥스라는 함수를 통과시켜주게 되면 확률 백터가 되고 이는 특정 클래스 k에 속할 확률로 해석할 수 있습니다.      신경망은 선형모델과 활성함수를 합성한 함수   앞서 데이터와 매개변수 행렬을 행렬곱을 하고 그리고 바이어스 텀을 더하여 복잡한 선형모델을 만들었습니다.  신경망은 선형모델에서 나온 출력 값을 비선형 활성 함수와 합성해 만든 또 다른 함수를 말합니다.      활성함수란   활성함수(activation function)는 비선형(nonlinear) 함수 로서 딥러닝에서 매우 중요한 개념입니다.  활성함수는 선형모형의 출력을 비선형하게 변환해주는 역할을 합니다.  시그모이도(sigmoid) 함수나 tanh 함수는 전통적으로 많이 쓰이던 활성함수 지만 딥러닝에선 ReLU 함수를 많이 쓰고 있습니다.      다층 신경망   앞서 살펴본 신경망을 여러개 층으로 쌓은 것이 다층 신경망입니다.      처음 계산된 Z(1)의 값이 활성함수를 통과해 H(1)이 되면 여기까지 한 층의 계산 입니다.  다시 H(1)이 다른 층으로에 입력 값으로 들어가 W(2)와 행렬곱이 되고 바이어스 텀이 더해져 Z(2)가 되고, Z(2)가 활성함수 층을 통과하면 H(2)가 됩니다.  이 출력 값을 계산 다음 층으로의 입력으로 넣어 계산을 수행하게 되고, 이를 다층 신경망이라고 합니다.   왜 층을 여러개를 쌓나요?   이론적으로는 2층 신경망으로도 임의의 연속함수를 근사할 수 있습니다.  그러나 층이 깊을수록 목적함수를 근사하는데 필요한 뉴런(노드)의 숫자가 훨씬 빨리 줄어들어 좀 더 효율적으로 학습이 가능합니다      딥러닝 학습원리: 역전파 알고리즘   신경망이 여러 층으로 쌓이게 되고, 각층에 있는 학습 패러메터 각각에 학습이 이루어 지기 위해 이 역전파 알고리즘을 사용할 수 있습니다.   역전파 알고리즘은 합성함수 미분법인 연쇄법칙(chain-rule)기반 자동미분(auto-differentiation)을 사용합니다.      경사 하강법에서 우리는 각 변수에서의 그레디언트 값을 계산하였습니다. 그레디언트 값(기울기=미분 값)은 이 변수값이 어디로 가야 우리의 목적함수를 최저값으로 만들 수 있는가를 알려주는 값이라고 할 수 있었습니다. 경사하강법에서는 변수 값에서 그레디언트 값을 빼줌으로서 우리의 목적함수를 최소화 할 수 있었습니다.   위의 그림에서도 마찬가지 입니다.  우리는 $z$ 값에 대해 $x$가 얼마만큼의 변화가 있는지 (미분 값 = 기울기)를 구하고 싶습니다.  하지만 위 함수는 합성합수 이기 때문에, 한번에는 안되고 한 단계를 더 거쳐야 구할 수 있습니다.   여기서 합성함수 미분법인 연쇄법칙을 사용하여 구할 수 있습니다.   $\\frac{\\partial z}{\\partial x}$ 구하기           먼저 겉미분을 합니다.  $w$를 $(x+y)$라 놓고, $z$를 $w$에 대해서 편미분을 하면 $ \\frac{\\partial z}{\\partial w} = 2w $가 됩니다.            다음은 속미분을 합니다.  $w$를 $(x+y)$라 놓았으니 $w$를 $x$대해서 편미분을 하면 $ \\frac{\\partial w}{\\partial x} = 1$이 됩니다.            그 다음 합성합수 연쇄법칙에 의해 $ \\frac{\\partial z}{\\partial w} \\frac{\\partial w}{\\partial x}$에서 ${\\partial w}$텀이 약분되게 되고 결론은 $ \\frac{\\partial z}{\\partial x}$가 도출되게 됩니다.            딥러닝에서도 위와 같은 아이디어가 똑같이 적용됩니다.   딥러닝은 역전파(backpropagation) 알고리즘을 이용하여 각 층에 사용된 패러미터 ${W(l), b(l)}1$에서$l1$ 까지를 학습합니다   각 층 패러미터의 그레디언트 벡터는 윗층부터 역순으로 계산하게 됩니다   위의 그림처럼 목적함수 $L$에 대한 $w(l)$의 그레디언트를 계산한다면 다음과 같이 계산해 볼 수 있습니다.   $\\frac{\\partial L}{\\partial w^{(l)}} = \\frac{\\partial L}{\\partial O} \\bullet \\bullet \\bullet \\frac{\\partial H^{(l)}}{\\partial Z^{(l)}} \\frac{\\partial Z^{(l)}}{\\partial W^{(l)}}$   피어세션 정리   두 번째 주차 셋째날 모임이었습니다.   오늘의 further question은 분류 문제에서 softmax 함수가 사용되는 이유가 뭘까요? 와 softmax 함수의 결과값을 분류 모델의 학습에 어떤식으로 사용할 수 있을까요? 이었고, 이에 대해 열심히 서로 토의를 해보았습니다.   그리고 오늘 공부하였던 내용 중에 약간 이해가 안되는 부분(소프트맥스를 구현하는 넘파이 코드에 있어서 왜 최대값을 전체 백터에 대해 빼주고, 이것이 어떻게 동작하는지? 와 역전파가 어떻게 계산이 되는지)이 있는 분이 계서서 질문을 듣고, 다 같이 여러 방향으로 자기가 생각해 본 것을 공유해보는 시간을 가졌었습니다.   그리고 내일 있을 10개 조씩 묶어서 3분씩 조를 소개하는 시간에 사용될 프레젠테이션을 만들기 위해 서로 협동하여 논의하는 시간을 가졌었습니다.   퀴즈 정리           $ReLU(x) = max(0,x)$ 일 때, $ReLU(-3.14)$ 의 값을 구하시오       $x$가 $0$보다 작다면 $0$을, $x$가$0$보다 크다면 $x$를 반환하게 되는 함수였습니다.            $\\partial tanh(x) = \\frac{\\partial tanh(x)}{\\partial x}$ 일 때, $\\partial tanh(0)$의 값을 구하시오.       $tanh(x)$를 미분하여 $x$에 $x$을 대입한 값을 구해주면 되는 문제였습니다.            다음 보기 중 역전파 (backpropagation) 알고리즘의 기반이 되는 것을 고르시오.       역전파 알고리즘의 핵심은 바로 합성함수의 연쇄법칙에 있습니다.            다음 보기 중 신경망에서 활성함수가 필요한 가장 적절한 이유를 고르시오.       선형모델의 출력을 비선형 적으로 근사하기 위하여 필요합니다.            $z$ 와 $k$ 가 다음과 같이 주어질 때, $\\frac{\\partial z}{\\partial x}$값으로 올바른 것을 고르시오.       $z = (k + 3)^{2}$ $k = (x + y)^{2}$       $\\frac{\\partial z}{\\partial x} = \\frac{\\partial z}{\\partial k} \\frac{\\partial k}{\\partial x}$ 가 됩니다.       $\\frac{\\partial z}{\\partial k}$은 $3(k+3)^{2}$  $\\frac{\\partial k}{\\partial x}$은 $2(x+y)$       즉, $6((x+y)^{2}+3)^{2}(x+y)$가 됩니다.       References      pandas - 최성철 교수님   Mathematics for Artificial Intelligence - Unist 임성철 교수님  ","categories": ["Development"],
        "tags": ["AI","Python"],
        "url": "http://localhost:4000/development/boostcamp-week2-day8/",
        "teaser":null},{
        "title": "Pandas / 기초 확률론",
        "excerpt":"판다스 / 딥러닝에서의 확률론 기본   판다스는 구조화된 데이터의 처리를 지원하는 Python 라이브러리입니다.  고성능 array 계산 라이브러리인 numpy와 통합하여, 강력한 “스프레드시트” 처리 기능을 제공하므로 Data science 분야에서 널리 쓰이는 판다스를 알아봅니다.   저번 포스팅에 이어, pandas 라이브러리 기능에 대해 알아봅니다.     딥러닝의 왜 확률론이 필요한지 알아봅니다.  데이터의 초상화로써 확률분포가 가지는 의미와 이에 따라 분류될 수 있는 이산확률변수, 연속확률변수의 차이점, 확률변수, 조건부확률, 기대값 등에 대해 알아봅니다.   pandas - groupby   특정 조건에 맞는 데이터들을 묶을 수 있는 기능입니다.      SQL groupby 명령어와 같음   split -&gt; apply -&gt; combine 과정을 거쳐 연산함      그룹바이 함수에는 묶음의 기준이 되는 컬럼이 들어가고 뒤에 적용하고자 하는 연산에 해당되는 컬럼을 입력합니다.   결과는 팀을 기준을 한 point들을 모두 합한 시리즈가 출력이 됩니다.     아래 그림 처럼 한 개 이상의 column을 묶을 수도 있습니다.      Hierarchical index      Groupby 명령의 결과물은 dataframe 입니다.   두 개의 column으로 groupby를 할 경우, index가 두개 생성됩니다.   아래의 그림에서는 ‘Team’과 ‘Year’의 인덱스가 생성된 모습입니다.      Hierarchical index – unstack()   Group으로 묶여진 데이터를 matrix 형태로 전환해주는 기능입니다.      Hierarchical index – operations   Index level을 기준으로 주어진 기본 연산이 수행 됩니다.   밑의 그림에서 level 0은 Team이고, level2는 Year 입니다.      Groupby – gropued   Groupby에 의해 Split된 상태를 추출 가능합니다.   Tuple 형태로 그룹의 key 값 Value값이 추출됩니다.        특정 key값을 가진 그룹의 정보만 추출도 가능합니다.      Groupby – aggregation   추출된 group 정보에 Aggregation이라는 요약된 통계정보를 추출해 줄 수 있는 기능을 적용할 수 있습니다.        특정 컬럼에 여러개의 function을 Apply 할 수 도 있습니다.      Groupby – transformation   Transformation은 Aggregation과 달리 key값 별로 요약된 정보가 아니고 개별 데이터의 변환을 지원합니다.      전체 그룹에서 칼럼 별로 가장 큰 값을 뽑아서, 그 값으로 전체 각각의 그룹의 칼럼 별 데이터를 갱신합니다.   Merge &amp; Concat   Merge는 SQL에서 많이 사용하는 Merge와 같은 기능으로써, 두개의 데이터를 하나로 합치는 기능입니다.   같은 칼럼 네임을 갖고 있는 데이터 프레임이 두개가 있고, ‘subject_id’의 같은 칼럼 값으로 merge를 하면 다음 그림과 같이 됩니다.      합병의 기준이 되는 컬럼의 이름이 다를 땐 ‘left_on’, ‘right_on’ 옵션을 각각 지정해주면 됩니다.        SQL을 하신 분이라면 익숙한 그림입니다.  Merge는 어느 방법을 쓰느냐에 따라, 다음과 같이 도식화 될 수 있습니다.      Merge example   다음은 예제에 사용될 데이터 프레임들 입니다.      left join   subject_id가 기준이 되면서, 왼쪽에 있는 모든 데이터도 머지 대상이 됩니다.  오른쪽 데이터에서 왼쪽 데이터의 칼럼에 해당되지 않는 부분은 NaN값으로 채워집니다.      right join   subject_id가 기준이 되면서, 오른쪽에 있는 모든 데이터도 머지 대상이 됩니다.  왼쪽 데이터에서 오른쪽 데이터의 칼럼에 해당되지 않는 부분은 NaN값으로 채워집니다.      full(outer) join   subject_id가 기준이 되면서, 양쪽에 있는 모든 데이터가 머지 대상이 됩니다.  왼쪽 데이터에서 오른쪽 데이터의 칼럼에 해당되지 않는 부분 그리고 오른쪽 데이터에서 왼쪽 데이터의 칼럼에 해당되지 않는 부분은 NaN 값으로 채워집니다.      Concat   말그대로, 같은 형태의 데이터를 붙이는 연산작업 입니다.      pd.concat([df1, df2])과 `df1.append(df2) 방식이 있습니다.      딥러닝 확률론   딥러닝에서 확률론이 왜 필요한가요?   딥러닝은 확률론 기반의 기계학습 이론에 바탕을 두고 있습니다. 기계학습에서 사용되는 손실함수(loss function)들의 작동 원리는 데이터 공간을 통계적으로 해석해서 유도하게 됩니다. (예측이 틀릴 위험(risk)을 최소화하도록 데이터를 학습하는 원리는 통계적 기계학습의 기본 원리)   회귀 분석에서 손실함수로 사용되는 L2-노름은 예측오차의 분산을 가장 최소화하는 방향으로 학습하도록 유도합니다.   분류 문제에서 사용되는 교차엔트로피(cross-entropy)는 모델 예측의 불확실성을 최소화하는 방향으로 학습하도록 유도합니다.   분산 및 불확실성을 최소화하기 위해서는 측정하는 방법을 알아야하는데, 두 대상을 측정하는 방법을 통계학에서 제공하기 때문에 기계학습을 이해하려면 확률론의 기본 개념을 알아야 합니다.   이산확률변수 vs 연속확률변수   확률변수는 확률분포 𝒟 에 따라 이산형(discrete)과 연속형(continuous) 확률변수로 구분하게 됩니다.   이산형 확률변수는 확률변수가 가질 수 있는 경우의 수를 모두 고려하여 확률을 더해서 모델링합니다.   $P(X \\in A) = \\Sigma_{x \\in A} P(X = x)$   연속형 확률변수는 데이터 공간에 정의된 확률변수의 밀도(density) 위에서의 적분을 통해 모델링합니다.   $P(X \\in A) = \\int_A P(x)dx$   조건부확률과 기계학습   조건부확률 $P(y \\mid x)$는 입력변수 $x$ 에 대해 정답이 $y$ 일 확률을 의미합니다.   로지스틱 회귀에서 사용했던 선형모델과 소프트맥스 함수의 결합은 데이터에서 추출된 패턴을 기반으로 확률을 해석하는데 사용됩니다.   분류 문제에서 softmax$(W\\phi + b)$은 데이터 $x$ 로부터 추출된 특징패턴 $\\phi(x)$ 과 가중치행렬 $W$을 통해 조건부확률 $P(y \\mid x)$을 계산합니다.   회귀 문제의 경우 조건부기대값 $𝔼[y \\mid x]$ 을 추정합니다.   딥러닝은 다층신경망을 사용하여 데이터로부터 특징패턴 $\\phi$을 추출합니다   기대값이 뭔가요?   확률분포가 주어지면 데이터를 분석하는 데 사용 가능한 여러 종류의 통계 적 범함수(statistical functional)를 계산할 수 있습니다.   기대값(expectation)은 데이터를 대표하는 통계량이면서 동시에 확률분포를 통해 다른 통계적Z 범함수를 계산하는데 사용됩니다.   $E_{x~P(x)}[f(x)] = \\int_X f(x)P(x)dx$, $E_{x~P(X)}[f(x)] = \\sum_{x \\in X} f(x)P(x)$   피어세션 정리   오늘은 판다스의 그룹핑에 대한 내용과 딥러닝에서 왜 통계학이 중요하고 사용되는지에 대해 배울 수 있었는데, 오늘 내용 중 통계학 부분의 설명이 좀 난해하고 낯설다는 분이 많이 계서서, 다 같이 어느부분이 이해가 안되고 궁금한지 이야기하는 시간을 가질 수 있었습니다.   그리고 2주차 들어오면서 수학적인 내용을 다룸에 따라 하루의 마무리인 학습정리를 할 때, 블로그나 다른 매체에 수식을 입력할 수 있는 LaTex라는 문법에 대해 이야기 하였고, 이를 어떻게 하면 효율적으로 배우고 쓸 수 있을지에 대해 이야기해볼 수 있었습니다.   퀴즈 정리           이산형 확률변수는 확률변수가 가질 수 있는 경우의 수를 모두 고려하여 확률을 더해서 모델링한다?       확률변수가 가질 수 있는 경우의 수를 모두 고려하여 확률을 더해서 모델링하게 됩니다.            연속형 확률변수의 한 지점에서의 밀도(density)는 그 자체로 확률값을 가진다?       밀도는 누적확률분포에서의 확률이 아니라 변화율을 의미하게 됩니다.            몬테카를로 샘플링 방법은 변수 유형 (이산형, 연속형)에 상관없이 사용할 수 있다?       상관없이 사용할 수 있습니다.            각 면이 나올 확률이 균등하고 독립적인 정육면체 주사위를 던진다고 하자. 확률변수 $X$ 는 주사위의 각 면의 숫자를 나타낸다고 할 때 $(X \\in {1, 2, 3, 4, 5, 6})$, $X$ 의 기대값을 구하시오 (소수점 첫째자리까지 입력).       각 확률변수에 확률함수 값을 곱하여 모두 더하면 되는 문제였습니다.            각 면이 나올 확률이 균등하고 독립적인 정사면체 주사위를 던진다고 하자. 확률변수 $X$ 는 주사위의 각 면의 숫자를 나타낸다고 할 때 $(X \\in {1, 3, 5, 7})$, $X$ 의 분산을 구하시오 (정수값으로 입력).       각 확률변수에서 기댓값을 뺀 값들을 각각 제곱하고, 모두 각각의 확률변수와 곱하여 더하면 되는 문제였습니다.       또는, 확률변수를 제곱한 값들의 기댓값을에서 기댓값 자체를 제곱한 값을 빼줘도 분산을 구할 수 있습니다.       References      pandas - 최성철 교수님   Mathematics for Artificial Intelligence - Unist 임성철 교수님  ","categories": ["Development"],
        "tags": ["AI","Python"],
        "url": "http://localhost:4000/development/boostcamp-week2-day9/",
        "teaser":null},{
        "title": " matplotlib",
        "excerpt":"matplotlib   데이터 분석을 위해서 가장 기초적인 단계로 해당 데이터를 시각화하여 보여줄 수 있는 능력이 필요합니다. 시각화 라이브러리는 파이썬에서만 10개가 넘는등 다양한 라이브러리가 존재합니다. 그 중에서 가장 대중적으로 많이 쓰이는 matplotlib, seaborn 모듈에 대해 알아보겠습니다.   matplotlib   가장 대중적으로 많이 쓰였고 많은 파이썬 라이브러리의 근간이 되는 matplotlib 입니다. matplotlib는 다른 라이브러리들의 부모 라이브러리로서의 역할을 하고 있다고 표현할정도로 다른 라이브러리들에 많은 영향을 주었습니다. 다소 복잡한 라이브러리 구성으로 인해 최근에는 그 사용 빈도와 대중성이 떨어지고 있으나 여전히 많은 입문자들이 처음 사용해보게 되는 좋은 시각화 라이브러리입니다.   matplotlib overview   그래프는 pyplot 객체를 사용하여 데이터를 표시합니다.  그 다음 pyplot 객체에 그래프들을 쌓은 다음 flush하게 됩니다.      plot 메소드는 argument를 kwargs인 키워드로 받기 때문에 고정된 argument가 없어서 alt+tab으로 사전에 어떤 parameter로 구성되어 받는지 확인이 어렵습니다.      그래프는 원래 figure 객체에 생성되는데, pyplot 객체 사용시, 기본 figure에 그래프가 그려집니다.      Figure &amp; Axes   Matplotlib은 Figure 안에 Axes로 구성이 됩니다.  Figure 위에 여러 개의 Axes를 생성         Subplot의 순서는 그리드로 작성됩니다.      set color   color 속성을 사용 float: 흑백, rgb color, predefined color 사용 가능      set line style   라인 스타일은 ls 또는 linestyles 속성을 사용함으로써 적용가능 합니다.      set title   pyplot에 title 함수 사용, figure의 subplot별 입력 가능      set legend   legend 함수로 범례를 표시함, loc 위치 등 속성 지정가능      scatter   scatter 함수를 사용해 그래프를 그릴 수 있습니다.   scatter 함수는 argument로 data_1, data_2같은 시퀀스 자료형을 받고 있습니다.  c는 컬러, marker는 모양을 지정하는 속성입니다.         s : 데이터의 크기를 지정, 데이터의 크기 비교 가능      bar chart   bar 함수로 bar chart를 그릴 수 있습니다.      histogram      seaborn   시각화를 위한 다양한 기능을 손쉽게 사용할 수 있도록 지원합니다. 모든 기능은 matplotlib을 기반으로 제공되어 matplotlib과 상호 호환됩니다. matplotlib의 모든 기능을 사용하면서 손쉽게 사용하고 싶다면 seaborn이 가장 적절한 대안입니다.      기존 matplotlib에 기본 설정을 추가   복잡한그래프를 간단하게 만들 수 있는 wrapper   간단한 코드 + 예쁜 결과         matplotlib과 같은 기본적인 plot   손쉬운 설정으로 데이터 산출   lineplot, scatterplot, countplot 등            퀴즈 정리           다음과 같은 표본 $X$ 가 있을 때, $X$ 의 평균을 구하시오 (정수값으로 입력).       표본을 모두 더한 다음 갯수로 나눠주면 되는 문제였습니다.            다음과 같은 표본 $X$ 가 있을 때, $X$ 의 표본분산을 구하시오 (소수점 첫째자리까지 입력)       표본들을 표본평균으로 뺀 값들을 제곱한 다음 전부 더해 [표본 개수 - 1] 로 나눠주면 되는 문제였습니다.            다음과 같은 표본 $X$ 가 있을 때, $X$x 의 표본표준편차를 구하시오 (정수로 입력).       위의 표본에서 표본분산을 구해서 제곱근을 취해주면 되는 문제였습니다.            정답 레이블을 one-hot 벡터로 표현한다면 하나의 정답 레이블 벡터의 크기는 1이다?       범주의 개수가 하나의 정답 레이블 벡터의 크기가 됩니다.            KL(P∥Q)는 KL(Q∥P) 와 같다?       쿨백-라이블러 발산의 이산확률변수에서의 경우와 연속확률변수에서의 경우는 다릅니다.       References      pandas - 최성철 교수님   Mathematics for Artificial Intelligence - Unist 임성철 교수님  ","categories": ["Development"],
        "tags": ["AI","Python"],
        "url": "http://localhost:4000/development/boostcamp-week2-day10/",
        "teaser":null},{
        "title": "베이즈 정리 / 딥러닝 입문 / MLP",
        "excerpt":"베이즈 정리 / 딥러닝 입문/ MLP   베이즈 정리는 데이터가 새로 추가되었을 때 정보를 업데이트하는 방식에 대한 기반이 되므로 오늘날 머신러닝에 사용되는 예측모형의 방법론으로 굉장히 많이 사용되는 개념입니다.   베이즈 정리   베이즈 통계학을 이해하기 위해선 조건부확률의 개념을 이해해야 합니다.   조건부확률 P(A∣B)는 사건B가 일어난 상황에서의 사건A가 발생활 확률을 말합니다.      베이즈 정리는 조건부확률을 이용하여 정보를 갱신하는 방법을 알려줍니다.      베이즈 정리: 예제   COVID-99 의 발병률이 10% 로 알려져있다. COVID-99 에 실제로 걸렸을 때 검진될 확률은 99%, 실제로 걸리지 않았을 때 오검진될 확률이 1% 라고 할 때, 어떤 사람이 질병에 걸렸다고 검진결과가 나왔을 때 정말로 COVID- 99 에 감염되었을 확률은?   아래의 베이즈 정리 식을 이용하면 쉽게 구할 수 있습니다.      우리가 구하고자 하는 값은 어떤 사람이 질병에 걸렸다고 검진결과가 나왔을 때 정말로 COVID- 99에 감염되었을 확률이고 이는 바로 사후확률이 됩니다.   이 사후확률은 사전확률인 발병률이 10% * 가능도인 COVID-99 에 실제로 걸렸을 때 검진될 확률은 99% / Evidence 로 구할 수 있습니다.   Evidence는 다음과 같이 구할 수 있습니다.  질병에 결렸을 때, 검진될 확률 * 발병률 + 질병에 걸리지 않았을 때 검진될 확률(오진) * 발병률의 부정      따라서 위 값을들 조합해 계산해보면 아래와 같습니다.      만약 오진률 즉, 발병되지 않았는데 검진될 확률이 0.1 = 10%로 올라간다면, Evidence에서의 값이 증가하게 되고 이는 사후 확률을 낮추게 됩니다.      오진률이 높아짐으로 인해, 질병에 걸렸다고 검진결과가 나왔을 때, 실제로 그사람이 감염되었을 확률이 낮아진다는 것입니다.   베이즈 정리를 통한 정보의 갱신   베이즈 정리를 통해 새로운 데이터가 들어왔을 때 앞서 계산한 사후확률을 사전확률로 사용하여 갱신된 사후확률을 계산할 수 있습니다.      앞서 COVID-99 판정을 받은 사람이 두 번째 검진을 받았을 때도 양성이 나 왔을 때 진짜 COVID-99 에 걸렸을 확률은?   갱신된 evidence는 다음과 같이 계산 됩니다.   빨간색 텀이 바로 전 단계에서 계산한 사후확률이고 이것이 이번 단계에서의 사전 확률로 들어가게 되는 것입니다.      그리고 갱신된 사후확률은 다음과 같이 계산될 수 있습니다.   사전확률이 전 단계에서 계산된 값으로 들어가고 위에서 계산한 evidence값이 분모로 들어가게 됩니다.  나머지는 원래 계산하던 것과 마찬가지 입니다.      Deep Learning Basic   딥러닝에 대한 소개, 그리고 딥러닝의 역사에 대해 배웁니다.   CNN(Convolutional neural networks), RNN(Recurrent Neural Networks)와 같은 딥러닝 모델을 공부하기 전에 중요한 요소인 Data, Model, Loss, Optimization algorithms에 대해 배웁니다.   What make you a good deep learner ?      가지고 있는 아이디어나 논문의 이론을 실제로 구현할 수 있는 능력   딥러닝을 공부하고 연구하는데에 필요한 선형대수와 통계학 등..   현재 어떤 트렌드가 있고, 어떤 연구결과가 나왔는지 아는 것이 매우 중요하다      Contents   앞으로 배우게 될 내용      Historical Review - 딥러닝의 역사적 리뷰   Neural Networks &amp; Multi-Layer Perceptron - 신경망과 다층 퍼셉트론   Optimization Methods - 최적화 방법 (드롭아웃, 규제 등)   Convolutional Neural Networks - 합성곱 신경망   Modern CNN   Computer Vision Applications - 컴퓨터 비전 응용   Recurrent Neural Networks   Transformer   Generative Models Part1 10.Generative Models Part2   AI / ML / DL      AI - 사람의 지능을 모방하는 것   ML - 어떤 문제를 품에 있어, 데이터를 통해 학습하는 분야   DL - 사랑의 지능을 모방하면서, 데이터를 통해 학습하고, 그 안에 딥 뉴럴 네트워크를 사용하는 위 두개의 분야 안의 세부적인 분야      DL분야를 연구하는 것은 AI분야 전체를 연구한다는 것과는 동치가 아니다.   Key Components of Deep Learning      The data that the model can learn from   The model how to transform the data   The loss function that quantifies the badness of the model   The algorithm to adjust the parameters to minimize the loss   Data      Data depend on the type of the problem to solve.  데이터는 풀고자 하는 문제에 종속적이다.      분류문제에서는 개와 고양이 같은 어떤 종류의 물체인지 분류하고, Semantic Segmentation같은 문제에서는 각 픽셀이 어디에 속하는 부분인지, Detection은 이미지에서 여러 종류의 물체가 있으면 이 물체의 바운더리에 어느 종류의 물체가 있는지 구분합니다.   Model   이미지, 텍스트 등이 주어졌을 때, 우리가 알고 싶어하는 문제의 예측값(레이블)을 도출해주는 역할을 한다.   문제에 따라 여러가지 모델이 존재하고, 성능도 각기 다르다.      Loss      The loss function is a proxy of what we want to achieve.  문제에서 풀고 이루고자 하는 목적을 달성하기 위한 근사치   문제에 따라 적용되는 손실함수의 종류가 달라지게 된다.   전형적인 선형회귀 같은 문제에서는 예측값과 정답레이블 사이의 거리를 최소화 하기 위해 MSE(최소제곱오차)라든지, 분류문제에서는 여러개의 선택지 중 어느 것이 확률이 제일 높은지 예측하기 위해 CE(교차 엔트로피)같은 손실함수를 적용한다.      Optimization Algorithm      퀴즈 정리           다음의 식이 성립하는가?       P(A∩B)=P(A)P(B∣A)       기본적인 조건부 확률 문제로서, P(B∣A)는 사건 A가 일어났을 때, B가 일어날 확률을 의미합니다.            사후확률 (posterior) 은 가능도 (likelihood) 에 반비례하는가?       가능도는 사후확률에 비례하고, Evidence가 반비례하게 됩니다.            다음의 식이 성립하는가?       P(A∣B) = P(A)P(B∣A)/P(B)       양변에 P(A)를 곱해주면 식은 성립하게 됩니다.            A가 binary variable일 때, 다음의 식이 성립하는가?       P(A∣B) = P(B∣A)P(A) / P(B∣A)P(A)+P(B∣¬A)P(¬A)       이항변수일 때의 베이즈 정리의 공식을 묻는 문제였습니다.            모든 변수에 대한 조건부 확률만으로 인과관계를 추론할 수 있는가?       인과관계를 추론함에 있어 어떤 중첩효과가 있는지 연구 후에 이를 제거해야 올바른 추론이 가능합니다.       References      Mathematics for Artificial Intelligence - Unist 임성철 교수님   Deep Learning Basic - 최성준 교수님  ","categories": ["Development"],
        "tags": ["AI","Python"],
        "url": "http://localhost:4000/development/boostcamp-week3-day11/",
        "teaser":null},{
        "title": "Optimization in Deep Learning",
        "excerpt":"Optimization in Deep Learning   최적화와 관련된 주요한 용어와 내용(Generalization, Overfitting, Cross-validation) 그리고 기존 SGD(Stochastic gradient descent)를 넘어서 최적화(학습)가 더 잘될 수 있도록 하는 다양한 기법들에 대해 알아봅니다.   Important Concepts in Optimization      Generalization   Under-fitting vs. over-fitting   Cross validation   Bias-variance   Bootstrapping   Bagging and boosting   Generalization   일반화는 학습 데이터로 학습이 되어진 모델이 얼마나 테스트 데이터에서 잘 동작하는지(문제에 따라 에러를 최소화)를 나타내는 개념입니다.      위의 그림처럼 학습 데이터를 반복적으로 학습함에 따라 모델은 Training Error는 줄어들게 됩니다.  그렇다고 Training Error가 최소값이 되었다고 해서 우리의 모델이 최적화 되었다고 할 수는 없습니다.   일반적으로 Training Error가 줄어들지만, 어느정도 반복 학습이 이루어지고 시간이 지나면 학습하지 않은(한번도 보지 않은) 테스트 데이터에 대해서는 Test Error가 올라가게 됩니다.   Generalization Gap은 Training Error와 Test Error 사이의 차이를 의미합니다.   그래서 Training Error와 Test Error의 차이 즉, Generalization Gap이 작을 때 우리는 Generalization Performance가 좋다고 말할 수 있고, Generalization Gap이 클 때 Generalization Performance가 좋지 않다고 말 할 수 있습니다.   주의할 점은 Test Error가 낮다고 해서 Generalization Performance 좋은 것이 아닙니다.  Generalization Performance는 단지 두 Error의 차이에 따른 성능만을 의미하는 것이기 때문입니다.   Underfitting vs. Overfitting   Overfitting은 학습데이터에 대해서는 잘 동작 하지만 테스트 데이터에 대해서는 잘 동작하지 않는 현상을 의미합니다. 이는 모델이 학습 데이터에 대해 너무 과적합하게 학습된 나머지, 한 번도 보지 못한 테스트 데이터에 대해서는 잘 동작하지 않는 것을 의미하게 됩니다.   Underfitting은 네트워크가 너무 간단하거나 학습을 너무 조금 시켜서 학습 데이터 마저도 잘 맞추지 못하는 현상을 의미하게 됩니다.   밑의 그림에서 볼 수 있듯이 학습데이터에 대해 너무 과적합하지 않으면서도 간단하거나 부족하지 않은 중간의 모델이 Balance하다고 할 수 있습니다.   하지만 문제에 따라서는 오른쪽 그림과 같이 파란 선들이 Target일 수도 있어서 이 개념들은 컨셉적인 이야기라고 보면 될 것 같습니다.      Cross-validation   전체 데이터를 크게 학습 데이터와 테스트 데이터로 나누는데, 학습 데이터에서 일정 부분을 검증을 위해 때어내서 만든 데이터를 Validation Data 라고 합니다.   Validation Data를 만들어 사용하는 이유는 학습 데이터로 학습을 시킨 모델이 학습에 사용되지 않은 Validation Data 기준으로 얼마나 잘 동작하는지 알아보기 위함입니다.      K-fold Validation이라고도 불리는 Cross validation은 학습 데이터를 k개의 fold로 나누고, 1개의 fold는 검증에 사용할 validation data로, 나머지 k-1개의 fold는 학습 데이터로 사용하는 것입니다.  이를 fold 마다 한번 씩 번갈아 가며 k번 수행하면 총 5개의 서로 다른 validation 값이 나오게 되고, 이 값들을 평균낸 값을 사용하게 됩니다.   모델을 학습 시키는데에 있어서 중요한 하이퍼 패러미터(Learning Late, 손실함수, 네트워크의 크기 등)를 정하기 위해 먼저 교차 검증을 수행하고 하이퍼 패러미터가 교정이 되면, 검증 데이터를 학습 데이터에 포함시켜 전체 학습 데이터에 대해 모델을 학습합니다. 이 때, 테스트 데이터를 사용해서 교차검증을 한다거나 하이퍼 패러매터를 설정하는 것 등… 무슨 이유에서건 테스트 데이터를 학습에 사용되서는 안됩니다.   Bias and Variance      Low Variance는 비슷한 입력을 넣었을 때, 얼마나 일관된 출력을 내는지를 의미합니다. 이는 주로 모델이 간단할 때 나타나는 현상입니다.   High Variance는 비슷한 입력을 넣었을 때, 출력이 많이 달라지게 되는 것을 의미합니다. 이렇게 되면 모델이 Overfitting 될 가능성이 커지게 됩니다.   Low Bias는 전체적인 출력 값이 Target 또는 Mean과 가깝다는 것을 의미합니다.        High Bias는 전체적인 출력 값이 Target 또는 Mean과 다소 떨어져 있다는 것을 의미합니다.              Bootstrapping   고정된 수의 학습데이터에 대해 랜덤하게 샘플링 된 데이터로 여러 모델을 만들어 어떤 목적을 수행하겠다는 방법론을 말합니다.   예를 들어 전체 데이터의 수가 100개이면 그 중 랜덤하게 80개를 뽑아 모델 1을 학습시키고, 다시 랜덤하게 80개를 뽑아 모델 2를 학습시키고… 이렇게 수행하게 됩니다.   이렇게 되면 하나의 입력에 대해서 여러개의 모델이 같은 값을 예측할 수도 있지만 서로 다른 값을 예측할 수도 있습니다.      그래서 입력 값들에 대해 이 모델들의 출력 값이 얼마나 일치하는 지를 보고 전체적인 모델의 Uncertainty를 예측하고자 할 때 사용할 수 있습니다.   Bagging vs Boosting      Bagging : 위에서 다룬 Bootstrapping 방법을 쓰는 데, 전체 데이터에서 일부를 랜덤 샘플링 해서 여러 개의 모델을 만들고, 그 모델들의 아웃풋을 가지고 평균을 내는 것을 의미하게 됩니다. 이런 것을 일반적으로 앙상블이라고도 부릅니다.   Boosting : 전체적인 프로세스가 Sequential 하게 전체 학습 데이터에 대해 모델을 만들고 그 중 학습이 잘 안된 데이터에 대해 또 다른 모델을 만들어 이 학습이 잘 안된 데이터에 대해 학습이 잘 되도록 모델을 만드는 것을 반복합니다. 그리고 이렇게 만든 모델들을 Sequential하게 합쳐 하나의 모델을 만듭니다.      Gradient Descent Methods   Gradient Descent 분류해보면 크게 3가지로 분류해 볼 수 있습니다.      Stochastic gradient descent : 엄밀하게 얘기해서 전체 학습 데이터에서 한번에 한개의 샘플 데이터에 대해서 역전파를 통해 그레디언트를 구하고, 값을 업데이트하고, 다시 한번에 한개의 샘플 데이터에 대해 반복하는 것을 말합니다.   Mini-batch gradient descent : 배치 사이즈인 256개나 128개 등의 학습 데이터의 서브셋에 대해 계산된 그레디언트를 업데이트 하는 방법을 말합니다.   Batch gradient descent : 전체 데이터에 대해 계산된 그레디언트를 사용해 패러매터를 업데이트 하게 되는 것을 말합니다.   대부분의 딥러닝 문제에서는 Mini-batch gradient descent가 사용되어지고 있습니다.   Batch-size Matters   많은 딥러닝 문제에서 Batch-size는 아주 중요한 요소입니다.  Batch-size에 따라 우리가 추구하고자 하는 모델이 이상적으로 가는지, 잘 학습이 되어지는에 대해 결정적일 수 있기 때문입니다.      실험적으로 발견이 되어진 내용에 의하면 큰 Batch-size를 사용하여 모델을 학습하게 되면, 학습과 테스트 함수가 sharp minimizers에 도달할 가능성이 크다고 합니다. 반면에 작은 Batch-size를 사용하게 되면 flat minimizers에 도달할 가능성이 크다고 합니다.   여기서 말하고자 하는 내용은 Batch-size를 작게쓰는 것이 일반적으로 성능이 좋다라는 것을 실험적으로 말하는 것입니다.      우리의 목적은 데이터가 Testing function에서 잘 동작하는 것을 찾고 싶습니다.   Flat minimum에서 Training Function 값이 조금 멀어져도, Testing Function에서도 적당히 비슷한 값이 나오는 것을 볼 수 있습니다. 이 말은 학습 데이터에서 잘 동작하는 것이 테스트 데이터에서도 잘 동작하는 즉, 앞에서 살펴본 Generalization performance가 높다고 할 수 있습니다.   Sharp minimum 에서는 Training Function에서 Local minimum에 도달했어도 Testing Function에서는 약간만 멀어져 있어도 높은 값이 나오는 것을 볼 수 있습니다. 이 말은 학습 데이터에서 잘 동작하는 것이 테스트 데이터에서는 잘 동작하지 않는 또는 예측하지 않는 즉, Generalization performance가 낮다고 할 수 있습니다.   Gradient Descent Methods      Stochastic gradient descent   Momentum   Nesterov accelerated gradient   Adagrad   Adadelta   RMSprop   Adam   Gradient Descent   가장 일반적인 Gradient Descent 방법입니다.      W는 업데이트 될 패러미터 백터, t는 타임스탬프, g는 자동미분으로 얻어진 그레디언트를 의미합니다.   그레디언트 값을 에타라고도 부르는 Learning rate 값과 곱해서 W와 빼주고 그 값을 새로 업데이트 하게 되는 방법입니다.   이 방법의 가장 큰 문제는 스텝 사이즈인 Learning rate를 정하는 것이 너무 어렵다는 점입니다.  Learning rate가 너무 크게 되면 학습이 잘 안되게 되고, 이 것이 너무 작으면 아무리 학습을 시켜도 학습이 안되게 될 것입니다.   그래서 이 Learning rate를 적절히 잡아주는게 중요합니다.   Momentum   관성이라고도 하는 이 방법은 쉽게 말해 한 번 그레디언트 방향이 a방향으로 흘렀다면, 다음번에 업데이트에서 계산된 그레이언트가 조금 다른 방향으로 흘러도 전에 흐르던 방향인 a방향의 정보를 조금 추가해서 그 방향을 보정하거나 이어가자는 것을 의미합니다.      베타상수가 모멘텀이 되고 a_t+1이 accumulation이 됩니다.  즉 한 번 계산되고 나서 g_t가 버려지게 되는 것이 아니고, 이 값이 베타 상수인 모멘텀과 같이 계산되어 accumuaation에 들어가게 되고 현재 뿐만 아니라, 다음 번의 경사하강 업데이트 계산에 a_t로서 계산이 들어가게 됩니다.   미니 배치 연산에서 에를 들면 전의 배치에서는 경사가 이쪽 방향으로 흘렀지만 다음 번 배치에서는 다른 방향으로 흐를 수 있고 이 때, 전에 계산된 방향으로 조금 보정해서 또는 관성을 줘서 흘러가자라는 것을 볼 수 있습니다.   그래서 그레디언트가 아주 많이 다 방향으로 왔다갔다 해도 어느정도 잘 학습이 되게 만들어 주는 효과가 있다고 합니다.   Nesterov Accelerated Gradient   NAG라고 불리는 이 경사하강 방법도 위에서 살펴본 Momentum과 비슷한 모양을 띄고 있습니다.  컨셉적으로 a라는 Accumulate gradient가 Learning rate와 곱해져서 Gradient Descent를 하게 되는 것인데, 위에 것과 조금 다른 점이라면 위에서 살펴본 g_t gradient를 계산 할 때 Lookahead gradient를 계산하게 됩니다.      Lookahead gradient는 a라고 불리는 현재 gradient 정보가 있으면, 그 방향으로 한 번 가보고, 간 곳에서 다시 gradient를 계산에 accumulate 시켜주게 됩니다.      Nesterov Accelerated Gradient 방법은 Momentum에 비해 local minima에 조금 더 빨리 converge 할 수 있다고 할 수 있습니다.   Adagrad   이 방법은 뉴럴 네트워크가 학습하면서 시간적으로 얼마나 패러미터가 변해왔는지 안 변해 왔는지를 보게 되고, 값이 많이 변한 패러미터들에 대해서는 다음번에 더 적게 변화 시키고, 반대로 값이 적게 변한 패러미터들에 대해서는 다음번에 더 크게 변화 시키게 됩니다.      G_t는 학습하면서 지금까지 얼머나 gradient가 변했는지를 제곱해서 더한 값입니다.   이 값이 커진다는 것은 그 해당하는 패러미터들이 많이 변했다는 것을 의미하고, 이 값을 역수를 취해 넣었기 때문에, 다음번의 경사 하강에서는 그 해당하는 패러미터들이 보다 적은 배율로 업데이트가 이루어 집니다.   위의 룰을 적용해, G_t값이 작을 때는 다음번에 좀 더 많이 패러미터들을 변화시키겠다는 말이 됩니다.   입실론 상수는 learning rate가 0으로 나눠지는 것을 방지하기 위한 (forNumerical stability) 값이 됩니다.   Adagrad에서 식에서도 유추해볼 수 있는 가장 큰 문제라면, G_t값이 무한대로 계속 커지게 된다면 분모가 무한대이므로 W_t의 왼쪽에서 계산된 텀인 gradient 값은 무한대로 작아지고 결국, W의 업데이트가 이루어지지 않을 것입니다. 그래서 학습이 진행되면서 뒤로 가면 갈 수록 학습이 멈춰지는 현상이 생긴다는 것입니다.   Adadelta   이 방법은 위에서 살펴본 Adagrad에서 G_t 값이 무한대로 커지는 현상을 방지하는 것을 추가한 방법이라고 보면 됩니다.   Adadelta는 이전의 모든 그래디언트를 누적하는 대신 그래디언트 업데이트의 이동 창을 기반으로 학습률을 조정하는 Adagrad 보다 강력한 확장론적 방법이라고 볼 수 있습니다.   이렇게 하면 Adadelta는 많은 업데이트가 수행 된 경우에도 계속해서 학습할 수 있습니다.      EMA : Exponential Moving Average   H_t는 내가 실제로 업데이트 하고하자는 패러미터의 값을 미분하여 제곱한 값이 되고 이를 H_t-1의 값과 감마 상수를 잘 조합한 값이 됩니다.   이를 위에서 본 G_t값에 대한 역수로 넣어주게 됨으로써 학습이 진행됨에 따라 뒤로가도 학습이 계속 진행되도록 할 수 있습니다.   RMSprop   Adadelta에서 살펴본 H_t값과 입실론의 루트 값 대신에 Learning rate텀이 대신 들어간 방법이 됩니다.   위에서 처럼 G_t를 그냥 쓰는것이 아닌, EMA의 값을 취해서 분모로 취해주게 됩니다.  분자에는 에타라는 Learning rate가 들어가게 됩니다.      Adam   일반적으로 Gradient descent 최적화 방법론 중 가장 잘 되고 무난하게 사용되는 것이 이 방법입니다.   Gradient squares를 Exponential Moving average로 가져감과 동시에 앞에서 보았던 모멘텀을 같이 활용하는 방법이 됩니다.      그레디언트의 크기가 바뀜에 따라 혹은 그레디언트 제곱의 크기에 따라서 적응적으로 Learning rate를 바꾸는 것과 이전에 계산된 모멘텀을 현재 그레디언트 값과 조합해 새로운 모멘텀을 조합하는 방법을 말하고 있습니다.   즉, Adam은 momentum과 adaptive Learning rate approach를 조합한 방법이 됩니다.   Hyperparameter는 베타1(모멘텀을 얼마나 유지시킬지), 베타2(Gradient square에 대한 EMA 정보), 에타(Learning rate), 입실론(for numerical stability)가 있습니다.   m_t옆에 root(1-b_2) / 1-beta_1 라는 것이 있는데, 이 전체 방법론이 Unbiased estimater가 되기 위해서 수학적으로 정의된 텀입니다.   딥러닝 프레임워크에서 입실론 패러미터가 기본적으로 약 10의 -7 제곱의 값으로 되어 있는데, 이 값을 잘 조정해주는 것이 Practical한 상황에서는 중요하다고 합니다.   References      Optimization in Deep Learning - 최성준 교수님  ","categories": ["Development"],
        "tags": ["AI","Python"],
        "url": "http://localhost:4000/development/boostcamp-week3-day12/",
        "teaser":null},{
        "title": "CNN - Convolution은 무엇인가?",
        "excerpt":"CNN(Convolutional Neural Network)   CNN(Convolutional Neural Network)에서 가장 중요한 연산은 Convolution 입니다.  Convolution의 정의, convolution 연산 방법과 기능에 대해 배웁니다.  그리고 Convolution, 입력을 축소하는 Pooling layer, 모든 노드를 연결하여 최종적인 결과를 만드는 Fully connected layer로 구성되는 기본적인 CNN(Convolutional Neural Network) 구조에 대해 배웁니다.     CNN consists of convolution layer, pooling layer, and fully connected layer.   가장 기본적이고 고전적인 CNN은 feature 값을 얻어내기 위해 합성곱 연산을 하는 convolution layer, Convolution을 거쳐서 나온 activation maps이 있을 때, 이를 이루는 convolution layer을 resizing하여 새로운 layer를 얻는 pooling layer 그리고 우리가 최종적으로 얻고자 하는 값들을 만들어주는 fully connected layer로 구성됩니다.   이미지를 예로 들면, Convolution and pooling layer는 이미지에서 어떤 유용한 정보를 뽑아내는 feature extraction을 담당하고 fully connected layer는 decision making; 예를 들어 분류를 하거나 회귀를 해서 우리가 원하는 출력 값을 얻도록 하게 합니다.   최근 들어서는 뒷단에 있는 fully connected layer가 최소화 되고, 점점 없어지는 추세라고 합니다.  이것은 패러매터의 수와 연관이 있는데요, 패러미터의 수가 늘어 나면 늘어날 수록 학습이 어렵고, Generalization performance가 떨어진다고 알려져 있습니다.   그래서 CNN의 응용 모델에서는 이런 패러매터의 수를 줄이면서 굉장히 Deep한 모델을 만들기 위해 여러 기법이 동원되고 적용되고 있습니다.      Convolution   Convolution 연산을 밑의 그림을 통해 봐보겠습니다.      밑에서 알아보게 될 stride와 padding는 고려하지 않고 가장 기본적인 Convolution 연산을 해보면 오른쪽의 Output 필터가 도출되게 됩니다.      오른쪽에서 빨간 네모인 값, 즉 하나의 Output 값은 Convolution 필터를 적용하고자 하는 이미지에 찍어 도출한다고 생각할 수 있습니다.   위의 그림에서 보는 것 처럼, 필터를 좌측 상단 이미지 상에 위치시키고, 각 그리드 위치에 맞는 값들 끼리 서로 곱셈을 한 후 전부 더하면 O_11의 output 값이 됩니다.   추가로 마지막에 바이어스 텀을 더해줄 수 있습니다.         전과 마찬가지로 O_12, O_13 값도 이미지 상에서 필터를 한 칸씩 옆으로 밀어 똑같이 계산하면 도출할 수 있습니다.   2D convolution in action   이미지 상에서 convolution operation을 한다는 것은 어떤 의미가 있을까요?   우리가 적용하고자 하는 필터에 따라 같은 이미지에 대해서 convolution output이 밑에서 보이는 것 처럼 여러가지 타입의 이미지로 변환이 되게 됩니다.   예를 들어서, 1/9 값을 가진 3x3 필터를 사용한다면, 이미지 상에서 필터가 적용될 때 3x3 픽셀의 이미지 값의 평균이 계산되고 이는 output 값에서 한 픽셀의 값이 됩니다. 그래서 이미지의 특정 영역에 대해 픽셀 값을 다 합쳐서 평균을 내므로 마치 밑에서 보이는 것 처럼 예를 들면 Blur화 된 이미지가 만들어지게 되는 것입니다.   마찬가지로 다른 타입의 필터를 적용하면 같은 이미지에 대해 강조되거나 외곽이 강조된 이미지를 얻을 수 있을 것입니다.      RGB Image Convolution   일반적으로 CNN에서는 RGB 이미지를 많이 다루게 됩니다.   대체로, 이미지는 가로와 세로 길이 그리고, RGB 값을 의미하는 3개의 채널로 구성이 됩니다.   RGB 이미지에 대해 Convolution을 하게 되면 이미지의 채널과 적용하고자 하는 필터의 채널 수를 맞춰서 계산하게 됩니다.   그래서 Output은 가로와 세로 모두 32-5+1인 크기가 되고 Depth즉 채널의 수는 1이 됩니다.      하나의 이미지에 대해 하나의 필터를 적용하게 되면 깊이 즉, 채널이 1인 feature 맵이 나오게 됩니다.   feature맵의 채널 수를 늘리고 싶다면, 하나의 이미지에 대해 여러개의 서로 다른 filter를 사용해서 연산을 하게 되면 feature맵의 채널 수가 filter개수 만큼 늘어나게 됩니다.        Convolution 연산을 여러 번 하게 되면 아래 그림처럼 도식화 될 수 있습니다.      stride는 1, padding은 0으로 고려하고 도식화 된 이미지 입니다.   32x32x3의 이미지에 대해 5x5x3의 필터가 적용되게 되는데, 필터의 개수가 4개 이므로 결과물을 28x28x4가 됩니다. (적용하는 필터의 개수 = 출력의 채널 수) 그리고 한 번 Convolution이 거치게 되면 생성된 feature맵의 각각의 Element들에 대해 Non-linear activation function을 적용하게 됩니다.   ReLU를 적용시키게 되면, 0보다 작은 Element 값들은 0 이되고, 0보다 큰 값들은 그대로 나오게 됩니다.   그리고 다시 이 feature맵에 대해 5x5x4의 필터 10개를 적용하게 되면 그림과 같이 나오게 됩니다.   나중에 보게 되겠지만 이 그림에서 첫번 째 Convolution에서 적용된 패러매터 들의 개수는 5x5x3x4가 됩니다.  4개의 필터가 필요하고, 각 필터의 사이즈는 5x5x3가 되기 때문입니다.   Stride   Stride라는 말은 쉽게 생각해 넓게 걷는다 라는 의미가 됩니다.   Convolution에서 Stride가 1이란 말은 이미지 상에서 매 픽셀마다 필터를 한 번에 한 픽셀 씩 옮겨 적용한다고 생각하면 이해가 쉽습니다.   위에서 보았던 Convolution 연산들은 이미지에 대해 필터가 한 번에 한 칸씩 이동하며 적용이 되었습니다. 그래서 Stride가 1이 됩니다.      왼쪽 그림에서 Input에 대해 크기가 3인 필터를 적용하고 Stride가 1이라면 Output은 5가 됩니다. 한 번에 한 칸씩 가므로.   Stride가 2인 경우에는 처음에 필터가 적용되고 나서 Stride의 수 만큼 옆으로 필터가 이동하게 됩니다. 따라서 Output은 3개가 나오게 됩니다.   위에서는 1차원을 예로 들었지만 2차원이 되면, Stride도 (1, 1), (2, 3) 이렇게 표현 될 수 있습니다.   Padding   위에서 보았듯이 이미지에 대해 필터를 3x3을 적용하고 나온 출력은 원래 이미지의 크기와 같지 않고 축소 되었습니다. 왜냐하면 boundary 정보가 버려지기 때문입니다. 필터가 이미지 밖으로 삐져나와서는 계산이 되지 않는 것을 말한 것입니다. 그래서 Padding은 가장자리에도 필터를 적용하고자 해서, 이미지의 가장자리에 0같은 값으로 채워주는 것을 말합니다.      5 크기의 Input이 있을 때 3 크기의 필터가 있으면 출력은 3이 됩니다.   출력을 원래 Input 크기만큼의 5로 만들어 주려면 가장 자리에 0을 덧댐으로서 즉 0 Padding을 함으로써 5로 만들어 줄 수 있게 됩니다.   Stride&amp;Padding   다음은 2차원 상에서 Stride 와 Padding을 다르게 하여 Convolution 연산을 도식화 한 것입니다.      Convolution Arithmetic   밑의 그림을 보고 Convolution 연산이 될 때의 parameter 수를 계산해 봅시다.      논문을 보거나 대부분의 자료에서 이렇게 도식화 된 그림을 많이 볼 수 있고, 도형 옆에는 각각 수들이 적혀 있습니다.   H: 세로 길이를 의미합니다.  W: 가로 길이를 의미합니다.  C: 채널 수, 깊이를 의미합니다. 보통 이미지라면 R, G, B의 3개의 값이고 투명도 까지 더해지면 4개의 값이 됩니다.   파란색 네모 박스는 왼쪽 큰 상자에 대해 적용할 필터가 됩니다.  3x3 크기의 필터를 적용하겠다는 것이고, 당연히 큰 상자의 채널 수와 필터의 채널 수는 일치해야 합니다.   그렇다면 필터의 패러미터 수는 3x3x128이 됩니다.   오른쪽의 출력의 채널 수는 64개가 되는데 이는, 오른쪽의 박스가 파란색 네모 필터를 64개 적용해서 얻어진 결과물이 됩니다. 왜냐하면 파란색 네모인 필터 하나 당 채널이 1인 feature map을 만들기 때문입니다.   그래서 총 패러미터의 수는 3x3x128x64가 됩니다.   References      CNN - Convolution - 최성준 교수님  ","categories": ["Development"],
        "tags": ["AI","Python"],
        "url": "http://localhost:4000/development/boostcamp-week3-day13/",
        "teaser":null},{
        "title": "Regularization",
        "excerpt":"Regularization   Regularization은 우리말로 규제라고 하며 쉽게 말해서 이전에 살펴본 최적화 방법에서 우리의 모델을 Generalization하게(학습 데이터에 대한 에러와 테스트 데이터에 대한 에러의 차이가 가능한 작게 되도록)하도록 하는 의미를 갖습니다.   엄밀히 말하면 우리의 모델이 데이터를 보고 학습을 하게 되는데, 학습에 방해가 되도록 규제를 하게 됩니다.  학습에 방해가 되도록 규제를 해서 우리가 얻는 이점은 학습 데이터에서만 우리의 모델이 잘 동작하는 것만 아니라 한번도 보지 못한 테스트 데이터에서도 잘 동작하도록 하는 것입니다.   여러가지 규제 방법들이 있고 아래와 같은 순서로 하나씩 살펴보겠습니다.      Early stopping   Parameter norm penalty   Data augmentation   Noise robustness   Label smoothing   Dropout   Batch normalization   Early stopping   일반적으로 학습이 반복되면서 학습 에러는 낮아지지만 그에 반해 학습 데이터 셋에서 분리한 검증 데이터로 검증을 하게 될 때, 검증 에러는 증가하게 됩니다.   밑의 그림은 말 그대로 학습이 반복됨에 따라 Generalization performance가 낮아지기 전에 또는 Generalization Gap이 커지기 전에 우리의 모델 학습을 멈추는 것을 의미합니다. 하지만 너무 빨리 멈춰 버리면 충분한 학습이 덜 되는 등 문제가 생기게 되므로 상황에 맞게 잘 적용해야 할 것입니다.   규제를 적용하고자 할 때 테스트 데이터를 써서 Early stopping을 하게 되면 Cheating에 해당되게 되므로 검증 데이터를 따로 사용하고 테스트 데이터는 사용하지 않습니다.      Parameter Norm Penalty   Parameter Norm Penalty는 뉴럴 네트워크 파라미터가 너무 커지지 않게 하는 것을 말합니다.  네트워크 파라미터 숫자를 다 제곱한 다음 더하면 어떤 값이 나오게 되는데 이 숫자를 같이 줄이는 것을 의미합니다.   이 것에 대해 물리적이거나 해석적인 의미는 뉴럴 네트워크가 만들어 내는 함수의 공간에 부드러움을 더하는 것입니다. 부드러운 함수일 수록 Generalization performance가 높을 것이다 라는 가정을 가지게 됩니다      밑에서 알아보게 될 stride와 padding는 고려하지 않고 가장 기본적인 Convolution 연산을 해보면 오른쪽의 Output 필터가 도출되게 됩니다.   Data Augmentation   뉴럴넷 혹은 딥러닝에서는 가장 중요한 하나를 꼽자면 역시 데이터 인데요, 데이터의 수가 작은 것 보다 데이터가 무한히 많으면 확실히 학습이 잘 이루어 지게 됩니다.   왼쪽의 그림 처럼 데이터의 수가 적을 때는 Random Forest, XGBoost 같은 방법론들이 데이터 대비 학습 성능이 더 잘 될 때가 많았습니다.   하지만 데이터 샘플의 개수가 어느정도 커지게 되면 딥러닝은 우리가 가지고 있는 방대한 데이터를 잘 표현을 하게 되고 이로 인해 성능이 올라가고, 기존에 머신러닝 방법론들은 이 많은 수의 데이터를 표현할 만한 표현력이 부족해지게 됩니다.   문제는 무엇이냐 하면, 현실에서의 데이터의 수는 한정적이고 해서 Data Augmentation를 통해서 데이터에 조작을 가해 기존에 있던 데이터와 비슷하지만 형태가 조금 다른 데이터를 추가하는 방식을 만들게 됩니다.      위에서 보이는 사진처럼 기존의 이미지에 대한 레이블 값이 바뀌게 하지 않는 선(유지)에서 이미지를 회전시키고, 확대 시키거나 축소 또는 뒤집기(플립), 자르기 등의 행위를 Data Augmentation 이라고 합니다.   하지만 MNIST 데이터에서 6과 같은 숫자는 상하로 뒤집게 되면 아예 이 데이터에 대한 레이블 값이 바뀌는 것이기에 이런 경우에는 뒤집기 같은 것을 사용할 수 없게 됩니다.   Noise Robustness   Noise Robustness는 노이즈를 추가한 데이터에 대해서도 잘 동작 하도록 모델을 강건하게 만든다는 것에 의미가 있습니다.   Data Augmentation과 차이점이라면 입력 데이터에 대해서만 노이즈를 추가하는 것이 아닌, 모델의 weight에 대해서도 노이즈를 추가해 줄 수 있습니다. 이렇게 되면 모델이 학습할 때 조금 더 성능이 더 잘 나온다는 실험적 결과가 있다고 합니다.      Label Smoothing   Label Smoothing도 Data Augmentation과 비슷한 의미를 갖는데, 차이점은 분류 문제라면 학습 데이터에서 랜덤하게 두 개의 이미지를 가져와 섞어주는 것입니다.   이것이 어떤 효과가 있냐 하면, 분류 문제에서의 이미지 공간 속에서 여러 개의 클래스들을 잘 구분할 수 있는 Decision Boundary를 찾고 싶을 것인데, 이 Decision Boundary를 부드럽게 만들어주는 효과를 가지고 있다고 합니다.    Mix up 같은 경우는 밑에서 보이는 것 처럼 이미지를 서로 50:50으로 섞습니다. 그리고 레이블 값도 각각 0.5씩 주게 됩니다.   Cut out은 이미지에서 일정 영역을 빼버리게 됩니다.   Cut mix는 이미지를 섞는데, 블렌딩하게 섞는 것이 아닌 일정 영역을 잘라 다른 이미지로 대체해버리는 방법을 말합니다. 그림에서 보이듯이 레이블 값은 0.6, 0.4씩 주어지게 됩니다.      Dropout   드롭아웃은 사진에서 보이는 것 처럼 뉴럴 넷에서의 특정 웨이트를 0으로 만듦으로써 뉴런을 비활성화 시키는 것을 말합니다. 드롭아웃 p = 0.5라는 말은 50%의 뉴런을 비활성화 시킨다라고 말할 수 있습니다.   이것을 해서 얻는 이점은 각각의 뉴런들이 좀 더 Robust한 feature를 잡을 수 있다라고 해석을 한다고 합니다. 그래서 모델의 Generalization performance가 올라간다고 실험적으로 잘 알려져 있습니다.      Batch Normalization   Batch Normalization는 이 기법을 적용하고자 하는 레이어의 값들을 통계적으로 정규화 시킨다라고 말할 수 있습니다.   예를 들어 1000개의 파라미터 값이 있는 히든 레이어가 있다고 하면, 1000개의 파라미터 각각의 값들에 대해 zero mean and unit variance하게 만들어 주는 것입니다.   unit variance은 데이터들에 대해 분산이 1이고 평균이 0인 값들의 분포로 만들어 주는 것을 말합니다.   신경망에서 해당층에는 파라미터의 여러 값들이 있는데, 그 수치의 크기가 달라서 큰 수의 값에 신경망이 지나치게 영향을 받는 것을 방지하기 위해서 이 기법을 적용한다고 생각해 볼 수 있습니다.   방법은 전체 데이터에 대해 평균과 분산을 구하고, 각각의 데이터에 대해서 평균을 뺀 값을 표준편차로 나눠주게 되면 Standarization이 되게 됩니다.   그렇다면, 전체 데이터에서 평균에 가까운 값이나 평균의 값을 가진 파라미터는 0또는 0 근처의 값이 되고, 다른 값들은 평균을 빼준 값에서 표준편차로 나누어준 거리 만큼 평균에서 떨어진 값으로 있게 됩니다.      References      Optimization - Convolution - 최성준 교수님  ","categories": ["Development"],
        "tags": ["AI","Python"],
        "url": "http://localhost:4000/development/boostcamp-week3-day14/",
        "teaser":null},{
        "title": "Sequential Models - RNN",
        "excerpt":"Sequential Models - RNN   주식, 언어와 같은 Sequential data와 이를 이용한 Sequential model의 정의와 종류에 대해 배웁니다. 그 후 딥러닝에서 sequential data를 다루는 Recurrent Neural Networks 에 대한 정의와 종류에 대해 배웁니다.   Sequential Model - Naive sequence model   Sequential Data는 우리의 일상에서 언어나 주식 차트, 영상 등이 해당될 수 있습니다.   이미지 같은 고정된 차원의 데이터가 아닌 시간에 따라 데이터가 입력이 되는 시계열 데이터에 대해 동작하는 것이 Sequential Model이라고 할 수 있습니다.   예를 들어 현재 무슨 언어가 나올지 예측하는 모델을 생각해 볼 수 있습니다. 시간상으로 전에 나온 단어들로 미래의 단어를 예측한다던지..   첫번째 단어가 입력이 되면, 두번째 단어는 첫번째 단어를 고려, 세번째 단어는 두번째, 첫번째 단어를 고려.. 반복   그럼 이 모델은 현재 단어를 예측하기 위해 고려해야 하는 데이터의 개수가 시간이 지남에 따라 계속 증가하게 됩니다.      Sequential Model - Auto regressive model   위의 모델은 현재를 예측할 때 과거의 데이터를 다 고려했다면, 이 방법은 fixed timespan을 두어 과거의 몇개만 고려하는 것입니다.   예를들어 과거에 대해 5개의 데이터만 보겠다하면 T의 값은 5가 됩니다. x_t = x_1 ~ x_5까지만 보겠다.      Markov model   이 모델은 현재의 값은 직전 과거의 하나의 데이터에만 dependent 하다는 것을 가정으로 두게됩니다.   이 모델은 과거의 하나의 데이터만을 이용하기 때문에, 위의 모델에 비해 당연히 많은 과거의 정보를 이용할 수가 없게 됩니다.      Latent autoregressive model   처음 살펴본 두개의 모델의 가장 큰 단점은 과거의 방대한 데이터를 다 고려해야한다는 것입니다.   이 모델은 모델 중간에 Hidden state가 들어있는 모델입니다. 이 Hidden state가 하는 일은 과거 데이터의 정보를 summary 한다고 볼 수 있습니다.   그래서 다음의 타임스텝의 아웃풋은 현재의 인풋과 바로 이전의 Hidden state에 의존하여 작동할 수 있게 됩니다.      Recurrent Neural Network   위에서 설명한 여러가지 모델들을 가장 잘 표현한 것이 Recurrent Neural Network 라고 할 수 있습니다.   Recurrent Neural Network는 MLP와 다른 점이 있다면, 자기 자신을 돌아오는 구조가 하나 있다는 것입니다.   이런 구조에서 타임t에서의 h는 x_t에서만 dependent한 것이 아니라, t-1의 A로 표시된 Sell state에도 dependent 하게 됩니다.   밑의 그림에서 오른쪽 그림은 왼쪽에서의 그림을 시간순으로 쭉 나열한 것이 됩니다.      Short-term dependencies   위에서 살펴본 RNN 구조에서의 가장 큰 단점이라고 한다면 Short-term dependencies을 들 수 있습니다.   과거의 모든 정보들이 다 취합이 되서 요약되고 미래에서 그것을 고려가 되어야하는데, RNN 자체는 하나의 fixed rule로 이 정보들을 계속 취합하기 때문에, 먼 과거에 있던 정보가 미래까지 살아남기 힘든 것을 의미합니다.   Short-term dependencies 즉, 현재에서 몇개의 전 과거의 데이터는 잘 고려가 되는데, 한 참 멀리 있는 정보를 고려하기 힘든것을 말하는 것입니다.      Long Short-term Memory   기존의 RNN 구조를 살펴보면, x가 A의 구조를 통과해서 h라는 아웃풋을 산출하고 h는 다시 다음번의 A구조로 들어가게 됩니다. 여기서 A구조에서는 weight와 계산이 되고, activation function과 계산이되게 됩니다.      기존의 RNN을 개선한 Long Short-term Memory의 구조는 다음과 같습니다.   Long Short-term Memory의 각각의 컴포넌트가 어떻게 동작하고 이 구조가 왜 Short-term dependencies를 극복하는지 알아보겠습니다.      Long Short-term Memory의 구조를 세부적으로 묘사한 그림입니다.   x_t는 인풋으로써 언어 모델이라면 여러개의 단어(5000개의 단어)를 표현한 원-핫 벡터가 될 수도 있고, 워드 임베딩된 벡터로 표현될 수도 있습니다.   h_t는 hidden state이면서, output이 됩니다.   previous cell state는 0부터 t-1까지의 정보를 다 취합해서 summarize 해주는 정보가 됩니다.   previous hidden state는 위쪽으로 previous cell state 들어가기도 하지만 오른쪽으로 여러 연산의 입력으로도 들어가게 됩니다.   전체적으로 보면 들어오는 입력은 3개가 되고 나가는 출력도 3개가 됩니다. 출력 중 2개는 다음번 입력으로 들어가고, 나머지 하나는 실제 아웃풋이 됩니다.      Long Short-term Memory은 총 4개의 gate로 이루어져 있습니다.      그림에서 검은 선이 바로 cell state이고, C_0부터 C_t 까지 들어온 정보를 요약하게 됩니다.  타임스탬프 t마다 컨베이어 벨트에서 처럼 물건(정보)이 올라오고, 그 정보들을 잘 조작해서, 어떤 것이 유용하고 어떤 것이 유용하지 않은지 정해서 다음번 셀로 이 정보들을 넘겨주는 역할을 하게 됩니다.   정보들을 잘 조작해서, 어떤 것이 유용하고 어떤 것이 유용하지 않은지 정해서 올리는 역할은 gate가 하게 됩니다.      Forget gate는 어떤 정보를 버릴지 정하는 역할을 합니다.  Forget gate에는 현재의 입력 x_t와 이전의 hidden state value인 h_t-1이 들어가서 f_t라는 숫자를 얻어내게 됩니다. 시그모이드를 통과하기 때문에 항상 f_t는 0에서 1사이 값을 갖게 됩니다.   f_t는 이전 cell state에서 나온 정보들 중에 어떤 것을 버리고, 어떤것을 살릴지 정해주게 됩니다.   Input gate는 어떤 정보를 cell state에 저장할지(올릴지) 정하는 역할을 합니다.  현재에 어떤 입력이 들어왔는데, 이것을 무작정 cell state에 올리는 것이 아닌, 이 정보중에 어떤 정보를 올릴지 정하게 됩니다.   i_t는 어떤 정보를 cell state에 올릴지 또는 저장할지 정하게 됩니다. 이전의 hidden state value와 현재의 입력을 가지고 만들어 지게 됩니다.   그렇다면 우리가 실제로 올릴 정보를 알아야합니다.   C_t~가 이 역할을 하게 됩니다.      update gate는 이전까지 summarize 되어있던 cell state와 올릴지 또는 저장할지 정하는 i_t 그리고 C_t~를 가지고 cell state에 update하는 역할을 합니다.   이전 cell state인 C_t-1과 f_t 만큼을 곱해서 C_t-1에서 어떤 정보를 버리게 되고 나오는 값 A, C_t~와 i_t만큼을 곱해서 어느 값을 올릴지를 정해서 만들어진 값 B, 이 두 값을 combine해서 다음 cell state인 C_t으로 업데이트 하는 역할을 합니다.   Out state는 어떤 값을 밖으로 내보낼지 결정하는 역할을 합니다.   o_t는 어떤 값을 내보낼지 정하는 역할을 하게 되고 이를 thanh를 통과한 C_t인 updated cell state와 Element wise multiplication을 해서 결정적으로 h_t가 만들어 지게 됩니다.      References      RNN - 최성준 교수님  ","categories": ["Development"],
        "tags": ["AI","Python"],
        "url": "http://localhost:4000/development/boostcamp-week3-day15/",
        "teaser":null},{
        "title": "Intro to NLP, Bag-of-Words, Naive Bayes Classifier ",
        "excerpt":"Intro to NLP, Bag-of-Words, Naive Bayes Classifier   NLP에 대해 짧게 소개하고 자연어를 처리하는 가장 간단한 모델 중 하나인 Bag-of-Words를 알아봅니다.   Bag-of-Words는 단어의 표현에 있어서 one-hot-encoding을 이용하며, 단어의 등장 순서를 고려하지 않는 아주 간단한 방법 중 하나입니다. 간단한 모델이지만 많은 자연어 처리 task에서 효과적으로 동작하는 알고리즘 중 하나입니다.   그리고, 이 Bag-of-Words를 이용해 문서를 분류하는 Naive Bayes Classifier에 대해서 설명합니다.   What is Natural language processing? (NLP)   Natural language processing (NLP), which aims at properly understanding and generating human languages, emerges as a crucial application of artificial intelligence, with the advancements of deep neural networks.   인간의 언어를 적절하게 이해하고 생성하는 것을 목표로하는 자연어 처리 (NLP)는 심층 신경망의 발전과 함께 인공 지능의 중요한 응용 프로그램으로 부상하고 있습니다.   NLP is used in various field in deep learning approaches as well as their applications such as language modeling, machine translation, question answering, document classification, and dialog systems.   NLP는 언어 모델링, 기계 번역, 질문 답변, 문서 분류 및 대화 시스템과 같은 응용 프로그램뿐만 아니라 딥 러닝 접근 방식의 다양한 분야에서 사용됩니다.   Natural language processing의 연구동향은 ACL, EMNLP, NAACL와 같은 학회에서 발표가 됩니다.   Academic Disciplines related to NLP     Natural language processing (major conferences: ACL, EMNLP, NAACL)           Low-level parsing : Tokenization(문자를 특정 단위로 자르는 것), stemming(영어, 한글에서와 같이 같은 의미론적의 단어라도 어미나 형태가 달라질 수 있고, 여기서 어근을 뽑아내는 것 ex) study, studied, studying…)            Word and phrase level : Named entity recognition(NER), part-of-speech(POS) tagging, noun-phrase chunking, dependency parsing, coreference resolution            Sentence level : Sentiment analysis(감정 분석), machine translation(기계 독해)            Multi-sentence and paragraph level : Entailment prediction, question answering(질문에 대한 정확한 대답), dialog systems(챗봇), summarization(긴 문장이나 문단에 대해서 짧게 요약)       Text mining (major conferences: KDD, The WebConf (formerly, WWW), WSDM, CIKM, ICWSM)           Extract useful information and insights from text and document data : 예를 들어, 방대한 뉴스 데이터로 부터 현재 AI 트렌드 키워드를 분석하는 것            Document clustering (e.g., topic modeling) : 방대한 데이터로 부터 여러 다른 주제에 대해 서로 그룹화 하는 것            Highly related to computational social science : 예를 들어, 소셜 미디어 데이터에 기반해 사람들의 정치적 성향의 변화를 분석하는 것       Information retrieval (major conferences: SIGIR, WSDM, CIKM, RecSys)      Recommendation system : 추천 시스템 (사용자의 성향을 바탕으로 관련된 토픽을 추천해 주는 등…)   Trends of NLP   Text data can basically be viewed as a sequence of words, and each word can be represented as a vector through a technique such as Word2Vec or GloVe.   RNN-family models (LSTMs and GRUs), which take the sequence of these vectors of words as input, are the main architecture of NLP tasks.   Overall performance of NLP tasks has been improved since attention modules and Transformer models, which replaced RNNs with self-attention, have been introduced a few years ago.   As is the case for Transformer models, most of the advanced NLP models have been originally developed for improving machine translation tasks.   In the early days, customized models for different NLP tasks had developed separately.   Since Transformer was introduced, huge models were released by stacking its basic module, self-attention, and these models are trained with large-sized datasets through language modeling tasks, one of the self-supervised training setting that does not require additional labels for a particular task.   Afterwards, above models were applied to other tasks through transfer learning, and they outperformed all other customized models in each task.   Currently, these models has now become essential part in numerous NLP tasks, so NLP research become difficult with limited GPU resources, since they are too large to train.   Bag-of-Words   Bag-of-Words는 단어의 표현에 있어서 숫자 형태로 나타내는 one-hot-encoding을 이용하며, 단어의 등장 순서를 고려하지 않는 아주 간단한 방법 중 하나입니다. 간단한 모델이지만 많은 자연어 처리 task에서 효과적으로 동작하는 알고리즘 중 하나입니다.   Step 1. Constructing the vocabulary containing unique words   문장들에서, 고유한 단어들을 뽑아서 단어사전을 구축합니다.      Step 2. Encoding unique words to one-hot vectors   고유한 단어들을 순서대로 원-핫-인코딩을 적용합니다.   항상 자기 자신을 제외한 어느 단어들과의 유클리드 거리는 루트 2, 코사인 유사도(내적)은 0이 됩니다.      Step 3. A sentence/document can be represented as the sum of one-hot vectors   sentence/document를 이뤘던 단어들의 원-핫 벡터를 Element wise하게 모두 더해줍니다.      NaiveBayes Classifier for Document Classification   Bag-of-Words로 나타내어진 문서를 정해진 카테고리 혹은 클래스로 분류할 수 있는 모델입니다.      Bag-of-Words for Document Classification        Bayes’ Rule Applied to Documents and Classes   d = 분류 되어질 문서, C = C개의 클래스   특정한 문서 d가 주어져 있을 때, 그 문서가 특정 클래스 중 하나인 c에 속할 확률 : P(c|d), 조건부 확률 분포상, 가장 높은 확률을 가지는 c를 통해서 문서 분류를 수행   P(c|d)는 Bayes’ Rule에 의해 아래의 그림에서의 중간 식과 같이 나타내어 질 수 있다.   Bayes’ Rule에서 P(d)는 문서 d가 뽑힐 확률, d는 우리가 분류할 고정된 하나의 개체라고 볼 수 있으므로, argmax operation 상에서 상수로 무시할 수 있게 되고, 이는 맨 아래의 식으로 유도될 수 있음.      P(d|c)는 특정 클래스가 고정이 되었을 때, 문서 d가 나타날 확률을 의미. 문서 d가 나타날 확률은 문서에서의 단어 w1 .. wn가 동시적으로 그리고 독립적으로 일어난 사건을 의미.      예시로, 다음과 같이 d가 4개, 그 다음 각 문서에서의 단어들 w, 그리고 문서들이 속할 클래스 c가 있습니다.   P(c_cv)는 문서 cv가 선택될 확률이므로 전체 4개의 문서 중 2개 : 0.5  P(c_NLP)도 위와 같습니다.      그리고 각 문서에서의 특정 단어가 나타날 확률은 다음의 표와 같을 때, 문서 d5가 주어졌을 때, 어느 클래스에 속할지 구하는 확률은 위에서 구한 공식에 대입하면 다음 그림과 같습니다.   d5가 cv클래스에 속할 확률 : cv 클래스의 문서가 뽑힐 확률 x P(w|c_cv) of words of w_d5  d5가 NLP클래스에 속할 확률 : NLP 클래스의 문서가 뽑힐 확률 x P(w|c_NLP) of words of w_d5      References      RNN - 주재걸 교수님  ","categories": ["Development"],
        "tags": ["AI","Deep Learning","Math"],
        "url": "http://localhost:4000/development/boostcamp-week4-day16/",
        "teaser":null},{
        "title": "Recurrent Neural Network, Types of RNNs and LSTM ",
        "excerpt":"Sequential Models - RNN   자연어 처리 분야에서 Recurrent Neural Network(RNN)가 무엇이고, Gradient Vanishing/Exploding의 문제를 보완한 Vanilla RNN을 발전시킨 LSTM을 알아보고, RNN의 Type을 알아봅니다.   Sequential Model - Naive sequence model   Sequential Data는 우리의 일상에서 언어나 주식 차트, 영상 등이 해당될 수 있습니다.   이미지 같은 고정된 차원의 데이터가 아닌 시간에 따라 데이터가 입력이 되는 시계열 데이터에 대해 동작하는 것이 Sequential Model이라고 할 수 있습니다.   예를 들어 현재 무슨 언어가 나올지 예측하는 모델을 생각해 볼 수 있습니다. 시간상으로 전에 나온 단어들로 미래의 단어를 예측한다던지..   첫번째 단어가 입력이 되면, 두번째 단어는 첫번째 단어를 고려, 세번째 단어는 두번째, 첫번째 단어를 고려.. 반복   그럼 이 모델은 현재 단어를 예측하기 위해 고려해야 하는 데이터의 개수가 시간이 지남에 따라 계속 증가하게 됩니다.      Sequential Model - Auto regressive model   위의 모델은 현재를 예측할 때 과거의 데이터를 다 고려했다면, 이 방법은 fixed timespan을 두어 과거의 몇개만 고려하는 것입니다.   예를들어 과거에 대해 5개의 데이터만 보겠다하면 T의 값은 5가 됩니다. x_t = x_1 ~ x_5까지만 보겠다.      Markov model   이 모델은 현재의 값은 직전 과거의 하나의 데이터에만 dependent 하다는 것을 가정으로 두게됩니다.   이 모델은 과거의 하나의 데이터만을 이용하기 때문에, 위의 모델에 비해 당연히 많은 과거의 정보를 이용할 수가 없게 됩니다.      Latent autoregressive model   처음 살펴본 두개의 모델의 가장 큰 단점은 과거의 방대한 데이터를 다 고려해야한다는 것입니다.   이 모델은 모델 중간에 Hidden state가 들어있는 모델입니다. 이 Hidden state가 하는 일은 과거 데이터의 정보를 summary 한다고 볼 수 있습니다.   그래서 다음의 타임스텝의 아웃풋은 현재의 인풋과 바로 이전의 Hidden state에 의존하여 작동할 수 있게 됩니다.      Recurrent Neural Network   위에서 설명한 여러가지 모델들을 가장 잘 표현한 것이 Recurrent Neural Network 라고 할 수 있습니다.   Recurrent Neural Network는 MLP와 다른 점이 있다면, 자기 자신을 돌아오는 구조가 하나 있다는 것입니다.   이런 구조에서 타임t에서의 h는 x_t에서만 dependent한 것이 아니라, t-1의 A로 표시된 Sell state에도 dependent 하게 됩니다.   밑의 그림에서 오른쪽 그림은 왼쪽에서의 그림을 시간순으로 쭉 나열한 것이 됩니다.      Short-term dependencies   위에서 살펴본 RNN 구조에서의 가장 큰 단점이라고 한다면 Short-term dependencies을 들 수 있습니다.   과거의 모든 정보들이 다 취합이 되서 요약되고 미래에서 그것을 고려가 되어야하는데, RNN 자체는 하나의 fixed rule로 이 정보들을 계속 취합하기 때문에, 먼 과거에 있던 정보가 미래까지 살아남기 힘든 것을 의미합니다.   Short-term dependencies 즉, 현재에서 몇개의 전 과거의 데이터는 잘 고려가 되는데, 한 참 멀리 있는 정보를 고려하기 힘든것을 말하는 것입니다.      Long Short-term Memory   기존의 RNN 구조를 살펴보면, x가 A의 구조를 통과해서 h라는 아웃풋을 산출하고 h는 다시 다음번의 A구조로 들어가게 됩니다. 여기서 A구조에서는 weight와 계산이 되고, activation function과 계산이되게 됩니다.      기존의 RNN을 개선한 Long Short-term Memory의 구조는 다음과 같습니다.   Long Short-term Memory의 각각의 컴포넌트가 어떻게 동작하고 이 구조가 왜 Short-term dependencies를 극복하는지 알아보겠습니다.      Long Short-term Memory의 구조를 세부적으로 묘사한 그림입니다.   x_t는 인풋으로써 언어 모델이라면 여러개의 단어(5000개의 단어)를 표현한 원-핫 벡터가 될 수도 있고, 워드 임베딩된 벡터로 표현될 수도 있습니다.   h_t는 hidden state이면서, output이 됩니다.   previous cell state는 0부터 t-1까지의 정보를 다 취합해서 summarize 해주는 정보가 됩니다.   previous hidden state는 위쪽으로 previous cell state 들어가기도 하지만 오른쪽으로 여러 연산의 입력으로도 들어가게 됩니다.   전체적으로 보면 들어오는 입력은 3개가 되고 나가는 출력도 3개가 됩니다. 출력 중 2개는 다음번 입력으로 들어가고, 나머지 하나는 실제 아웃풋이 됩니다.      Long Short-term Memory은 총 4개의 gate로 이루어져 있습니다.      그림에서 검은 선이 바로 cell state이고, C_0부터 C_t 까지 들어온 정보를 요약하게 됩니다.  타임스탬프 t마다 컨베이어 벨트에서 처럼 물건(정보)이 올라오고, 그 정보들을 잘 조작해서, 어떤 것이 유용하고 어떤 것이 유용하지 않은지 정해서 다음번 셀로 이 정보들을 넘겨주는 역할을 하게 됩니다.   정보들을 잘 조작해서, 어떤 것이 유용하고 어떤 것이 유용하지 않은지 정해서 올리는 역할은 gate가 하게 됩니다.      Forget gate는 어떤 정보를 버릴지 정하는 역할을 합니다.  Forget gate에는 현재의 입력 x_t와 이전의 hidden state value인 h_t-1이 들어가서 f_t라는 숫자를 얻어내게 됩니다. 시그모이드를 통과하기 때문에 항상 f_t는 0에서 1사이 값을 갖게 됩니다.   f_t는 이전 cell state에서 나온 정보들 중에 어떤 것을 버리고, 어떤것을 살릴지 정해주게 됩니다.   Input gate는 어떤 정보를 cell state에 저장할지(올릴지) 정하는 역할을 합니다.  현재에 어떤 입력이 들어왔는데, 이것을 무작정 cell state에 올리는 것이 아닌, 이 정보중에 어떤 정보를 올릴지 정하게 됩니다.   i_t는 어떤 정보를 cell state에 올릴지 또는 저장할지 정하게 됩니다. 이전의 hidden state value와 현재의 입력을 가지고 만들어 지게 됩니다.   그렇다면 우리가 실제로 올릴 정보를 알아야합니다.   C_t~가 이 역할을 하게 됩니다.      update gate는 이전까지 summarize 되어있던 cell state와 올릴지 또는 저장할지 정하는 i_t 그리고 C_t~를 가지고 cell state에 update하는 역할을 합니다.   이전 cell state인 C_t-1과 f_t 만큼을 곱해서 C_t-1에서 어떤 정보를 버리게 되고 나오는 값 A, C_t~와 i_t만큼을 곱해서 어느 값을 올릴지를 정해서 만들어진 값 B, 이 두 값을 combine해서 다음 cell state인 C_t으로 업데이트 하는 역할을 합니다.   Out state는 어떤 값을 밖으로 내보낼지 결정하는 역할을 합니다.   o_t는 어떤 값을 내보낼지 정하는 역할을 하게 되고 이를 thanh를 통과한 C_t인 updated cell state와 Element wise multiplication을 해서 결정적으로 h_t가 만들어 지게 됩니다.      Types Of RNNs   다루고자 하는 데이터와 문제에 따라 RNN을 여러 형태로 하여 구성할 수 있습니다.      one-to-one   one-to-many   many-to-one   many-to-many   One-to-one   입력과 출력의 타임스탭이 단 하나인 스탠다드한 모델 구조를 말합니다.  모델은 입력 벡터를 받아 가중치를 이용해 입력 벡터를 선형변환과 필요하다면 비선형 함수를 적용하고, 출력 벡터를 산출한다는 의미가 됩니다.      One-to-many   입력이 하나의 타임스탭으로 이루어지고, 출력은 여러 타임스탭으로 이루어진 모델 구조를 말합니다.  대표적으로 Image Captioning이 이에 해당할 수 있습니다. 입력으로는 하나의 이미지를 받고, 이 이미지에 대한 설명으로 각 타임스탭마다 하나의 단어를 산출한다는 점을 들 수 있습니다.   매 타입스탭마다 모델로 입력이 주어져야 하지만, 밑의 사진처럼 따로 주어질 입력이 없는 경우 원래의 입력 사이즈와 같고 값이 0으로 채워진 벡터나 행렬을 입력으로 주게 됩니다.      Many-to-one   입력이 여러개의 타임스탭으로 이루어지고, 출력은 하나의 타임스탭으로 이루어진 모델을 말합니다.  대표적으로 여러개의 입력을 받아 종합적으로 이 입력들의 감정을 분류하는 Sentiment Classification을 예로 들 수 있습니다.      Many-to-many   입력과 출력 모두 여러개의 타임스탭으로 이루어진 시퀀스한 모델을 말합니다.  대표적으로 입력 단에서 특정 어느 나라 말을 끝까지 시간순으로 읽은 후, 출력단에서 순차적으로 다른 나라말로 번역(예측)이 되는, 기계독해 - Machine Translation을 예로 들 수 있습니다.      References      RNN - 주재걸, 최성준 교수님  ","categories": ["Development"],
        "tags": ["AI","RNN","Python","Math"],
        "url": "http://localhost:4000/development/boostcamp-week4-day17/",
        "teaser":null},{
        "title": "Sequence to Sequence with Attention",
        "excerpt":"Sequence to Sequence   Sequence를 Encoding과 Decoding 할 수 있는 sequence to sequence에 대해 알아봅니다.   Sequence to sequence는 encoder와 decoder로 이루어져 있는 framework으로 대표적인 자연어 처리 architecture 중 하나입니다.   Encoder-decoder architecture   Sequence to Sequence 모델은 여러개의 입력 단어 시퀀스를 받아 처리하는 Encoder, 출력 단어를 순차적으로 생성하는 Decoder로 구성됩니다.   각각의 모듈은 서로 파라미터를 공유하지 않는 독립된 RNN 모듈이라고 생각할 수 있습니다.   그림에서는 RNN 모델을 LSTM 모듈로서 채용한 것을 알 수 있습니다.   Sequence to Sequence의 Encoder에서 입력 단어의 마지막 까지 읽어들인 후, Encoder에서 나온 제일 마지막 hidden state vector가 Decoder로 제일 처음 h0 벡터로서 입력으로 들어가게 됩니다.   h0는 입력 단어들을 잘 요약 정리한 정보라고 할 수 있고, 이는 출력단에서 순차적으로 처리가 되어 대응 되는 다음 단어를 생성하는데 사용될 수 있습니다.   Start 토큰은 실질적으로 예측하고자 하는 결과 단어를 만들기 위한 제일 처음 넣어주는 인풋값으로서 사용하게 됩니다.   End 토큰은 Decoder에서 문장이 끝나는 시점을 의미하고, 이 토큰이 생성되면 디코더의 실행은 멈추게 됩니다.      Seq2Seq Model with Attention   기존에는 인코더의 마지막 hidden state 벡터의 입력만 디코더에 넣어줘서 결과를 순차적으로 생성했다면, Attention을 적용한 경우에는, 인코더에서 각각의 타임스탭마다 만들어진 중간 노드들의 hidden state vector들을 디코더의 매 타임 스탭마다 하나의 정보로서 같이 활용하게 됩니다.      인코더에서 만들어진 마지막 hidden state vector = h0와 start 토큰이 디코더를 거쳐 h1 state vector를 만들게 되는데 이는 인코더 단의 각각의 매 타임 스탭마다 만들어진 h1 ~ h4와 각각 내적의 연산을 수행하게 됩니다.   이 내적 연산의 결과값의 의미는 h1 state vector와 각각의 인코더 hidden state vector간의 내적에 기반한 유사도라고 할 수 있습니다.      우리는 이 값들을 다시 소프트맥스 층에 적용하여, 각각의 인코더 hidden state vector와의 대응되는 확률 값으로 해석할 수 있습니다.   이 각각의 값들은, 각각의 인코더 hidden state vector로의 부여되는 가중치로서 사용이 되고, 이 4개의 값들을 가중평균을 내어 다시 종합된 하나의 인코딩 vector를 생성할 수 있게 됩니다. 이를 context vector 라고도 부릅니다.   예시로든 사진에서는 0.85의 값이 제일 높은데 이는, 인코더의 첫번째 타임스탭의 단어를 제일 높은 확률로 필요로 한다는 의미가 됩니다.      밑의 그림에서 녹색 원 안에의 부분을 우리는 Attention 모듈이라고 부르게 되고, 입력으로 인코더 단에서의 각각의 hidden state vector와 디코더 단에서의 hidden state vector가 들어가게 되고, Attention 모듈의 출력으로는 인코더 단에서의 각각의 hidden state vector의 가중 평균이 되는 context vector가 됩니다.      이렇게 만들어진 context vector는 앞서 만들어진 디코더 단의 hidden state vector와 concat이 되어서 그림에서는 y3 아웃풋을 만들게 되고, 이는 다음 타임 스탭으로의 입력으로 들어가게 됩니다.      디코더 단에서 y6인 money를 예측하는 타임 스탭에서의 그림은 다음과 같습니다.      이렇게 디코더 단에서 매 타임 스탭마다 단어를 예측하는데에 있어서 각각의 인코더 hidden state vector가 쓰이게 되고 매번 다른 가중치가 적용된 가중평균된 context vector를 생성하게 되고, context vector가 매 타임 스탭마다 생성되고 아웃풋에 직접적인 입력의 일부로서 사용이 되어 그 해당 타임 스탭에서의 보다 좀 더 정확한 예측이 가능하도록 하게 만듭니다.   이를 End of sentence를 의미하는 END 토큰이 나올 때 까지 반복을 하게 됩니다.   References      RNN - 주재걸, 최성준 교수님  ","categories": ["Development"],
        "tags": ["AI","RNN","Python","Math"],
        "url": "http://localhost:4000/development/boostcamp-week4-day18/",
        "teaser":null}]
