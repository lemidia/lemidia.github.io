var store = [{
        "title": "Recursion",
        "excerpt":"Recursion  컴퓨터 과학에서의 Recursion은 어떤 문제가 그 문제의 더 작은 사례의 해결에 의존해 해결되는 방법론이다. 재귀적인 문제는 반복적인 방법으로도 풀어질 수 있는데 그렇게 되기 위해선 런 타임 이전에 더 작은 사례를 식별하고 인덱스화 해야한다. 컴퓨터 과학 그리고 프로그래밍에서 Recursion은 함수가 자기 코드(own code) 안에서 자기 자신을 호출함으로 재귀적인 문제를 해결한다. Recursion은 많은 종류의 문제에서 적용될 수 있고 컴퓨터 과학에서의 중요한 이론이므로 잘 알아둘 필요가 있다.   대부분의 프로그래밍 언어는 함수가 자기 코드(own code) 안에서 자기 자신을 호출하는 방식으로 재귀를 지원한다. 함수적 프로그래밍 언어는 반복적인 구조를 정의하지 않으므로 오직 재귀적인 방법에만 의존해 문제를 해결한다.   함수안에서 자기 자신을 반복적으로 호출하는 재귀적인 방식을 사용하면 콜스택의 크기가 계속 커져 모든 호출과 연관된 입력 크기의 합과 같아질 수 있고, 이는 반복적인 방법으로 쉽게 해결이 가능한 문제의 경우 재귀를 적용했을 때의 효율성이 떨어진다는 것을 말한다. 또한 재귀적인 방법을 적용할 때 다소 큰 문제에 대해서는 tail call 같은 최적화 기술을 사용하는 것이 필수적이다.   Recursive functions   컴퓨터 과학에서 어떤 문제를  일반적인 방법 중의 하나는 분할 정복(Divide and conquer)이라는 것을 사용하는 것이다. 분할 정복은 어떤 문제를 같은 타입의 더 작은 문제들로 분할해 이를 해결하고 다시 합쳐 원래의 문제를 해결하는 방법론을 말한다. 여기서, 재귀 함수(Recursive functions)를 이용하면 분할 정복을 보다 쉽게 적용할 수 있게된다. 문제에 따라서는 해당 문제의 더 작은 사례들이 겹칠 수가 있어 같은 문제를 반복적으로 풀지않고, 계산 시간을 절약하기 위해 더 작은 문제들의 솔루션을 저장한 동적표 또는 룩업 테이블(Dynamic table or look up table)을 구성하는데, 이를 함께 적용한 방법을 이를 동적 프로그래밍 또는 메모이제이션(dynamic programming or memoization)이라 부른다.   일반적으로 재귀 함수(Recursive functions)는 단순히 조건에 따라 값을 반환하는 하나 이상의 기본 또는 기저 사례들(base cases)과 자기 자신을 호출하는 하나 이상의 재귀 사례들(Recursive cases)로 구성된다. 팩토리얼을 계산을 예로 들면, 입력 값 n이 0 일때는 0! = 1의 단순히 1을 반환하는 기저 사례, 입력 값 n이 0 보다 클 때는 n! = n(n − 1)!의 재귀 사례로 구성할 수 있다.   unsigned int factorial(unsigned int n) {     if (n == 0) {         return 1;     } else {         return n * factorial(n - 1);     } }   재귀 함수에서의 재귀 사례는 보다 큰 입력을 단순한 입력으로 분해하는 것으로 볼 수 있다. 잘 설계된 재귀 함수에서의 각 재귀 호출은 입력 문제를 보다 단순한 사례로 분해하고 결국에는 기본 사례에 도달하게 한다. 주의할 점은 기본 사례를 잘못 만들거나 생략하면(missing) 재귀 함수는 무한 루프(infinity loop)에 빠질 수 있다.   Single recursion and multiple recursion   재귀 함수가 단순히 하나의 자기 호출(single self-reference)을 가지고 있다면 이것을 단일 재귀(Single recursion), 여러개의 자기 호출(multiple self-references)을 가지고 있다면 다중 재귀(multiple recursion)라고 한다. 단일 재귀를 사용한 예로는 선형 탐색의 리스트 순회, 팩토리얼 계산이 있다. 이것들은 모두 하나의 재귀 사례로 행해질 수 있는 계산들이다.   다음은 단일 재귀의 리스트 순회 코드이다.   public static void listTraversal(listNode node) { \t// 현재 노드가 null이면 리턴 \tif (node == null) { \t  return; \t} \t// 현재 노드의 데이터를 출력한다. \tSystem.out.print(root.data + \" \"); \t// 재귀적으로 현재 노드의 다음 노드를 탐색한다. \tlistTraversal(node.next); }  현재 노드가 null인지 체크해 재귀를 끝내는 기본 사례와 다음 노드로의 탐색을 진행하는 단일 재귀 호출로 구성되어 있음을 볼 수 있다.     다중 재귀를 사용한 예로는 깊이우선탐색 방식의 트리 순회를 들 수 있다. 대표적인 깊이우선탐색 방식의 트리 순회는 전위 순회, 중위 순회, 후위순회가 있으며 이들 모두는 2개의 다중 재귀 사례를 가지고 있다.   다음은 트리 순회의 한 가지인 중위 순회의 코드이다.   inorder 함수는 1개의 기본 사례와 2개의 재귀 사례로 구성되어 있음을 볼 수 있다.  // Recursive function to perform in-order traversal of the tree public static void inorder(TreeNode root) { \t// 현재 노드가 null이면 리턴 \tif (root == null) { \t\treturn; \t} \t// 재귀적으로 왼쪽 서브트리를 탐색한다. \tinorder(root.left); \t// 현재 노드의 데이터를 출력한다. (방문) \tSystem.out.print(root.data + \" \"); \t// 재귀적으로 오른쪽 서브트리를 탐색한다. \tinorder(root.right); }   단일 재귀는 대체로 다중 재귀보다 효율적이고, 일반적으로 선형 시간에 동작하고 상수적 메모리 공간을 요구하는 반복적인 계산 방법으로 대체될 수 있다. 그에 반해 다중 재귀는 지수적 시간 복잡도와 공간을 요구하고 명시적인 스택 없이는 반복적인 방법으로 대체될 수 없다.   다중 재귀나 반복적인 방법은 문제에 따라서 단일 재귀로 바뀔 수 있는데 피보나치 순열이 그 예이다. 피보나치 순열을 이전의 값들을 두 개의 다중 재귀를 표현하여 계산하는 것은 연속적인 두 값을 이용하여 나이브(naive)하게 반복적인 방법으로 대체될 수 있고, 이는 다시 연속적인 두 값을 단일 재귀의 매개변수로 넣음으로써 단일 재귀 방법으로 대체될 수 있다. 하지만 여기서의 단일 재귀는 일반 재귀 때 처럼 문제를 작은 사례로 분해하여 기본 사례로 가는 것이 아니라 처음부터 값을 추적해 나가는데, 이것을 역 재귀(corecursion)라고 부른다.   Recursive programs   Factorial   재귀의 전형적인 예로 팩토리얼 계산을 들 수 있다.   Recursive procedures  function factorial is:  input: integer n such that n &gt;= 0  output: [n × (n-1) × (n-2) × … × 1]      1. if n is 0, return 1     2. otherwise, return [ n × factorial(n-1) ]  end factorial    위 팩토리얼을 계산하는 함수를 fact(n)로 보고 n을 매개 값으로 보면 n이 4일 때는 다음과 같이 계산이 된다.   fact(4) = 4 * fact(3)         = 4 * (3 * fact(2))         = 4 * (3 * (2 * fact(1)))         = 4 * (3 * (2 * (1 * fact(0))))         = 4 * (3 * (2 * (1 * 1)))         = 4 * (3 * (2 * 1))         = 4 * (3 * 2)         = 4 * 6         = 24    재귀 함수는 루프 구조(looping construct)와 상수적 O(1)공간을 요구하는 변수를 사용함으로써 재귀를 사용하지 않고 아래와 같이 반복적인 방법(iterative)으로 표현할 수 있다.   Iterative procedures  function factorial is:  input: integer n such that n &gt;= 0  output: [n × (n-1) × (n-2) × … × 1]      1. create new variable called running_total with a value of 1      2. begin loop           1. if n is 0, exit loop           2. set running_total to (running_total × n)           3. decrement n           4. repeat loop      3. return running_total  end factorial   Greatest common divisor   두 정수의 최대 공약수(GCD, Greatest common divisor)를 계산하는 유클리디언 알고리즘도 다음과 같이 재귀를 이용하여 표현될 수 있다.   Recursive procedures  function gcd is: input: integer x, integer y such that x &gt; 0 and y &gt;= 0      1. if y is 0, return x     2. otherwise, return [ gcd( y, (remainder of x/y) ) ]  end gcd   x = 111 이고 y = 259 일 때의 위 함수를 적용하여 다음과 같이 계산된다.  gcd(111, 259)   = gcd(259, 111 % 259)                 = gcd(259, 111)                 = gcd(111, 259 % 111)                 = gcd(111, 37)                 = gcd(37, 111 % 37)                 = gcd(37, 0)                 = 37     마찬가지로 반복적인 방법으로 표현될 수 있다.   Iterative procedures  function gcd is:  input: integer x, integer y such that x &gt;= y and y &gt;= 0      1. create new variable called remainder      2. begin loop           1. if y is zero, exit loop           2. set remainder to the remainder of x/y           3. set x to y           4. set y to remainder           5. repeat loop      3. return x  end gcd   Binary search   이진 탐색은 사전에 미리 정렬이 완료된 배열이나 리스트에서 특정 값을 찾는 탐색 방법으로써 탐색의 매 단계마다 입력 배열의 반틈을 반복적으로 검색해 나간다. 입력 배열의 중간 지점을 선택해 찾고자 하는 데이터와 비교하고 찾았다면 그 값을 리턴한다. 아니라면, 중간 지점의 데이터가 찾고자 하는 데이터보다 작다면 중간 지점의 오른쪽 배열 반틈을, 중간 지점의 데이터가 찾고자 하는 데이터보다 크다면 중간 지점의 왼쪽 배열 반틈을 다시 검색해 나간다.   재귀의 속성이 이진 탐색에서 활용될 수 있는데, 매 탐색의 단계마다 입력 배열의 반틈을 반복적으로 탐색해 나가기 때문이다. 탐색의 매 단계마다 이전 배열로 부터 만들어진 새로운 배열에 대해 이진 탐색을 하는데 있어 재귀 함수를 적용할 수 있다. 이진 탐색은 탐색의 매 단계 마다 문제의 크기를 반틈씩 나누므로 로그적$O(logn)$ 성능을 보인다.   다음은 재귀를 적용한 이진 탐색 코드이다.  /*   Call binary_search with proper initial conditions.    INPUT:     data is an array of integers SORTED in ASCENDING order,     toFind is the integer to search for,     count is the total number of elements in the array    OUTPUT:     result of binary_search   */  int search(int *data, int toFind, int count)  {     //  Start = 0 (beginning index)     //  End = count - 1 (top index)     return binary_search(data, toFind, 0, count-1);  }   /*    Binary Search Algorithm.     INPUT:         data is a array of integers SORTED in ASCENDING order,         toFind is the integer to search for,         start is the minimum array index,         end is the maximum array index    OUTPUT:         position of the integer toFind within array data,         -1 if not found  */  int binary_search(int *data, int toFind, int start, int end)  {     //Get the midpoint.     int mid = start + (end - start)/2;   //Integer division      //Stop condition.     if (start &gt; end)        return -1;     else if (data[mid] == toFind)        //Found?        return mid;     else if (data[mid] &gt; toFind)         //Data is greater than toFind, search lower half        return binary_search(data, toFind, start, mid-1);     else                                 //Data is less than toFind, search upper half        return binary_search(data, toFind, mid+1, end);  }   References      Recursion   Recursion (Computer science)   Functional programming  ","categories": ["Algorithm"],
        "tags": ["Recursive","Computer science","Mathematics"],
        "url": "http://localhost:4000/algorithm/recursion/",
        "teaser":null},{
        "title": "스패닝 트리와 최소 스패닝 트리(Minimum Spanning Tree)",
        "excerpt":"들어가기 전에: 먼저 스패닝 트리가 무엇인지 알아보자.   스패닝 트리(Spanning tree)   G: 그래프  T: 스패닝 트리  V: 모든 정점의 개수  E: 모든 간선의 개수   라고 하자.   그래프 이론에서 어떤 비방향 그래프 G가 있다고 하면, 그 비방향 그래프 G의 스패닝 트리 T는 이렇게 정의된다.   Definition  그래프 G의 모든 정점을 연결하면서 가능한 최소의 간선 개수로 이루어지는 트리(또는 서브 그래프). (트리이므로 사이클은 포함하지 않아야 한다.)   이에 따라, 그래프 G의 스패닝 트리 T는 그래프 G의 모든 정점의 수 V개를 가지며, 간선의 개수는 V-1개를 가진다.   트리란?: 여기서 트리는 사이클을 가지지 않는 비방향 연결 그래프를 말한다.   아래 그림은 그래프 G의 스패닝 트리 T를 나타낸 것이다.      빨간점은 스패닝 트리 T의 정점, 파란선은 스패닝 트리 T의 간선을 나타낸다.   그림에서 보이는 것과 같이 스패닝 트리 T는 그래프 G의 모든 정점을 연결하고 있고, 스패닝 트리 T를 구성하는 간선의 개수는 최소가 되고 있다.  또한 사이클을 포함하지 않는다.   위 그래프 G의 정점의 개수를 V개라 하면, 스패닝 트리 T는 정점의 개수가 V개 즉, 16개 간선의 수는 V-1개 즉, 15개로 이루어져 있다.   일반적으로, 그래프는 아래 그림처럼 여러개의 스패닝 트리를 가질 수 있다.      하지만 그래프 G가 연결 그래프가 아니라면 스패닝 트리를 가질 수 없다.   만약 그래프 G의 모든 간선이 그래프 G의 스패닝 트리 T의 간선과 동일하다면, 그래프 G는 트리이고 또한 스패닝 트리 T라고 할 수 있다. (이것은 그래프 G가 유일한 스패닝 트리를 가질 수 있음을 의미한다.)   그래프 G의 스패닝 트리는 이렇게도 정의 될 수 있다.   사이클을 포함하지 않는 그래프 G의 간선의 최대 집합 혹은 그래프 G의 모든 정점을 연결하는 그래프 G의 간선의 최소 집합.   Fundamental cycles   스패닝 트리를 포함하는 그래프G의 간선들 중에서 스패닝 트리를 구성하지 않는 간선을 하나만 추가하면 사이클이 생긴다. 이러한 사이클을 Fundamental cycles이라 부른다.   스패닝 트리에 포함되지 않는 그래프의 각 간선들 마다 고유한 Fundamental cycles이 존재한다. 따라서, 스패닝 트리에 포함되지 않는 그래프의 각 간선들과 Fundamental cycles은 1:1 관계라고 볼 수 있다.   정점 V개의 연결 그래프는 V-1개의 간선을 가진 스패닝 트리를 가질 것이고 이는, 간선의 개수가 E개의 연결 그래프의 어떤 한 스패닝 트리는 E-V+1개의 Fundamental cycles을 가지게 된다.   요약: V: 그래프 G의 정점 개수, E: 그래프 G의 간선 개수라 한다면   스패닝 트리에 포함되지 않는 그래프 G의 간선들 = E - (V-1) = E - V + 1.  Fundamental cycles과 스패닝 트리에 포함되지 않는 그래프 G의 간선들은 1:1 관계이므로  Fundamental cycles = E - V + 1.   Fundamental cut sets   연결된 그래프 G에서, 그래프 G를 이루는 간선들 중 어느 간선들의 삭제가 그래프 G를 비연결 그래프로 만들게하는데 그 간선들의 집합을 cut sets이라 한다. cut sets은 그래프 G를 항상 두개의 그래프로 나눈다.   아래 그림은 그래프 G의 cut sets을 보여준다.      스패닝 트리는 그 트리를 이루는 간선들 중 하나의 간선만 삭제하면, 스패닝 트리를 이루는 정점들은 서로 다른 두개의 정점들 집합으로 분리된다. 따라서, 스패닝 트리를 이루는 모든 간선들은 cut sets이라고 볼 수 있다.   이러한, 스패닝 트리의 하나의 간선(가지)만을 포함하는 cut sets을 Fundamental cut sets이라고 한다.   최소 스패닝 트리(Minimum spanning tree)   위의 스패닝 트리를 이해했다면 최소 스패닝 트리의 개념은 간단하다.   그래프 G의 스패닝 트리 중에서 그 스패닝 트리를 구성하는 간선들의 가중치의 합이 최소가 되는 트리를 최소 스패닝 트리라고 한다.   다음 그래프 G의 그림을 보자.      굵은 검은선과 검은 정점들은 그래프G 최소 스패닝 트리를 나타내고, 회색 실선은 스패닝 트리에 포함되지 않는 그래프의 간선들을 나타낸다.   이처럼, 위 그림에서의 스패닝 트리는 여러가지가 있겠지만, 위 그림에서 표시된 스패닝 트리가 간선들의 가중치 합이 최소가 되게 하고 있다. (간선과 가중치의 구성에 따라 여러개의 최소 스패닝 트리가 나올 수 있다.)   컴퓨터 과학에서 이러한 그래프가 주어지면 최소 스패닝 트리를 구하는 알고리즘은 대표적으로 프림 알고리즘, 크루스칼 알고리즘 두 가지가 있다.   References    Spanning Tree - Wikipedia  Cut sets  ","categories": ["Data Structure"],
        "tags": ["Spanning Tree","Tree"],
        "url": "http://localhost:4000/data%20structure/spanning-tree/",
        "teaser":"http://localhost:4000/assets/images/spanning-tree-minimum.png"},{
        "title": "이분 탐색(Binary Search)",
        "excerpt":"이분 탐색(Binary Search)   컴퓨터 과학(Computer science)에서 이분 탐색(Binary Search)은 정렬된 배열(Sorted array)에서 찾고자 하는 값의 존재 유무나 위치를 찾는 알고리즘이다. 이분 탐색은 찾고자 하는 값을 배열의 중간 원소와 비교한다. 두 개의 값이 같지 않다면, 찾고자 하는 값이 놓여있지 않다고 판단되는 배열의 반은 탐색 범위에서 제외되고 나머지 반을 다시 탐색한다. 이것을 찾고자 하는 값이 나올 때까지 반복하는데, 탐색 공간이 빈 공간(크기가 0)이 되어 탐색이 끝나게 되면 해당 배열에서 찾고자 하는 값이 없다는 것을 의미한다.   탐색을 수행할 배열의 원소 개수가 $n$개일 때 이분 탐색은 복잡도 면에서 최악의 경우 $O(logn)$의 로그적 시간에 동작한다. 앞에서 부터 순서대로 하나씩 탐색하는 순차 혹은 선형 탐색(linear search)과 비교하면 작은 크기의 배열을 제외할 시 이분 탐색이 더 빠르다고 할 수 있다. 순차 탐색은 탐색에 있어 배열의 원소 순서에 제약이 없지만 이분 탐색은 원소의 정렬이 완료된 배열에서 탐색이 가능하다.   Algorithm   가장 일반적인 알고리즘을 보자.   배열은 오름차순으로 정렬되어 있다고 가정하고 시작한다. 먼저 찾고자 하는 값을 배열의 중간 위치의 원소 값과 비교한다. 찾고자 하는 값이 중간 위치의 원소 값과 일치하면 그 중간 원소의 위치를 반환하고 알고리즘을 끝낸다. 찾고자 하는 값이 중간 원소의 값보다 작다면 중간 원소를 기준으로 오른쪽의 값들은 찾고자 하는 값들보다 크므로 탐색을 수행할 필요가 없다. 따라서 왼쪽 반에 대해서 이분 탐색을 수행한다. 찾고자 하는 값이 중간 원소의 값보다 그다면 중간 원소를 기준으로 왼쪽의 값들은 찾고자 하는 값들보다 작으므로 탐색을 수행할 필요가 없다. 따라서 오른쪽 반에 대해서 이분 탐색을 수행한다. 이것을 원하는 값을 찾을 때 까지 수행한다. 탐색을 수행하다가 탐색 범위의 크기가 0이 되면 배열에서 찾고자 하는 값이 없다는 것을 의미한다.   Procedure   $n$개의 원소로 이루어진 $A_0,A_1,A_2,…,A_{n-1}$ 배열 $A$가 주어지고 원소들은 오름차순 $A_0 \\leq A_1 \\leq A_2 \\leq … \\leq A_{n-1}$ 으로 정렬되어 있다. 그리고 찾고자 하는 값 $T$가 주어진다.   다음의 절차로 배열 $A$에서 값 $T$를 찾는다.           배열의 맨 처음 인덱스를 가리키는 $L$을 $0$으로 배열의 맨 끝 인덱스를 가리키는 $R$을 $n-1$로 놓는다.            $L \\gt R$ 이면 탐색 공간의 크기가 0이 되고 배열에서 찾고자 하는 값이 없다는 것을 의미하므로 알고리즘을 종료한다.            배열의 중간 인덱스 원소를 가리키는 $m$을 $\\lfloor\\frac{L + R}{2}\\rfloor$로 놓는다. $\\lfloor x \\rfloor$, floor 기호는 $x$ 값 보다 크거나 같은 수 중 가장 작은 정수를 의미한다. 예) $\\lfloor\\frac{1+2}{2}\\rfloor$ = 1이다.            $A_m \\lt T$이면 $L$을 $m+1$로 놓고 2번으로 간다.            $A_m \\gt T$이면 $R$을 $m-1$로 놓고 2번으로 간다.            $A_m = T$ 이면 $m$을 반환하고 알고리즘을 종료한다.       다음은 위 절차에 대한 의사코드이다.   function binary_search(A, n, T) is     L := 0     R := n − 1     while L ≤ R do         m := floor((L + R) / 2)         if A[m] &lt; T then             L := m + 1         else if A[m] &gt; T then             R := m - 1         else:             return m     return unsuccessful   Alternative procedure   위에서 알아본 방법에서는 탐색의 매 반복 마다 중간 값 원소와 $T$를 비교하는 구문이 있다면, 이번 방법에서는 $L = R$이 같을 때에만 값이 같은지 체크를 수행한다. 이 방법은 위의 방법에 비해 비교 구문을 하나 제거하였기에 루프에서 빠른 비교를 가능하게 하지만 평균 상황에서 한 번의 반복을 더 요구한다.   다음의 절차로 배열 $A$에서 값 $T$를 찾는다.           배열의 맨 처음 인덱스를 가리키는 $L$을 $0$으로 배열의 맨 끝 인덱스를 가리키는 $R$을 $n-1$으로 놓는다.       while $L \\neq R$                     배열의 중간 인덱스 원소를 가리키는 $m$을 $\\lceil\\frac{L + R}{2}\\rceil$로 놓는다. $\\lceil x \\rceil$, ceil 기호는 $x$ 값 보다 크거나 같은 수 중 가장 작은 정수를 의미한다. 예) $\\lceil\\frac{1+2}{2}\\rceil$ = 2이다.                        $A_m \\gt T$이면 $R$을 $m-1$로 놓는다.                        $A_m \\leq T$이면 $L$을 $m$으로 놓는다.                   이제 $L = R$ 이다.  $A_L = T$ 이면 $L$을 반환한다. 아니라면, unsuccessful을 반환한다.   다음은 위 절차에 대한 의사코드이다.   function binary_search_alternative(A, n, T) is     L := 0     R := n − 1     while L != R do         m := ceil((L + R) / 2)         if A[m] &gt; T then             R := m - 1         else:             L := m     if A[L] = T then         return L     return unsuccessful   Duplicate elements   앞에서 알아본 방법에 의해 이분 탐색은 배열에서 찾고자 하는 값의 위치를 반환하는데, 중복된 값이 존재해도 마찬가지로 동작한다. 정렬된 배열 $[1,2,3,4,4,5,6,7]$이 있고 찾고자 하는 값이 4일 때, 위에서 알아본 방법에 의해 각각 4번째 위치(3번 인덱스)와 5번째 위치(4번 인덱스)를 반환할 것이다. 처음 알아본 방법은 4번째 위치를 반환할 것이다. 하지만 처음 알아본 방법은 중복된 값이 있으면 그 중에서 제일 처음 값을 반환하지 않는데, 만약 배열 $[1,2,4,4,4,5,6,7]$이 있다고 하면 처음 방법은 4번째 값을 반환하고, 중복된 첫번째 값(3번째 위치)을 반환하지 않는다. 특정 문제나 상황에서 배열에 찾고자 하는 값의 중복된 값이 존재하고 그 값들 중 가장 왼쪽 값 또는 가장 오른쪽 값을 찾아야 하는 경우가 있다. 배열 $[1,2,4,4,4,5,6,7]$에서 값 4의 가장 왼쪽 값은 3번째 위치의 4이고, 가장 오른쪽 값은 5번째 위치의 4이다. 위에서 알아본 Alternative procedure는 배열에서 찾고자 하는 값이 존재하면, 찾고자 하는 값들 중 가장 왼쪽의 위치를 반환한다.   Procedure for finding the leftmost element   다음은 중복된 값들 중 가장 왼쪽에 있는 값을 찾는 알고리즘이다.           배열의 맨 처음 인덱스를 가리키는 $L$을 $0$으로 배열의 맨 끝 인덱스를 가리키는 $R$을 $n$으로 놓는다.       while $L \\lt R$                     배열의 중간 인덱스 원소를 가리키는 $m$을 $\\lfloor\\frac{L + R}{2}\\rfloor$로 놓는다.                        $A_m \\lt T$이면 $L$을 $m+1$로 놓는다.                        $A_m \\geq T$이면 $R$을 $m$으로 놓는다.                   $L$을 반환한다.   위의 과정을 거치고, $L \\lt n$ $and$ $A_L = T$ 이면 $A_L$은 $T$와 같은 가장 왼쪽에 있는 원소이다. $T$가 배열에 있다면 $L$은 $T$의 가장 왼쪽 원소 위치를 가리키는 동시에 $T$보다 작은 원소들의 개수를 의미한다. 이것을 $Rank$라고 한다. $T$가 배열에 없다면 $L$은 $T$보다 작은 원소들의 개수를 의미한다.   다음은 위 알고리즘의 의사코드이다.   function binary_search_leftmost(A, n, T):     L := 0     R := n     while L &lt; R:         m := floor((L + R) / 2)         if A[m] &lt; T:             L := m + 1         else:             R := m     return L   Procedure for finding the rightmost element   다음은 중복된 값들 중 가장 오른쪽에 있는 값을 찾는 알고리즘이다.           배열의 맨 처음 인덱스를 가리키는 $L$을 $0$으로 배열의 맨 끝 인덱스를 가리키는 $R$을 $n$으로 놓는다.       while $L \\lt R$                     배열의 중간 인덱스 원소를 가리키는 $m$을 $\\lfloor\\frac{L + R}{2}\\rfloor$로 놓는다.                        $A_m \\gt T$이면 $R$을 $m$으로 놓는다.                        $A_m \\leq T$이면 $L$을 $m+1$로 놓는다.                   $R-1$을 반환한다.   위의 과정을 거치고, $R \\gt 0$ $and$ $A_{R-1} = T$ 이면 $A_{R-1}$은 $T$와 같은 가장 오른쪽에 있는 원소이다. $T$가 배열에 있다면 $R-1$은 $T$의 위치를 가리킨다. $n-L$은 $T$ 보다 작은 원소들의 개수를 의미한다.   다음은 위 알고리즘의 의사코드이다.   function binary_search_rightmost(A, n, T):     L := 0     R := n     while L &lt; R:         m := floor((L + R) / 2)         if A[m] &gt; T:             R := m         else:             L := m + 1     return R - 1   Approximate matches   이분 탐색은 배열에서 찾고자 하는 값의 위치를 알아낼 때도 쓸 수 있지만, 정렬된 배열에서 동작하는 알고리즘 특성 상 배열에 해당 값이 없어도 그 값과 대략적으로 일치하는 값의 위치를 알아내는 데에도 적용할 수 있다.      위 그림에서 보이듯이, 이분 탐색을 활용하면 Target value의 Rank, predcessor, successor,  nearest neighbor를 계산할 수 있다. 또한 특정 두 원소 사이에 몇 개의 원소가 있는지 찾는 범위 질의(Range queries)도 두 값의 $Rank$를 안다면 쉽게 계산 할 수 있다.           Rank queries: Target value 보다 작은 원소의 개수를 위에서 $Rank$라고 했었다. $Rank$는 위에서 알아본 procedure for finding the leftmost element를 이용하여 알아낼 수 있다. 이 procedure에서는 Target value 보다 작은 원소의 개수를 의미하는 $L$을 반환한다.            predcessor queries: 선행자 - predcessor는 바로 위에서 알아본 Rank queries에서 알아낼 수 있다. target value의 $rank$가 $r$이라고 하면 predcessor는 $r-1$이 된다.            successor queries: 후행자 - successor는 procedure for finding the rightmost element를 통해 알아낼 수 있다. 이 procedure가 반환한 값이 $r$이라면 successor는 $r+1$이 된다.            nearest neighbor: predcessor와 successor 중 더 가까운 쪽이 nearest neighbor가 된다.            Range queries: 두 값의 $Rank$를 안다면 첫번째 값 보다 크거나 같고 두번째 값보다 작은 원소의 개수는 두 $Rank$의 값의 차이이다. 이 개수는 범위의 끝점이 개수로 카운팅 되어야 하는가와 배열에서 해당 범위의 끝점이 target value와 일치 하는가에 따라 하나씩 증가 또는 감소할 수 있다.       Avoid integer overflow   C++이나 java와 같은 프로그래밍 언어에서는 Signed int가 4bytes의 공간을 차지한다. 이는 정수 값으로 -2147483648$(2^{31})$ ~ 2147483647$(2^{31}-1)$의 값을 표현 할 수 있다.   문제는 중간 원소의 위치를 계산하는 과정에서 $L + R$을 할 때 Interger의 범위를 넘을 수가 있다.      (L + R)/2 &gt; 2147483647   Integer overflow를 피하기 위해서는 다음의 트릭을 쓸 수 있다.      L + (R - L)/2 또는 R - (R - L)/2   R-L을 함으로써 overflow를 피하고 이를 반으로 나누면 양 끝점에서 부터 중간 원소 까지의 떨어진 거리 Offset이 된다. 이를 맨 처음 인덱스에 더하거나, 맨 끝 인덱스에서 빼면 중간 원소의 위치가 계산된다.   이 트릭은 중간 위치를 정확하게 계산하면서 Integer 범위 안의 매우 큰 값에 대해서도 두 정수를 더할 때 Integer overflow를 방지한다.   performance   비교 횟수와 관련해, 이분 탐색의 성능은 이분 탐색이 만드는 이진 트리에서의 프로시저의 실행을 통해 분석할 수 있다. 트리의 루트 원소는 배열에서의 중간 위치의 원소이다. 배열의 중간 위치 원소를 기준으로 왼쪽 반은 루트 노드의 왼쪽 자식 트리이고, 오른쪽 반은 루트 노드의 오른쪽 자식 트리이다. 그 밑의 자식 트리들도 이와 같이 만들어 진다. 루트 노드를 시작으로 찾고자 하는 값과의 대소 비교를 통해 어느쪽 자식을 탐색할지 정해진다.      위의 그림은 배열이 [20, 30, 40, 50, 80, 90, 100]일 때, 이분 검색이 그리는 트리를 나타내고 있다.  Target value가 40일 때, 그림처럼 루트 노드에서부터 비교를 시작해서 50, 30, 40순으로 탐색을 한다.      시간적인 측면에서 보면 이분 검색은 최악의 경우, 찾고자 하는 값이 배열에 있을 때, 비교 반복 횟수를 $\\lfloor log_2(n) + 1 \\rfloor$번 만든다. 최악의 경우 찾고자 하는 원소가 트리의 가장 깊은 곳에 있어 $\\lfloor log_2(n) + 1 \\rfloor$만큼의 비교 검색을 수행해야 하기 때문이다.   찾고자 하는 값이 배열에 없을 때도 최악의 경우가 있을 수 있는데, n이 2의 제곱 수 이거나 탐색이 트리의 가장 깊은 곳에서 끝나면 비교 반복 횟수는 $\\lfloor log_2(n) + 1 \\rfloor$이 된다. 그렇지 않고, 탐색이 두번째로 가장 깊은 곳에서 끝나면 비교 반복 횟수는 1 줄어든 $\\lfloor log_2(n)\\rfloor$이 된다.   평균적인 상황에서는 모든 원소가 동일하게 검색될 가능성이 있다고 가정하면, 이분 탐색은 $\\lfloor log_2(n) \\rfloor + 1 - (2^{\\lfloor log_2(n) + 1 \\rfloor} - \\lfloor log_2(n) -2 \\rfloor)/n$의 비교 반복 횟수를 만든다. 이 값은 n이 커질 수록 대략적으로 $\\lfloor log_2(n) - 1 \\rfloor$ 값에 근접해진다.   최선의 상황에서는 찾고자 하는 값이 배열의 중앙에 있어 한번 만에 찾는 경우이다. 이는 한번의 비교 반복 횟수 만으로 원소를 반환하는 경우이다. - $O(1)$   공간적인 측면에서 보면 이분 탐색을 반복적인 방법으로 구현했을 시, 약간의 포인터 혹은 변수들은 $O(1)$의 공간을 요구한다. 또한 처음 프로그램이 호출될 때 단일 콜 스택 $O(1)$의 공간을 요구한다. 반복적인 방법은 다른 변수나 추가적인 Recursive call을 만들지 않기 때문에 전체적으로 $O(1)$의 공간만을 요구한다.   재귀적인 방법으로 구현할 시, 탐색의 매 단계마다 재귀 호출을 하는데, 이는 지금의 함수 호출 정보를 담은 스택 프레임(Stack frame)을 콜 스택(Call stack)에 저장하고 다시 재귀 호출을 한다는 것을 의미한다. 이분 탐색의 레벨 깊이가 m일 때 최악의 경우 m개의 스택 프레임이 만들어지므로 공간 복잡도는 이 레벨 깊이에 비례한다. 원소의 개수가 $n$개일 때 최대 레벨은 $\\lfloor log_2n \\rfloor + 1$개가 되므로 전체적으로 최악 $O(log_2n$)의 공간복잡도가 된다.   Time &amp; Space Complexity           Worst Case performance: $O(log_2n)$            Average Case performance: $O(log_2n)$            Best Case performance: $O(1)$            Worst Case Space Complexity: Iterative: $O(1)$, Recursive: $O(log_2n)$ due to call stack       References      Binary Search   Binary Search   Binary Search - Space Complexity  ","categories": ["Algorithm"],
        "tags": ["Search Algorithm","Tree","binary Search"],
        "url": "http://localhost:4000/algorithm/binary-search/",
        "teaser":null},{
        "title": "삽입 정렬(Insertion Sort)",
        "excerpt":"삽입 정렬(Insertion sort)   삽입 정렬은 안정 정렬이자 제자리 정렬 알고리즘이다.   비교적 심플한 정렬 알고리즘으로서 일상 생활에서도 번호에 따라 카드를 정렬할 때 대부분 이 방법을 사용하곤 한다. 이 알고리즘에서는 각 원소를 정렬된 부분 배열(Sorted partial array)의 적절한 위치에 삽입한다.   삽입 정렬의 시간복잡도는 최악 기준 $O(n^2)$이므로 큰 리스트에는 비효율적이며, 유사한 시간복잡도를 갖는 선택 정렬이나 버블소트 보다는 성능이 좋지만, $O(nlogn)$의 시간복잡도를 같는 퀵 소트나 머지소트 같은 소팅 알고리즘 보다는 덜 효율적이다.   그러나, 삽입 정렬은 원소의 숫자가 적은 배열이나 리스트(원소의 개수가 10-20개 이하)에서는 일반적으로 퀵 소트나 머지소트 보다 효율적이여서, 실무에서는 다른 $O(nlongn)$의 시간복잡도를 갖는 소팅 알고리즘과 함께 정렬에 사용되어지고 있다. (ex. Tim sort)   안정 정렬과 제자리 정렬 이란?   안정 정렬: 정렬이 끝나면 같은 키값을 가진 원소들의 상대적인 순서가 변하지 않는 것을 의미.  안정 정렬 알고리즘으로는 삽입 정렬, 머지소트, 카운팅 소트 등이 있다.  제자리 정렬: 원소들의 개수에 비해서 충분히 무시할 만한 저장 공간만을 더 사용하는 정렬 알고리즘들을 의미.  예를 들어 삽입 정렬은 이미 주어진 원소들을 옮긴 뒤 적절한 위치에 원소를 삽입하는 연산을 반복하는데, 이 과정에서 원소들을 담는 공간 외에 추가로 사용될 수 있는 공간은 옮겨지는 원소가 저장되는 공간과 루프 변수 정도에 불과하다.   다음은 삽입 정렬의 몇 가지 장점이다.      다른 정렬 알고리즘에 비해 코드가 간단하고 구현이 쉽다. - Simple to implement   최악 기준 $O(n^2)$의 시간복잡도를 가지는 소팅 알고리즘(선택 정렬, 버블 소트)에 비해 비교적 효율적이다.   작은 데이터 셋에서 매우 효율적이다. - Efficient in small data set   적응적이다. 대체로 이미 정렬이 되어있는 데이터 셋에서 효율적이다. - Adaptive   같은 키값을 가진 원소들의 상대적인 순서를 바꾸지 않는다. - Stable   O(1)의 상수적인 추가 메모리 공간만이 필요하다. - In-place   실시간으로 원소를 하나씩 입력받으면서 정렬할 수 있다. - Online   알고리즘   다음은 삽입 정렬의 알고리즘이다. (오름차순, 원소 개수 2개 이상 기준)      먼저, 정렬될 리스트에서 두번째 원소를 선택한다.   1.번에서 선택한 원소를 기준으로 리스트의 앞의 원소들과 비교하여 기준에 따라 자기 자리를 찾아간다. - 1 pass   이를 매번 3…n-1번째 원소까지 선택하여 2.번을 반복한다.   이처럼, n개의 원소를 가진 리스트는 삽입 정렬로 n-1번의 패스를 거쳐 정렬이 된다.     삽입 정렬에서는 매 반복(1 pass or each repetition)마다 하나의 원소를 취해 부분 정렬된 정렬된 리스트에 그 원소가 속할 위치를 찾고 그 위치에 삽입을 한다. 이것을 n번째 원소까지 반복한다.   다음 그림은 매번의 반복마다 원소 $x$가 자리를 찾아 삽입되는 것을 보여준다.   아래 그림은 원소 $x$가 정렬이 수행되기 전이다.  원소 $x$는 아직 정렬되지 않은 데이터 셋에 있다.      정렬이 수행되고 나서는 아래 그림처럼 된다.  원소 $x$는 $&lt;=x$ 보다는 오른쪽 $&gt;x$ 보다는 왼쪽에 있어, 부분 정렬 결과에 속하게 된다.        다음은 삽입 정렬의 애니메이션이다.      예제   다음 예제를 보고 알고리즘을 이해해 보자.   다음과 같은 리스트가 있다고 하자.    List = [64 25 12 22 11] - index: 0...4  List = [정렬 완료 | 미정렬]  1 pass: 1번 인덱스 위치의 원소를 선택하여          앞의 원소들과 비교하여 적절한 위치에 삽입한다.  List = [25 64 | 12 22 11]  2 pass: 2번 인덱스 위치의 원소를 선택하여         앞의 원소들과 비교하여 적절한 위치에 삽입한다.  List = [12 25 64 | 22 11]  3 pass: 3번 인덱스 위치의 원소를 선택하여         앞의 원소들과 비교하여 적절한 위치에 삽입한다.  List = [12 22 25 64 | 11]  4 pass: 4번 인덱스 위치의 원소를 선택하여          앞의 원소들과 비교하여 적절한 위치에 삽입한다.  List = [11 12 22 25 64 | ]  n-1번의 pass로 리스트의 정렬이 완료되었다.  List = [11 12 22 25 64]   구현   다음은 삽입 정렬의 의사 코드이다.   i ← 1 while i &lt; length(A)     j ← i     while j &gt; 0 and A[j-1] &gt; A[j]         swap A[j] and A[j-1]         j ← j - 1     end while     i ← i + 1 end while   다음은 선택 정렬을 C++로 구현한 코드이다.   #include&lt;iostream&gt;   using namespace std;   int main ()   {       int i,j, k,temp;       int a[10] = { 10, 9, 7, 101, 23, 44, 12, 78, 34, 23};        cout&lt;&lt;\"\\nprinting sorted elements...\\n\";       for(k=1; k&lt;10; k++)        {           temp = a[k];           j= k-1;           while(j&gt;=0 &amp;&amp; temp &lt;= a[j])           {               a[j+1] = a[j];                j = j-1;           }           a[j+1] = temp;       }       for(i=0;i&lt;10;i++)       {           cout &lt;&lt;a[i]&lt;&lt;\"\\n\";       }   }    /* Output: Printing sorted elements . . .  7 9 10 12 23 23 34 44 78  101  */   다음은 선택 정렬을 java로 구현한 코드이다.   public class InsertionSort {       public static void main(String[] args) {           int[] a = {10, 9, 7, 101, 23, 44, 12, 78, 34, 23};           for(int k=1; k&lt;10; k++)            {               int temp = a[k];               int j= k-1;               while(j&gt;=0 &amp;&amp; temp &lt;= a[j])               {                   a[j+1] = a[j];                    j = j-1;               }               a[j+1] = temp;           }           System.out.println(\"printing sorted elements ...\");           for(int i=0;i&lt;10;i++)           {               System.out.println(a[i]);           }       } }   /* Output: Printing sorted elements . . .  7 9 10 12 23 23 34 44 78  101  */   시간복잡도 &amp; 공간복잡도   시간복잡도 분석   최악 기준 $1$…$n-1$개의 원소를 매 패스마다 비교한다.  n개의 원소가 있다면 $n-1$의 패스를 가진다.     비교의 측면에서 볼 때, 복잡도는 $O(n^2)$이다.   교환(Swap)도 위와 동일하다.   **Insertion sort**  Class\t            정렬 알고리즘  Data structure\t    배열  Worst-case          О(n^2) 비교 performance         О(n^2) 교환  Best-case           О(n^2) 비교 performance         О(n^2) 교환  Average             О(n^2) 비교 performance         О(n^2) 교환  Worst-case          O(n) 총 공간 space complexity    O(1) 추가 공간   References   Insertion sort - wikipedia  Insertion sort - javatpoint  ","categories": ["Algorithm"],
        "tags": ["Sort","Array"],
        "url": "http://localhost:4000/algorithm/insertion-sort/",
        "teaser":null},{
        "title": "퀵 소트(Quick Sort)",
        "excerpt":"Quick sort   퀵 소트(Quick sort)는 효율적인 비교기반 정렬 알고리즘으로 영국의 컴퓨터 과학자 Tony Hoare에 의해 1959 년에 개발되었다. 이 정렬 알고리즘은 현재 여러 프로그래밍 언어의 공식 정렬 라이브러리로 채택이 되었고, 실무에서도 많이 쓰이고 있다. 구현이 잘 되었을 때는 시간복잡도 $O(nlogn)$의 머지 소트나 힙 소트보다 두 배에서 세 배 정도 빨라질 수 있다.   퀵 소트는 분할 정복 알고리즘이다. 배열에서 원소를 두 부분의 서브 배열(sub-array)로 나눌 기준이 되는 피봇(pivot)을 선택하고 피봇 값 보다 크고 작음에 따라 원소를 두 부분의 서브 배열로 나눈다. 피봇을 기준으로 두 서브 배열이 부분 정렬이 되면, 서브 배열은 다시 재귀적(recursively)으로 위와 같이 정렬이 되어진다.   퀵 소트에서 원소가 피봇을 기준으로 두 부분의 서브 배열로 분할 되는 것은 약간의 변수와 같은 상수적 메모리 공간 $O(1)$만을 요구하는 제자리 정렬(in-place)의 속성을 만족 할 수 있다.   퀵 소트는 비교기반 정렬 알고리즘으로서 원소들이 크고 작음의 관계에 따라 상대적인 위치가 정해지게 된다. 대소 관계를 정의할 수 있는 형태는 이 비교기반에 따라 정렬이 가능해진다. 또한 현재 퀵 소트의 효율적인 알고리즘은 안정 정렬(Stable sort)이 아니다. 이 것은 같은 값을 가진 원소의 상대적인 위치가 정렬이 되고 난 후에는 변할 수도 있다는 것을 의미한다.   퀵 소트의 시간복잡도 분석에 따르면 평균적인 상황에서는(서브 배열의 크기를 25% or 75%로 나눌 수 있는 피봇을 원소로 선정) $n$개의 원소를 정렬할 때 성능이 $O(nlogn)$, 최악의 상황에서는(서브 배열이 매 단계마다 1크기 만큼 줄어드는 상황) 성능이 $O(n^2)$임을 보인다. 최악의 경우는 대부분 많이 드물며 세부 구현에 따라 복잡도가 다소 달라질 수 있다.   안정 정렬과 제자리 정렬 이란?   안정 정렬: 정렬이 끝나면 같은 키값을 가진 원소들의 상대적인 순서가 변하지 않는 것을 의미.  안정 정렬 알고리즘으로는 삽입 정렬, 머지 소트, 카운팅 소트 등이 있다.  제자리 정렬: 원소들의 개수에 비해서 충분히 무시할 만한 저장 공간만을 더 사용하는 정렬 알고리즘들을 의미.  예를 들어 삽입 정렬은 이미 주어진 원소들을 옮긴 뒤 적절한 위치에 원소를 삽입하는 연산을 반복하는데, 이 과정에서 원소들을 담는 공간 외에 추가로 사용될 수 있는 공간은 옮겨지는 원소가 저장되는 공간과 루프 변수 정도에 불과하다.   Algorithm   퀵 소트는 분할 정복 알고리즘으로 피봇 원소를 기준으로 입력 배열을 두개의 부분 배열로 나눈다.(하나는 피봇 보다 작거나 같은 원소들, 하나는 피봇보다 큰 원소들) 그리고 나뉜 두개의 부분 배열을 각각 재귀적으로 다시 분할 정복 정렬 한다.   다음은 퀵 소트의 알고리즘이다. (오름차순 기준)           배열에서 피봇(pivot)을 하나 선정한다.            피봇 값을 기준으로 배열의 원소들을 두 개의 부분 배열로 구분한다. 피봇보다 작은 원소는 피봇의 앞의 부분 배열에, 피봇보다 큰 원소는 피봇의 뒷 부분 배열에 놓는다. 구분이 완료되면 피봇을 배열의 최종적인 위치(원소들을 기준으로 절대적으로 위치해야만 하는 특정 위치)에 놓는다. 이 두 번째 스텝을 분할(Partition)이라고 한다.            피봇을 기준으로 나뉜 두 부분 배열에 대해 위의 1, 2번 연산들을 재귀적으로 적용한다.       Step by Step   실제 예를 들어 퀵 소트가 어떻게 동작 되는지 알아본다.   가정      원소를 오름차순으로 정렬한다.   피봇은 배열의 맨 마지막 원소로 선정한다. (피봇 선정 방법은 여러가지가 있다.)   배열의 크기가 1 이하에 대해서는 퀵 소트를 수행하지 않는다. (크기가 1인 배열은 이미 정렬이 되어있다.)     위 알고리즘의 2번째 스텝 분할(Partition)을 세분화하여 보면 다음과 같다.           배열의 맨 첫번째 원소를 가리키는(인덱스 0) Left 포인터를 둔다.            피봇 바로 앞의 원소를 가리키는(피봇 인덱스 -1) Right 포인터를 둔다.            Left 포인터가 Right 포인터보다 작거나 같을 동안 &amp; Left 포인터가 가리키는 원소가 피봇이 가리키는 원소보다 크거나 같을 때 까지 Left 포인터 위치를 1씩 증가시킨다.            Left 포인터가 Right 포인터보다 작거나 같을 동안 &amp; Right 포인터가 가리키는 원소가 피봇이 가리키는 원소보다 작을 때 까지 Right 포인터 위치를 1씩 감소시킨다.            Left &gt; Right가 아니라면 Left와 Right 포인터가 가리키는 원소를 서로 스왑한다.  그리고 3번으로 간다.            Left &gt; Right이라면 Left가 가리키는 원소와 피봇이 가리키는 원소를 서로 스왑 함으로써 피봇이 가리키던 원소의 최종적인 위치가 정해진다.         다음은 예제에 사용될 배열이다.      맨 마지막 원소를 피봇으로 선정한다.      Left 포인터는 배열의 0 번째 인덱스를 가리키고, Right 포인터는 피봇 바로 앞의 원소를 가리킨다.   위 설명에 따라 포인터를 움직인다.      Left &gt; Right가 아니므로 Left와 Right 포인터가 가리키는 원소를 서로 스왑한다.      알고리즘에 의해 Left와 Right 포인터를 움직인다.      Left &gt; Right가 아니므로 Left와 Right 포인터가 가리키는 원소를 서로 스왑한다.      알고리즘에 의해 Left와 Right 포인터를 움직인다.   Left &gt; Right가 되었다.      Left가 가리키는 원소와 피봇이 가리키는 원소를 서로 스왑한다.      피봇이 가리키는 원소의 최종적인 위치가 정해진 모습이다.   피봇을 기준으로 두개의 부분 배열로 분할이 되고, 왼쪽 부분 배열에는 피봇보다 작은 원소, 오른쪽 부분 배열에는 피봇보다 큰 원소들로 구성되었음을 볼 수 있다.      계속해서 왼쪽 부분 배열에 대해 재귀적으로 퀵 소트를 수행한다.   맨 마지막 원소를 피봇으로 선정한다.      Left 포인터는 배열의 0 번째 인덱스를 가리키고, Right 포인터는 피봇 바로 앞의 원소를 가리킨다.      알고리즘에 의해 포인터를 움직인다.   Left &gt; Right가 되었다.      Left가 가리키는 원소와 피봇이 가리키는 원소를 서로 스왑한다.      피봇이 가리키는 원소 1의 최종적인 위치가 정해진 모습이다.   원소 1을 기준으로 양 옆의 두 부분 배열은 모두 크기가 1 이하이므로 퀵소트를 수행하지 않는다.      원소 2의 최종적인 위치가 정해진 모습이다.      계속해서 3의 오른쪽 부분 배열 [6, 5, 4]가 재귀적으로 정렬이 된다.   맨 마지막 원소를 피봇으로 선정한다.      Left 포인터는 배열의 0 번째 인덱스를 가리키고, Right 포인터는 피봇 바로 앞의 원소를 가리킨다.      알고리즘에 의해 포인터를 움직인다.   Left &gt; Right가 되었다.      Left가 가리키는 원소와 피봇이 가리키는 원소를 서로 스왑한다.      피봇이 가리키는 원소 4의 최종적인 위치가 정해진 모습이다.   원소 4의 왼쪽 부분 배열은 크기가 1 이하이므로, 오른쪽 배열에 대해 재귀적으로 정렬을 수행한다.      맨 마지막 원소를 피봇으로 선정한다.      Left 포인터는 배열의 0 번째 인덱스를 가리키고, Right 포인터는 피봇 바로 앞의 원소를 가리킨다.      알고리즘에 의해 포인터를 움직인다.   Left &gt; Right가 되었다.      Left가 가리키는 원소와 피봇이 가리키는 원소를 서로 스왑한다.      피봇이 가리키는 원소 6의 최종적인 위치가 정해진 모습이다.   원소 6을 기준으로 양 옆의 두 부분 배열은 모두 크기가 1 이하이므로 퀵소트를 수행하지 않는다.      원소 5의 최종적인 위치가 정해진 모습이다.      이로써 퀵 소트를 적용한 정렬이 완료된 모습이다.      Selecting pivot - Median of three   위 방법에서는 피봇을 선정할 때 배열의 맨 마지막 원소로 하였는데, 이렇게 되면 입력으로 이미 정렬이 완료된 배열이 들어왔을 때 최악의 성능을 내게 된다. 이를 방지하기 위한 방법은 의외로 간단한데, 피벗을 선정할 때 임의의 인덱스를 선정하거나 배열의 중간 인덱스를 피봇으로 선정하는 것이다.   보다 효율적인 방법은 세지윅(Sedgewick)이 제안한 것으로 세 개의 중앙값(Median of three)이 있다. 이것은 파티션의 첫번째 값, 중간값, 마지막 값의 중앙값(Median)을 계산하여 이를 피봇으로 선정하는 것이다.   이 세 개의 중앙값 방법은 이미 정렬이 되어있는 배열에 대해서는 아주 적절하며, 임의의 원소를 피봇으로 선정하는 방법보다 피봇을 선정하는데 있어 보다 최적의 추정을 하는 것으로 알려져 있다.   다음은 세 개의 중앙값(Median of three)의 의사코드이다.   mid := (lo + hi) / 2 if A[mid] &lt; A[lo]     swap A[lo] with A[mid] if A[hi] &lt; A[lo]     swap A[lo] with A[hi] if A[mid] &lt; A[hi]     swap A[mid] with A[hi] pivot := A[hi]      lo : 첫번째 값   hi : 마지막 값   mid : 중간값   세 개의 값 중에서 제일 작은 값을 맨 앞(lo)으로 보낸다. 그리고 나머지 두개의 값을 비교해 중앙값을 계산한다. 이A[hi]중앙값을 피봇으로 사용한다.   임의의 피봇 선정 방법의 경우 $n$ 개의 요소를 정렬하는 데 필요한 예상 비교 수는 $1.386 nlogn$이다. 세 개의 중앙값은 예상 스왑 횟수가 3%정도 증가하는 대신 필요한 예상 비교 수를 1.188 n log n으로 낮춘다.   Implementation - java code   다음 코드는 퀵 소트를 자바로 구현한 것이다.   이 코드는 위 알고리즘을 적용하였으며, 피봇 선정은 세 개의 중앙값(Median of three)을 적용하였다.   /**  *  * This program is to sort an array using quick sort algorithm by ascending manner  * Applied Hoare partition scheme and median of three method as a pivot selecting  *  * This implementation is not stable sorting in which the relative position of  * two elements with the same value is preserved  *  * partition:  *  * Select a pivot using median of three method  * Arrange an element that less than or equal pivot key to the left side of pivot  * Arrange an element that greater than pivot key to the right side of pivot  *  * quickSort:  *  * recursively Sort left side and right side of pivot respectively  *  *  * Time Complexity:  *  * Average case performance: O(nlogn) where n is the number of item in an array  *  * Worst case performance: O(n^2)  *  * Best case performance: O(nlogn)  *  *  * Space complexity:  *  * Worst case space: O(n) auxiliary (naive)  *  * @author Gyeong  *  */  import java.util.Arrays;  public class QuickSort {      public static void quickSort(int arr[], int start, int end){         if (start &lt; end){             int pivot = partition(arr, start, end); // partition             quickSort(arr, start, pivot-1); // sort left side of pivot recursively             quickSort(arr, pivot+1, end); // sort right side of pivot recursively         }     }      public static int partition(int arr[], int start, int end){         int left = start;         int right = end-1;         // The median is placed at the end of the array. (end)         medianOfThree(arr, start, end);         // Pivot points to median         int pivot = end;          // Loop until left is less than or equal right         while (left &lt;= right){             // Searching for the item that is greater than pivot item             while (left &lt;= right &amp;&amp; arr[left] &lt;= arr[pivot])                 left++;             // Searching for the item that is less than or equal pivot item             while (left &lt;= right &amp;&amp; arr[pivot] &lt; arr[right])                 right--;             // when right is less than left, sub array was sorted             if (left &gt; right)                 break;              // Elements smaller than the pivot are placed on the left side of pivot             // Elements larger than the pivot are placed on the right side of pivot             swap(arr, left, right);              left++;             right--;         }          // Arrange pivot item to the proper position of the array         swap(arr, left, pivot);          // return pivot index         return left;     }      // Find the median of three numbers and place it at the end of the array     public static void medianOfThree(int arr[], int left, int right){         // The smallest of the three numbers is placed before two numbers          int mid = (left+right)/2;         if (arr[mid] &lt; arr[left])             swap(arr, mid, left);         if (arr[right] &lt; arr[left])             swap(arr, right, left);         // then compare the second and third numbers to determine the median         if (arr[mid] &lt; arr[right])             swap(arr, mid, right);     }      public static void swap(int arr[], int a, int b){         int temp = arr[a];         arr[a] = arr[b];         arr[b] = temp;     }      public static void main(String[] args) {         int arr[] = new int[]{2, 1, 4, 5, 7, 1, 1, 8, 9, 10, 11, 14, 15, 3, 2, 4};         System.out.println(\"Before sorting: \" + Arrays.toString(arr));         quickSort(arr, 0, arr.length-1);         System.out.print(\"After sorting: \" + Arrays.toString(arr));     } }    Output:  Before sorting: [2, 1, 4, 5, 7, 1, 1, 8, 9, 10, 11, 14, 15, 3, 2, 4] After sorting: [1, 1, 1, 2, 2, 3, 4, 4, 5, 7, 8, 9, 10, 11, 14, 15]   Time &amp; Space Complexity   Quick sort   The worst-case performance : $O(n^2)$   The best-case performance : $O(nlogn)$ or $O(n)$ (세 개의 분할, 동일 원소 값)   The average-case performance : $O(nlogn)$   The worst-case space requirement : $O(n)$의 보조 공간   References   Quick sort - wikipedia  Quick sort - codingeek  Quick sort - programiz  ","categories": ["Algorithm"],
        "tags": ["Sort","Array","Mathematics"],
        "url": "http://localhost:4000/algorithm/quick-sort/",
        "teaser":null},{
        "title": "선택 정렬(Selection Sort)",
        "excerpt":"선택 정렬   선택 정렬은 비교기반 제자리 정렬 알고리즘이다.  복잡도는 $O(n^2)$이므로 큰 리스트에는 비효율적이며, 유사한 삽입 정렬보다 성능이 더 떨어지는 것이 일반적이다. 선택 정렬은 단순함이 특징이며 특정한 상황(메모리가 제한적인 경우)에서는 더 복잡한 알고리즘보다 성능상 우위가 있다.   비교기반과 제자리 정렬 이란?   비교기반: 원소들을 정렬할 때 원소들의 순서에만 의존하는 것을 의미.  비교하는 원소들이 숫자거나, 문자열이거나, 심지어는 복잡한 객체에 대해서도 순서가 결정되어 있다면 적용할 수 있다.  제자리 정렬: 원소들의 개수에 비해서 충분히 무시할 만한 저장 공간만을 더 사용하는 정렬 알고리즘들을 의미.  예를 들어 삽입 정렬은 이미 주어진 원소들을 옮긴 뒤 적절한 위치에 원소를 삽입하는 연산을 반복하는데, 이 과정에서 원소들을 담는 공간 외에 추가로 사용될 수 있는 공간은 옮겨지는 원소가 저장되는 공간과 루프 변수 정도에 불과하다.   알고리즘   다음은 선택 정렬의 알고리즘이다. (오름차순)      먼저, 정렬될 리스트에서 가장 최소값을 찾는다.   1번에서 찾은 값을 정렬될 리스트의 맨 처음 위치한 값과 바꾼다. (1 pass)   맨 처음 위치를 제외한 나머지 리스트의 원소들에 대해서 이를 반복한다.   1 pass: 정렬이 되지않은 리스트에서 최소값을 선택해, 리스트의 적절한 위치에 넣는다.   이처럼, n개의 원소를 가진 리스트는 선택 정렬로 n-1번의 패스를 거쳐 정렬이 된다.   비교하는 것이 상수 시간에 이루어진다는 가정 아래, n개의 주어진 리스트를 위와 같은 방법으로 정렬하는 데에는 $O(n^2)$ 만큼의 시간이 걸린다.     다음은 선택 정렬의 애니메이션이다.     예제   다음 예제를 보고 알고리즘을 이해해 보자.   다음과 같은 리스트가 있다고 하자.    List = [64 25 12 22 11] - index: 0...4  List = [정렬 완료 | 미정렬]  1 pass: List[0...4]를 순회하여 최소값인 11을 찾고           이를 0번째 인덱스 위치의 64와 스왑한다.  List = [11 | 25 12 22 64]  2 pass: List[1...4]를 순회하여 최소값인 12을 찾고         이를 1번째 인덱스 위치의 25와 스왑한다.  List = [11 12 | 25 22 64]  3 pass: List[2...4]를 순회하여 최소값인 22을 찾고           이를 2번째 인덱스 위치의 25와 스왑한다.  List = [11 12 22 | 25 64]  4 pass: List[3...4]를 순회하여 최소값인 25을 찾고   이를 3번째 인덱스 위치의 25와 스왑한다.  List = [11 12 22 25 | 64]  n-1번의 pass로 리스트의 정렬이 완료되었다.   구현   다음은 선택 정렬을 C로 구현한 코드이다.   /* a[0] to a[aLength-1] is the array to sort */ int i,j; int aLength; // initialise to a's length  /* advance the position through the entire array */ /*   (could do i &lt; aLength-1 because single element is also min element) */ for (i = 0; i &lt; aLength-1; i++) {     /* find the min element in the unsorted a[i .. aLength-1] */      /* assume the min is the first element */     int jMin = i;     /* test against elements after i to find the smallest */     for (j = i+1; j &lt; aLength; j++)     {         /* if this element is less, then it is the new minimum */         if (a[j] &lt; a[jMin])         {             /* found new minimum; remember its index */             jMin = j;         }     }      if (jMin != i)      {         swap(a[i], a[jMin]);     } }   다음은 선택 정렬을 자바로 구현한 코드이다.   void selectionSort(int[] list) {     int indexMin, temp;      for (int i = 0; i &lt; list.length - 1; i++) {         // Lowest position         indexMin = i;         for (int j = i + 1; j &lt; list.length; j++) {             if (list[j] &lt; list[indexMin]) {                 indexMin = j;             }         }         // Swap         temp = list[indexMin];         list[indexMin] = list[i];         list[i] = temp;     } }   시간복잡도 &amp; 공간복잡도   시간복잡도 분석   $n$ $(n-1…1)$개의 원소를 매 패스마다 스캔하여 적절한 위치와 스왑한다.  n개의 원소가 있다면 $n-1$의 패스를 가진다.     등차수열에 의해,     비교의 측면에서 볼 때, 복잡도는 $O(n^2)$이다.   교환은 매 패스마다 한 번씩 일어난다. 즉, $n-1$번 복잡도는 $O(n)$  (마지막 원소는 이미 정렬되어 있다.)  **Selection sort**  Class\t            정렬 알고리즘  Data structure\t    배열  Worst-case          О(n^2) 비교 performance         О(n) 교환  Best-case           О(n^2) 비교 performance         О(n) 교환  Average             О(n^2) 비교 performance         О(n) 교환  Worst-case          O(1) 추가 공간 space complexity\t   References   Selection sort  Selection sort - GIF  ","categories": ["Algorithm"],
        "tags": ["Sort","Array"],
        "url": "http://localhost:4000/algorithm/selection-sort/",
        "teaser":null},{
        "title": "힙(Heap)-예정 포스트",
        "excerpt":" ","categories": ["Data Structure"],
        "tags": ["Array"],
        "url": "http://localhost:4000/data%20structure/heap/",
        "teaser":null},{
        "title": "크루스칼 알고리즘(Kruskal's Algorithm)",
        "excerpt":"들어가기 전에: 크루스칼 알고리즘에는 다음의 선행지식이 필요합니다.     스패닝 트리와 최소 스패닝 트리   Union Find - 서로소 집합     크루스칼 알고리즘(Kruskal’s Algorithm)   크루스칼 알고리즘(Kruskal’s Algorithm)은 연결 가중치 그래프(connected weighted graph)에서 최소 스패닝 트리(Minimum spanning tree)를 찾는 알고리즘이다. 알고리즘 과정에서 볼 때 그래프의 숲(forest)관점에서 여러개의 트리 중 서로 다른 집합의 두 트리를 연결하는 가능한 최소 가중치 간선(least possible weighted edge)을 찾는 작업을 수행한다.   그래프 이론에서는 그리디 알고리즘의 하나로서 알고리즘의 매 과정마다 최소 가중치 간선을 하나씩 선택해 추가하는 작업을 하면서 연결 가중치 그래프에서 최소 스패닝 트리를 찾는다. 그리하여 모든 정점을 포함하고 간선들의 서브셋인 스패닝 트리를 형성하게 하고, 생성된 스패닝 트리의 모든 간선의 가중치 합을 최소로 만든다.   그래프가 연결 그래프가 아니라면, 크루스칼 알고리즘은 최소 스패닝 숲(Minimum spanning forest)을 찾는다. (비 연결 그래프 내의 각 연결된 그래프에서의 최소 스패닝 트리)   알고리즘   크루스칼 알고리즘이 어떻게 동작하는지 살펴보자.   그래프 G가 주어졌다고 하자. (여기서는, 비 연결 그래프, 연결 그래프 구분하지 않는다.)           그래프 G의 모든 정점이 분리된 트리들의 집합인 숲(Forest) F를 생성한다.  여기서 숲은 분리된 트리들의 집합이다. (a set of trees)            그래프 G의 모든 간선을 포함하는 집합 S를 생성한다.            While 집합 S가 공집합이 아니고 &amp;&amp; 숲 F가 스패닝 트리가 아니면             집합 S에서 가장 최소 가중치의 간선을 하나 선택하고 S로 부터 삭제한다.       선택된 간선이 서로 다른 두 트리를 연결한다면 숲 F에 선택된 간선을 추가한다.    이것은 두 트리를 하나의 트리로 합치는 것이다.           알고리즘이 끝나고, 그래프 G가 비 연결 그래프 였다면 숲 F는 다중 컴포넌트(Trees)의 최소 스패닝 숲(MSF)을 형성하고, 그래프 G가 연결 그래프 였다면 숲 F는 단일 컴포넌트의 최소 스패닝 트리(MST)를 형성하게 된다.     다음은 크루스칼 알고리즘의 Animation이다.         파란색 간선은 현재 집합 S에서 선택한 간선   빨간색 간선은 집합 S에서 선택한 간선을 숲 F에 추가한 간선이다.   사이클을 형성하지 않으면서 간선들을 하나씩 추가하며 정점의 개수가 V라면 V-1개의 간선을 가진 최소 스패닝 트리를 구성하고 있는 모습이다.   의사코드   다음은 크루스칼 알고리즘의 의사코드이다. (Union Find 자료구조 사용)   Warning: 의사코드에는 Union Find - 서로소 집합 자료구조가 사용이 되므로 모른다면 반드시 알고와야 이해가 가능하다.   algorithm Kruskal(G) is     // 공집합으로 초기화     A := ∅     // 그래프 G의 모든 정점에 대해서     for each v ∈ G.V do         // 모든 정점들을 하나의 독립된 트리로 만들어 준다.         MAKE-SET(v)     // 그래프 G의 모든 간선들에 대해서 (간선들은 전부 오름차순으로 나열 되어있다.)     for each (u, v) in G.E ordered by weight(u, v), increasing do         // u와 v가 속한 집합이 서로 다르면 (서로 다른 집합의 트리라면)         if FIND-SET(u) ≠ FIND-SET(v) then            // u, v를 정점으로 하는 간선 (u, v)를 집합 A에 포함 시킨다.            A := A ∪ {(u, v)}            // 두 집합 u, v를 하나의 집합으로 합친다.            UNION(FIND-SET(u), FIND-SET(v))     return A   예제   예를 들어 크루스칼 알고리즘이 어떻게 동작하는지 하나씩 알아보자.   다음의 그래프에서 크루스칼 알고리즘을 적용해 최소 스패닝 트리를 찾아본다.   Graph G:        다음은 위 그래프의 가중치 간선들의 정보이다.   Edge\tAE   AD   AC   AB   BC   CD   DE Weight\t6    10   4    1    3    5    2   먼저, 간선들을 가중치에 따라 오름차순으로 정렬한다.   Edge\tAB   DE   BC   AC   CD   AE   AD Weight\t1    2    3    4    5    6    10    MST 구축을 시작한다.   위 간선 집합에서 가중치가 1로 제일 작은 최소 가중치 간선인 AB를 선택한다.  정점 A와 정점B는 서로 다른 집합이므로 간선 AB를 MST에 추가한다.   MST:    이번에는 AB를 선택했으니 그 다음으로 가중치가 작은 간선을 선택한다. 여기서는 가중치가 2인 간선 DE를 선택한다.   정점D와 정점E는 서로 다른 집합이므로 간선 DE를 MST에 추가한다.   MST:    계속해서, DE를 선택했으니 그 다음으로 가중치가 작은 간선을 선택한다. 여기서는 가중치가 3인 간선 BC를 선택한다.   정점B와 정점C는 서로 다른 집합이므로 간선 BC를 MST에 추가한다.   MST:    계속해서, BC를 선택했으니 그 다음으로 가중치가 작은 간선을 선택한다. 여기서는 가중치가 4인 간선 AC를 선택한다.   그러나 정점A와 정점C는 서로 이미 같은 집합에 속해 있다. 따라서 간선 AC를 추가하면 사이클이 생긴다는 것을 알 수 있다.   MST:    MST는 트리이므로 사이클이 없어야 한다는 것을 알고있다. 따라서, 간선 AC는 버린다.   계속해서, 간선 AC 다음으로 가중치가 작은 간선을 선택한다. 여기서는 가중치가 5인 간선 CD를 선택한다.   정점C와 정점D는 서로 다른 집합이므로 해당 정점들을 끝점으로 하는 간선을 추가해도 사이클을 형성하지 않는다. 간선 CD를 MST에 추가한다.   MST:    이로서 그래프 G의 모든 정점을 포함하고 4개(V-1)의 간선으로 구성되는 최소 스패닝 트리(MST)가 완성이 되었다.   위 트리의 모든 간선의 가중치 합은 11로서 그래프 G에서 나올 수 있는 스패닝 트리 중 가장 작은 가중치의 합을 가진 스패닝 트리가 된다.   구현   다음은 유니온 파인드 자료구조를 이용하여 크루스칼 알고리즘을 구현한 C++ 코드이다.   그래프는 위의 예제를 이용하였다.   예제 입력은 다음과 같다.      그래프의 정점의 수와 간선의 수를 입력한다.  nodes, edges   그 다음 그래프의 각 간선별 정보를 입력한다.  x, y, weight   결과 출력은 다음과 같다.      해당 그래프의 MST 간선 가중치 총합을 출력한다.  Minimum cost is ?   Kruskal’s algorithm - C++ Code   #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;utility&gt; #include &lt;algorithm&gt; using namespace std; const int MAX = 1e4 + 5; int id[MAX], ranks[MAX], nodes, edges;  // Edge array : weight, (u, v) pair &lt;long long, pair&lt;int, int&gt; &gt; p[MAX];  // Make set initialization void init() {     for(int i = 0;i &lt; MAX;++i) {         id[i] = i;         ranks[i] = 0;     } }  // Find with path compression int root(int x) {     if (id[x] == x)         return x;     else         // Recursion         return id[x] = root(id[x]); }  // union by rank void union1(int x, int y) {     int p = root(x);     int q = root(y);      if (p == q) // 루트가 같다면 수행하지 않는다.         return;      // p의 랭크가 q의 랭크보다 크다면     if (ranks[p] &gt;= ranks[q]) {         // q가 p의 밑으로 되게 합친다.         id[q] = id[p];     } else { // 위의 if문 과 반대         id[p] = id[q];     }     // 두 트리의 랭크가 같다면, 랭크를 1만큼 키운다.     if (ranks[p] == ranks[q])         ranks[p]+=1; }  // Find MST long long kruskal(pair&lt;long long, pair&lt;int, int&gt; &gt; p[]) {     int x, y;     int cnt = 0;     long long cost, minimumCost = 0;     for(int i = 0; i &lt; edges; ++i)     {         x = p[i].second.first;         y = p[i].second.second;         cost = p[i].first;         if(root(x) != root(y))         {             minimumCost += cost;             union1(x, y);             cnt++;         }         if (nodes-1 == cnt)             break;     }     return minimumCost; }  int main() {     int x, y;     long long weight, minimumCost;     init();     cout &lt;&lt;\"Enter Nodes and edges\";     cin &gt;&gt; nodes &gt;&gt; edges;     for(int i = 0;i &lt; edges;++i)     {         cout&lt;&lt;\"Enter the value of X, Y and edges\";         cin &gt;&gt; x &gt;&gt; y &gt;&gt; weight;         p[i] = make_pair(weight, make_pair(x, y));     }     sort(p, p + edges);     minimumCost = kruskal(p);     cout &lt;&lt;\"Minimum cost is \"&lt;&lt; minimumCost &lt;&lt; endl;     return 0; }   Output  Enter Nodes and edges 5 7 Enter the value of X, Y and edges 1 2 1 Enter the value of X, Y and edges 2 3 3 Enter the value of X, Y and edges 1 3 4 Enter the value of X, Y and edges 1 5 6 Enter the value of X, Y and edges 3 4 5 Enter the value of X, Y and edges 1 4 10 Enter the value of X, Y and edges 4 5 2 Minimum cost is 11   References   Kruskal’s Algorithm - java T point  Kruskal’s Algorithm  ","categories": ["Algorithm"],
        "tags": ["Graph","Union Find","Spanning Tree","Greedy"],
        "url": "http://localhost:4000/algorithm/kruskal/",
        "teaser":"http://localhost:4000/assets/images/kruskal-algorithm-solution3.png"},{
        "title": "카운팅 소트(Counting sort)",
        "excerpt":"카운팅 소트(Counting sort)   계수 정렬이라고도 하며, 점근적 복잡도 O(n+k)를 가지는 선형 정렬 알고리즘이다.      n: 정렬될 입력 배열의 원소 개수.   k: 정렬될 입력 배열의 가장 큰 키 값.   이 정렬 알고리즘은 특정한 조건하에 매우 효율적이며 같은 키값을 가진 원소에 대해 안정적이다. 버블소트와 머지소트와는 다르게, 이 알고리즘은 비교기반 정렬이 아니므로 원소 간에 비교를 하지 않고, 리스트의 O(1)의 삽입 및 조회 연산을 사용해 동작한다.   카운팅 소트는 정수의 특정 범위 사이에서 동작하며, 특정 키 값의 개체의 수를 세아려 이 정보를 보조 배열에 기록한다. 이 정보와 산술계산을 사용하여 각 키 값을 정렬될 결과 리스트의 특정 위치에 배치시킨다.   이 정렬 알고리즘은 정렬될 수의 범위가 정렬될 원소의 개수보다 심하게 크지 않을 때 적합하다.  그리고, 실행시간은 $O$(가장 큰 키 값 - 가장 작은 키 값)이 되므로 정렬될 수의 범위 또는 가장 큰 키 값(K)가 크지 않을 때 적합하다. 그렇지 않으면 보다 비효율적이다.   카운팅 소트는 안정 정렬에 속하고 제자리 정렬이 아니다. 이는 특정 원소의 키 값 개수를 추적할 추가적인 $O(K)$공간을 요구한게 된다.   안정 정렬과 제자리 정렬 이란?   안정 정렬: 정렬되기 전에 같은 키 값을 가진 원소들의 상대적인 위치나 순서는 정렬이 끝나도 변하지 않고 그대로 유지되는 것을 의미.  안정 정렬 알고리즘으로는 삽입 정렬, 머지소트, 카운팅 소트 등이 있다.  제자리 정렬: 원소들의 개수에 비해서 충분히 무시할 만한 저장 공간만을 더 사용하는 정렬 알고리즘들을 의미.  예를 들어 삽입 정렬은 이미 주어진 원소들을 옮긴 뒤 적절한 위치에 원소를 삽입하는 연산을 반복하는데, 이 과정에서 원소들을 담는 공간 외에 추가로 사용될 수 있는 공간은 옮겨지는 원소가 저장되는 공간과 루프 변수 정도에 불과하다.   카운팅 소트에 제약사항으로는 정수 같은 이산적인(Discrete)값들만 정렬 할 수 있고, 입력된 배열을 정렬하기 전에 가장 큰 값 K(범위)를 사전에 알고 있어야 한다.   의사 코드   다음은 카운팅 소트의 의사 코드이다.    // params A: 입력 배열, k: 가장 큰 키 값, n: 입력 배열 원소의 개수 CountingSort(A, n, k,)   // 특정 키 값의 원소 개수를 추적할 c[], 결과 배열 B[]를 준비한다.   c[k+1], B[n+1]    // C[]를 0으로 전부 초기화 한다.   for i = 0 to k do      c[i] = 0    //Complexity: O(n)   for j = 0 to n do     // 특정 키 값의 원소의 개수를 세아린다.     c[A[j]] = c[A[j]] + 1    ////Complexity: O(k)   for i = 1 to k do     // 결과 배열 B[]에 저장될 실제 인덱스 위치를 구한다.     c[i] = c[i] + c[i-1]    //Complexity: O(n)   for j = n-1 down to 0 do     //결과 배열을 구한다.     B[c[A[j]]] = A[j]     c[A[j]] = c[A[j]] - 1  end func   카운팅 소트 - 예제   예제로 카운팅 소트 알고리즘을 이해해 본다.           먼저 정렬 될 입력 배열이다.  그리고, 특정 키 값의 원소 개수를 저장할 배열 Count[k+1], 정렬 결과를 저장할 배열 Result[n+1]를 준비한다.  여기서 k는 입력 배열의 가장 큰 값인 11이고, n은 입력 배열의 원소 개수인 11이다.            입력 배열을 처음부터 끝까지 순회하면서 Count[]에 원소의 특정 키 값을 인덱스로 하여 개수를 기록한다. 그러면, 다음 그림과 같이 Count[] 배열이 완성된다.  위 그림에서 Count[2]은 1인데 이 의미는 실제 입력 배열의 2를 키 값으로 하는 원소가 1번 등장 했다는 것을 의미한다. 마찬가지로 Count[1]은 2인데 이 의미는 실제 입력 배열의 1을 키 값으로 하는 원소가 2번 등장 했다는 것을 의미한다. 이렇게 입력 배열의 특정 키 값을 Count[]의 인덱스로 하여 등장횟수 만큼 +1씩 증가시키며 기록해 준다.            Result[]에 저장될 특정 키 값의 실제 위치를 표현하기 위해 Count[]의 Prefix sum을 구한다.   위 그림의 Modified Count[]의 값은 Count[i] = Count[i] + Count[i-1]를 한 값이다.  이 값은 Result[] 배열에 저장될 원소들의 위치 인덱스 값을 계산하는 것이다.            입력 배열을 순회하면서 결과 배열을 계산한다.  앞에서 계산해둔 Count[]의 정보를 이용해서 결과 배열을 계산해보자.  인덱스 i는 0부터 시작하여, 입력 배열의 맨 처음 원소는 2이다. input[0] = 2  Count[input[i]] = Count[2] 이 값은 Result[]에 저장될 input[i]의 위치를 말해준다.  Count[]을 보자. 여기서 Count[input[i]] 값은 3이다. 즉, Result[Count[input[i]]] = input[i] -&gt; Result 배열 3번 인덱스 위치에는 2가 저장이 된다.  그 다음, 입력 배열에 같은 키 값을 가진 원소들이 2개 이상 있을 수 있는데(예제 입력 배열에서는 1이 2개) 결과 배열의 같은 인덱스에 저장되어 알고리즘의 오류를 피하기 위해 Count[input[j]] = Count[input[j]] - 1를 해야 한다. 이것은 같은 키 값을 가지는 원소들을 결과 배열에 저장할 때 한 칸씩 서로 다른 위치에 저장이 되게 한다. 앞에서 prefix sum을 계산한 이유가 이것이다.  이렇게 입력 배열 끝까지 순회하며 계산해주면 밑의 그림과 같이 Result배열이 완성된다.        실제 정렬된 배열은 Result[]의 [1번 인덱스 … n번 인덱스]이다. 위 그림에서 보이듯이 0번 인덱스가 거슬린다면 Result[]의 크기를 Result[n]로 초기화 하고 Result[Count[input[i]]] = input[i]에서 왼쪽 항에 -1을 넣어주자. =&gt; Result[Count[input[i]] -1] 이는 한칸 씩 앞으로 당겨 저장함을 의미한다.   자바 코드   다음은 카운팅 소트의 자바 코드이다.   import java.util.Arrays;  public class CountingSort {  \tpublic int[] sort(int[] A) { \t\tint[] Result = new int[A.length + 1]; \t\tint[] Count = new int[A.length + 1];  \t\tfor (int i = 0; i &lt; Count.length; i++) { \t\t\tCount[i] = 0; // put count for every element as 0 \t\t} \t\t// Count[] will store the counts of each integer in the given array \t\tfor (int i = 0; i &lt; A.length; i++) { \t\t\tint x = Count[A[i]]; \t\t\tx++; \t\t\tCount[A[i]] = x; \t\t} \t\t// • Update the Count[] so that each index will store the sum till \t\t// previous step. (Count[i]=Count[i] + Count[i-1]). \t\t// Now updated Count[] array will reflect the actual position of each \t\t// integer in Result[]. \t\tfor (int i = 1; i &lt; Count.length; i++) { \t\t\tCount[i] = Count[i] + Count[i - 1]; \t\t} \t\t// • Now navigate the input array taking one element at a time, \t\t// Count[input[i]] will tell you the index position of input[i] in \t\t// Result[]. When you do that, decrease the count in Count[input[i]] by \t\t// 1. \t\tfor (int i = A.length - 1; i &gt;= 0; i--) { \t\t\tint x = Count[A[i]]; \t\t\tResult[x] = A[i]; \t\t\tx--; \t\t\tCount[A[i]] = x; \t\t} \t\treturn Result;  \t}  \tpublic static void main(String[] args) { \t\t// TODO Auto-generated method stub \t\tint input[] = { 2, 1, 4, 5, 7, 1, 1, 8, 9, 10, 11, 14, 15, 3, 2, 4 }; \t\tSystem.out.println(\"Orginal Array: \" + Arrays.toString(input)); \t\tCountingSort c = new CountingSort(); \t\tint[] B = c.sort(input); \t\tSystem.out.println(\"Sorted Array: \" + Arrays.toString(B)); \t} }    Output: Orginal Array: [2, 1, 4, 5, 7, 1, 1, 8, 9, 10, 11, 14, 15, 3, 2, 4] Sorted Array: [0, 1, 1, 1, 2, 2, 3, 4, 4, 5, 7, 8, 9, 10, 11, 14, 15]   시간복잡도 &amp; 공간 복잡도   이 정렬 알고리즘은 재귀나 서브루틴(함수)콜을 사용하지 않고 1차원의 다소 심플한 for loop만 되어 있으므로 복잡도 분석이 꽤 간단한 편이다. Count[]의 prefix sum 계산이 최대 k+1번 수행되므로 O(k), Count[]의 계산과 Result[]의 계산은 n번 계산되므로 O(n)이다.   따라서 이 알고리즘의 전체 시간복잡도는 이 두개의 합인 O(n+k)가 된다.   **Counting sort**  Class\t            정렬 알고리즘  Data structure\t    배열  Worst-case          О(n+k)  performance        Worst-case          О(n+k)  space complexity\t  * n은 원소의 개수, k는 음수가 아닌 키 값의 범위   참고하면 좋은 자료   카운팅 소트를 시각화한 애니메이션으로 참고하면 좋다.   Counting Sort visualization   Reference   Counting sort - wikipedia  Counting sort - codingeek  Counting sort - algorithms.tutorialhorizon  ","categories": ["Algorithm"],
        "tags": ["Sort","Array"],
        "url": "http://localhost:4000/algorithm/counting-sort/",
        "teaser":null},{
        "title": "깊이우선탐색(Depth First Search, DFS)",
        "excerpt":"깊이우선탐색(Depth First Search, DFS)   깊이우선탐색(DFS)은 트리나 그래프 혹은 다른 구조 상에서 탐색을 위한 알고리즘이다. 이 알고리즘은 루트 노드를 시작으로(그래프의 경우에는 임의의 노드를 루트 노드로 정하게 된다.) 탐색을 하다가 더 이상 갈 수 없어 백트랙 하기 전까지 가능한 한 가지를 따라 깊게 멀리 탐색한다.   시간 및 공간 복잡도 분석은 많은 응용분야에 따라 다른데, 이론적인 컴퓨터 과학 분야에서 DFS는 전체 그래프를 탐색하는데 사용되기 때문에 수행 시간은 선형인 $O(|V|+|E| )$가 된다. 공간 복잡도면을 보면 DFS는 경로상의 현재 탐색하고 있는 정점과 경로상 이미 방문한 정점들의 스택을 저장하고 있기 때문에 최악 $O(|V|)$의 공간을 요구한다. ($|V|$는 정점의 수, $|E|$는 간선의 수이다.)   깊이우선탐색(DFS)의 시간 및 공간 상한은 너비우선탐색(BFS)과 같기 때문에, 탐색 알고리즘의 사용면에서 두 알고리즘이 만드는 정점 방문 순서의 다름과 그 복잡성을 생각해 어느 알고리즘을 사용해야 할지 생각해야한다.   예제   다음 그래프를 보고 깊이우선탐색이 어떤 것인지 이해해보자.      가정      현재 방문하고 있는 정점에서 인접한 왼쪽 간선을 오른쪽 간선보다 먼저 선택한다고 가정한다.   탐색 알고리즘은 현재 정점의 이전 정점의 방문을 기억한다고 가정한다.   정점들의 방문은 중복되지 않는다고 가정한다.     먼저 A를 루트 노드로 하여 탐색을 시작한다.           A를 방문하고 위의 가정에 따라 인접 정점 C, E를 탐색하기 전에 B를 먼저 탐색한다.            B를 방문하고 F를 탐색하기 전에 D를 먼저 탐색한다.            D를 방문하고 D의 인접한 정점은 B이지만 이미 방문하였기에 더 이상 탐색할 곳이 없으므로, 이전 정점 B로 백트래킹 한다.            정점 B에서 F를 탐색한다.            F를 방문하고 아직 탐색하지 않은 인접 정점인 E를 탐색한다.            E를 방문하고 나면 인접 정점들은 모두 방문한 상태이므로 이전 정점 F로 백트래킹 한다.            F에서도 인접 정점들은 모두 방문한 상태이므로 이전 정점 B로 백트래킹 한다.            B에서도 인접 정점들은 모두 방문한 상태이므로 이전 정점 A로 백트래킹 한다.            A에서 인접한 정점 중 아직 탐색하지 않은 곳은 C이므로 C를 탐색한다.            C를 방문하고 아직 탐색하지 않은 곳인 G를 탐색한다.            G를 방문한다.            G에서 인접 정점들은 모두 방문한 상태이므로 이전 정점 C로 백트래킹 한다.            C에서 인접 정점들은 모두 방문한 상태이므로 이전 정점 A로 백트래킹 한다.            A에서 모든 인접 정점이 방문 완료 되었으므로 DFS는 완료되었다.       이로서, DFS에 의한 위 그래프의 정점들 방문 순서는 : A, B, D, F, E, C, G 이다.   의사코드   깊이우선탐색(DFS)을 하는 두가지 방법을 알아본다.   서브루틴을 이용한 재귀적 방법   Input: 그래프 G, 그래프 G의 정점 v  Output: v로 부터 탐색 가능한 모든 정점들   다음은 서브루틴을 이용한 재귀적 방법의 의사코드이다.   procedure DFS(G, v) is     label v as discovered     for all directed edges from v to w that are in G.adjacentEdges(v) do         if vertex w is not labeled as discovered then             recursively call DFS(G, w)   한 구문씩 보자.      label v as discovered: 현재 정점 v를 탐색완료 되었다는 것을 표시한다. (중복 방문 방지를 위해)   for all directed edges from v to w that are in G.adjacentEdges(v) do: 그래프 G의 모든 인접한 간선 (v, w)에 대해서   if vertex w is not labeled as discovered then: 만약 w가 탐색되지 않았으면   recursively call DFS(G, w): 재귀적으로 w를 탐색한다.  이것은 현재 정점 v의 인접 정점 w를 매개변수로 하여 같은 서브루틴으로 다음 정점을 탐색하는 것을 의미한다.   이 방법의 최악 공간 복잡도는 $O(|V|)$가 된다.  현재 탐색하고 있는 경로의 정점들과 이미 방문한 정점들의 스택을 저장하고 있기 때문이다.   스택을 이용한 반복적인 방법   Input: 그래프 G, 그래프 G의 정점 v  Output: v로 부터 탐색 가능한 모든 정점들   다음은 스택을 이용한 반복적인 방법의 의사코드이다.  procedure DFS-iterative(G, v) is     let S be a stack     S.push(v)     while S is not empty do         v = S.pop()         if v is not labeled as discovered then             label v as discovered             for all edges from v to w in G.adjacentEdges(v) do                  S.push(w)   한 구문씩 보자.      let S be a stack: S라는 스택을 하나 생성한다. 현재 방문 정점의 인접 정점들을 담는다.   S.push(v): 탐색하고자 하는 시작 정점 v를 스택에 push한다.   while S is not empty do: 스택이 빈 공간이 아닐 때 까지 아래 연산들을 반복한다. v = S.pop(): 현재 탐색 하고 있는 정점을 v에 넣는다.   if v is not labeled as discovered then label v as discovered: 만약 v가 탐색되지 않았으면, 탐색 완료 표시를 한다.   for all edges from v to w in G.adjacentEdges(v) do                S.push(w): 현재 정점 v의 모든 인접한 정점 w를 스택에 넣는다.   이 방법의 최악 공간 복잡도는 $O(|E|)$가 된다.  재귀적인 방법과는 달리, 어떤 해당 정점에서 인접 정점들의 정보를 모두 스택에 저장하기 때문에, 최악의 설정으로 하나의 정점이 다른 모든 정점과 직접 연결되어 있다면 공간 복잡도는 $O(|E|)$가 된다.   두 가지 접근의 차이점   위에서 살펴본 두 가지 DFS의 탐색 방법은 각 정점들의 이웃방문 순서가 서로 반대인데, 재귀적인 방법에서는 인접리스트 방식에서 정점 v의 첫번째 이웃을 먼저 방문하는 반면, 스택을 이용한 반복적인 방법에서는 정점 v의 이웃들이 스택에 역순으로 저장되기 때문에 인접 리스트 관점에서 정점 v의 첫번째 이웃은 제일 마지막(first in last out)에 탐색이 된다.   위 그래프를 예로 들면 재귀적인 방법으로의 방문 순서는 A, B, D, F, E, C, G가 되고, 스택을 이용한 반복적 접근에서는 A, E, F, B, D, C, G가 된다.   응용   DFS 탐색 알고리즘은 많은 곳에서 쓰이는데 예는 다음과 같다.      미로 찾기   그래프의 위상 정렬   모든 경우 다 해보기(전체 탐색)   연결 구성 요소 찾기   이분 그래프   링크   프로그래밍 언어로의 구현은 다음 글을 참고하면 좋다.      DFS Implementation Using Recursion   DFS Implementation Using Stack   시간 복잡도 &amp; 공간 복잡도      시간 복잡도: 최악 $O(|V|+|E| )$ (중복 방문 제외)   공간 복잡도: 최악 $O(|V|)$ (알고리즘이 재귀적 일 때)   References      Wikipedia   JavaTpoint   Algorithms  ","categories": ["Algorithm"],
        "tags": ["Search Algorithm","DFS","Stack","Recursive","Graph","Tree","Back Tracking"],
        "url": "http://localhost:4000/algorithm/DFS/",
        "teaser":null},{
        "title": "깊이우선탐색(DFS) 구현 - Iterative using stack",
        "excerpt":"깊이우선탐색 글 참고하기      Depth First Search   그래프의 구현 글 참고하기      Graph     이번 글에서는 스택을 사용한 DFS를 이해하고 구현해 봅니다.   깊이우선탐색(Depth First Search, DFS)   깊이우선탐색(DFS)은 트리나 그래프 혹은 다른 구조 상에서 탐색을 위한 알고리즘이다. 이 알고리즘은 루트 노드를 시작으로(그래프의 경우에는 임의의 노드를 루트 노드로 정하게 된다.) 탐색을 하다가 더 이상 갈 수 없어 백트랙 하기 전까지 가능한 한 가지를 따라 깊게 멀리 탐색한다.   시간 및 공간 복잡도 분석은 많은 응용분야에 따라 다른데, 이론적인 컴퓨터 과학 분야에서 DFS는 전체 그래프를 탐색하는데 사용되기 때문에 수행 시간은 선형인 $O(|V|+|E| )$가 된다. 공간 복잡도면을 보면 스택을 사용한 DFS는 최악 $O(|E|)$의 복잡도를 가진다. 재귀적인 방법과는 달리, 해당 정점에서 방문하지 않은 인접 정점들의 정보를 모두 스택에 저장하기 때문에, 최악 $O(|E|)$가 된다. ($|V|$는 정점의 수, $|E|$는 간선의 수이다.)   알고리즘   우선, 방문할 인접 정점들을 저장할 Stack과 정점들의 방문 표시를 할 visited[] 배열을 선언한다.   스택을 이용한 DFS 알고리즘은 다음과 같은 순서로 실행된다.           탐색을 시작할 스타팅 노드를 스택에 넣는다.            스택이 빈 공간이 아닐 때 까지 다음을 실행한다.            스택에서 정점 하나를 꺼내 방문하지 않았으면 방문 표시를 하고 그 정점에 인접한 모든 정점을 스택에 넣는다.(방문 하지 않은 정점들만)            2번으로 간다.       예제   예를 들어 DFS 알고리즘을 이해 해보자.   방문 우선순위: 현재 정점과 인접한 정점이 여러개면 번호가 [작은 순서대로] 방문한다.   아래와 같은 정점 5개로 이루어진 비방향 그래프로 DFS를 시작한다.   탐색은 0번 정점부터 시작한다고 가정한다.      위 알고리즘에 따라 탐색을 시작할 0번 정점을 스택에 넣는다.      스택에서 가장 위에있는 원소를 하나 꺼낸다. (여기서는 제일 왼쪽 칸이 top이다.) 0번 정점을 방문표시 하고 0번 정점과 인접한 정점들 중에서 방문하지 않는 정점들을 모두 스택에 넣는다.   0번 정점과 1, 2, 3번 정점이 인접해 있다. 위의 방문 우선순위에 따라 인접한 정점이 여러개면 번호가 [작은 순서대로] 방문해야 하므로 3, 2, 1순으로 스택에 삽입한다. (후입 선출)      계속해서, 스택에서 가장 위에있는 1번 정점을 꺼낸다. 1번 정점을 방문표시 하고 1번 정점과 인접한 정점들 중에서 방문하지 않는 정점들을 모두 스택에 넣는다.  여기서는 2번 정점을 스택에 삽입한다.      그 다음, 스택에서 가장 위에있는 2번 정점을 꺼낸다. 2번 정점을 방문표시 하고 2번 정점과 인접한 정점들 중에서 방문하지 않는 정점들을 모두 스택에 넣는다.  여기서는 4번 정점을 스택에 삽입한다.      그 다음, 스택에서 가장 위에있는 4번 정점을 꺼낸다. 4번 정점을 방문표시 하고 4번 정점과 인접한 정점들 중에서 방문하지 않는 정점들을 모두 스택에 넣는다.  4번 정점과 인접한 정점 중에서는 방문하지 않은 정점들이 없으므로 다음 스탭으로 간다.      그 다음, 스택에서 가장 위에있는 3번 정점을 꺼낸다. 3번 정점을 방문표시 하고 3번 정점과 인접한 정점들 중에서 방문하지 않는 정점들을 모두 스택에 넣는다.  3번 정점과 인접한 정점 중에서는 방문하지 않은 정점들이 없으므로 다음 스탭으로 간다.      알고리즘 2번에 의해 스택이 모두 비었으니 알고리즘을 끝낸다.   스택을 이용한 DFS의 방문순서는 0 1 2 4 3 순이다.   구현   의사코드   스택을 이용한 반복적인 방법   Input: 그래프 G, 그래프 G의 정점 v  Output: v로 부터 탐색 가능한 모든 정점들   procedure DFS-iterative(G, v) is     let S be a stack     S.push(v)     while S is not empty do         v = S.pop()         if v is not labeled as discovered then             label v as discovered             for all edges from v to w in G.adjacentEdges(v) do                 if w is not labeled as discovered then                    S.push(w)   한 구문씩 보자.      let S be a stack: S라는 스택을 하나 생성한다. 현재 방문 정점의 인접 정점들을 담는다.   S.push(v): 탐색하고자 하는 시작 정점 v를 스택에 push한다.   while S is not empty do: 스택이 빈 공간이 아닐 때 까지 아래 연산들을 반복한다.            v = S.pop():현재 탐색 하고 있는 정점을 v에 넣는다.       if v is not labeled as discovered then label v as discovered: 만약 v가 탐색되지 않았으면, 탐색 완료 표시를 한다.       for all edges from v to w in G.adjacentEdges(v) do if w is not labeled as discovered then S.push(w): 현재 정점 v의 모든 인접한 정점 w를 스택에 넣는다. (w가 방문되지 않았으면)             자바 프로그램   위 의사코드를 바탕으로 스택을 이용한 DFS 알고리즘 자바 코드는 다음과 같다.   public void DFS(int start){     boolean[] visited = new boolean[vertex];     Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;();     stack.push(start);     while (!stack.isEmpty()){         int v = stack.pop();         if (!visited[v]){             visited[v] = true;             for (int i = 0; i &lt; list[v].size(); i++){                 int dest = list[v].get(i);                 if (!visited[dest])                     stack.push(dest);             }         }     } }   위의 코드 설명   boolean[] visited = new boolean[vertex]; Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;();   방문할 인접 정점들을 저장할 Stack과 정점들의 방문 표시를 할 visited[] 배열을 선언한다.   stack.push(start);  탐색을 시작할 스타팅 노드를 스택에 넣는다.   while (!stack.isEmpty()){}  스택이 빈 공간이 아닐 때 까지 다음을 실행한다.   int v = stack.pop(); if (!visited[v]){   visited[v] = true;     for (int i = 0; i &lt; list[v].size(); i++){       int dest = list[v].get(i);         if (!visited[dest])             stack.push(dest);     } }  스택에서 정점 하나를 꺼내 방문하지 않았으면 방문 표시를 하고 그 정점에 인접한 모든 정점을 스택에 넣는다.(방문 하지 않은 정점들만)     위의 예제 그래프를 사용한 전체 코드는 다음과 같다.   DFSIterative.java  import java.util.LinkedList; import java.util.Stack;  public class DFSIterative {      static class Graph{         int vertex;         LinkedList&lt;Integer&gt; list[];          public Graph(int vertex) {             this.vertex = vertex;             list = new LinkedList[vertex];             for (int i = 0; i &lt;vertex ; i++) {                 list[i] = new LinkedList&lt;&gt;();             }         }          public void addEdge(int source, int destination){             list[source].addFirst(destination);             list[destination].addFirst(source);         }          public void DFS(int start){             System.out.print(\"Depth First Traversal: \");             boolean[] visited = new boolean[vertex];             Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;();             stack.push(start);             while (!stack.isEmpty()){                 int v = stack.pop();                 if (!visited[v]){                     System.out.print(v + \" \");                     visited[v] = true;                     for (int i = 0; i &lt; list[v].size(); i++){                         int dest = list[v].get(i);                         if (!visited[dest])                             stack.push(dest);                     }                 }             }         }          public void printGraph(){             for (int i = 0; i &lt;vertex ; i++) {                 LinkedList&lt;Integer&gt; nodeList = list[i];                 if(nodeList.isEmpty()==false) {                     System.out.print(\"source = \" + i + \" is connected to nodes: \");                     for (int j = 0; j &lt; nodeList.size(); j++) {                         System.out.print(\" \" + nodeList.get(j));                     }                 }                 System.out.println();             }         }     }      public static void main(String[] args) {         Graph graph = new Graph(6);         graph.addEdge(0, 1);         graph.addEdge(0, 2);         graph.addEdge(1, 2);         graph.addEdge(1, 3);         graph.addEdge(3, 4);         graph.addEdge(2, 3);         graph.addEdge(4, 0);         graph.addEdge(4, 1);         graph.addEdge(4, 5);         graph.printGraph();         graph.DFS(0);     } }    Output:  source = 0 is connected to nodes:  3 2 1 source = 1 is connected to nodes:  2 0 source = 2 is connected to nodes:  4 1 0 source = 3 is connected to nodes:  0 source = 4 is connected to nodes:  2 Depth First Traversal: 0 1 2 4 3  Process finished with exit code 0   References      Wikipedia   JavaTpoint   Algorithms  ","categories": ["Algorithm"],
        "tags": ["Search Algorithm","DFS","Stack","Recursive","Graph","Tree","Back Tracking"],
        "url": "http://localhost:4000/algorithm/DFS-Implementation-stack/",
        "teaser":null},{
        "title": "깊이우선탐색(DFS) 구현 - Recursive",
        "excerpt":"깊이우선탐색 글 참고하기      Depth First Search   그래프의 구현 글 참고하기      Graph     이번 글에서는 재귀 함수를 사용한 DFS를 이해하고 구현해 봅니다.   깊이우선탐색(Depth First Search, DFS)   깊이우선탐색(DFS)은 트리나 그래프 혹은 다른 구조 상에서 탐색을 위한 알고리즘이다. 이 알고리즘은 루트 노드를 시작으로(그래프의 경우에는 임의의 노드를 루트 노드로 정하게 된다.) 탐색을 하다가 더 이상 갈 수 없어 백트랙 하기 전까지 가능한 한 가지를 따라 깊게 멀리 탐색한다.   시간 및 공간 복잡도 분석은 많은 응용분야에 따라 다른데, 이론적인 컴퓨터 과학 분야에서 DFS는 전체 그래프를 탐색하는데 사용되기 때문에 수행 시간은 선형인 $O(|V|+|E| )$가 된다. 공간 복잡도면을 보면 DFS는 경로상의 현재 탐색하고 있는 정점과 경로상 이미 방문한 정점들의 콜 스택 정보를 저장하고 있기 때문에 최악 $O(|V|)$의 공간을 요구한다. ($|V|$는 정점의 수, $|E|$는 간선의 수이다.)   알고리즘   재귀 함수를 이용한 DFS 알고리즘은 다음과 같은 순서로 실행된다.           탐색을 시작할 스타팅 노드를 매개변수로 하여 DFS 함수를 실행한다.            현재 탐색 정점을 방문 표시한다.            현재 정점에 인접한 모든 정점 중에서 방문하지 않은 정점을 재귀적으로 탐색한다.  현재 정점에 인접한 모든 정점을 방문 하였으면 이전 정점으로 백트래킹 한다.            2번으로 간다.       예제   예를 들어 DFS 알고리즘을 이해 해보자.   방문 우선순위: 현재 정점과 인접한 정점이 여러개면 번호가 [작은 순서대로] 방문한다.   아래와 같은 정점 5개로 이루어진 비방향 그래프 G로 DFS를 시작한다.   DFS(G, 정점 번호)는 그래프 G와 정점 번호를 매개변수로 하여 DFS함수를 재귀적으로 호출하는 것을 의미한다.   탐색은 0번 정점부터 시작한다고 가정한다.      DFS(G, 0) 실행   0번 정점을 방문한다.  0번 정점의 인접 정점들 중 탐색하지 않은 정점들을 탐색한다.  1번 정점을 재귀적으로 탐색한다.      DFS(G, 1) 실행   1번 정점을 방문한다.  1번 정점의 인접 정점들 중 탐색하지 않은 정점들을 탐색한다.  2번 정점을 재귀적으로 탐색한다.      DFS(G, 2) 실행   2번 정점을 방문한다.  2번 정점의 인접 정점들 중 탐색하지 않은 정점들을 탐색한다.  4번 정점을 재귀적으로 탐색한다.      DFS(G, 4) 실행   4번 정점을 방문한다.  4번 정점의 인접 정점들 중 탐색하지 않은 정점들을 탐색한다.  인접 정점들 중 방문 하지 않은 정점이 없으므로 이전 정점으로 백트랙 한다.      DFS(G, 2) 백트랙   2번 정점의 인접 정점들 중 탐색하지 않은 정점들을 탐색한다.  인접 정점들 중 방문 하지 않은 정점이 없으므로 이전 정점으로 백트랙 한다.      DFS(G, 1) 백트랙   1번 정점의 인접 정점들 중 탐색하지 않은 정점들을 탐색한다.  인접 정점들 중 방문 하지 않은 정점이 없으므로 이전 정점으로 백트랙 한다.      DFS(G, 0) 백트랙   0번 정점의 인접 정점들 중 탐색하지 않은 정점들을 탐색한다.  3번 정점을 재귀적으로 탐색한다.      DFS(G, 3) 실행   3번 정점을 방문한다.  3번 정점의 인접 정점들 중 탐색하지 않은 정점들을 탐색한다.  인접 정점들 중 방문 하지 않은 정점이 없으므로 이전 정점으로 백트랙 한다.      DFS(G, 0) 백트랙   1번 정점의 인접 정점들 중 탐색하지 않은 정점들을 탐색한다.  인접 정점들 중 방문 하지 않은 정점이 없으므로 DFS(G, 0)이 콜 스택에서 사라진다.      콜스택이 비었으므로 알고리즘을 끝낸다.      재귀 함수를 이용한 DFS의 방문순서는 0 1 2 4 3 순이다.   구현   의사코드   다음은 서브루틴을 이용한 재귀적 방법의 의사코드이다.   Input: 그래프 G, 그래프 G의 정점 v  Output: v로 부터 탐색 가능한 모든 정점들   procedure DFS(G, v) is     label v as discovered     for all directed edges from v to w that are in G.adjacentEdges(v) do         if vertex w is not labeled as discovered then             recursively call DFS(G, w)   한 구문씩 보자.      label v as discovered: 현재 정점 v를 탐색완료 되었다는 것을 표시한다. (중복 방문 방지를 위해)   for all directed edges from v to w that are in G.adjacentEdges(v) do: 그래프 G의 모든 인접한 간선 (v, w)에 대해서            if vertex w is not labeled as discovered then: 만약 w가 탐색되지 않았으면       recursively call DFS(G, w): 재귀적으로 w를 탐색한다.  이것은 현재 정점 v의 인접 정점 w를 매개변수로 하여 같은 서브루틴으로 다음 정점을 탐색하는 것을 의미한다.             자바 프로그램   위 의사코드를 바탕으로 재귀 함수를 이용한 DFS 알고리즘 자바 코드는 다음과 같다.   public void DFSRecursion(int startVertex){     boolean [] visited = new boolean[vertices];     dfs(startVertex, visited); }  public void dfs(int start, boolean [] visited){     visited[start] = true;     for (int i = 0; i &lt;adjList[start].size() ; i++) {         int destination = adjList[start].get(i);         if(!visited[destination])             dfs(destination,visited);     } }   위의 코드 설명   public void DFSRecursion(int startVertex){     boolean [] visited = new boolean[vertices];     dfs(startVertex, visited); }   정점들의 방문 표시를 할 visited[] 배열을 선언한다. 그 다음 탐색 시작 정점과, visited[] 배열을 매개변수로 하는 dfs 함수를 시작한다.   visited[start] = true;  현재 탐색 중인 정점을 방문 표시한다.   for (int i = 0; i &lt;adjList[start].size() ; i++) {}  현재 탐색 중인 인접 정점들에 대하여   int destination = adjList[start].get(i); if(!visited[destination])     dfs(destination,visited);  현재 탐색 중인 인접 정점 destination이 방문되지 않은 정점이면 destination을 다음 정점으로 하는 dfs 함수를 실행하여 재귀적으로 탐색한다.     위의 예제 그래프를 사용한 전체 코드는 다음과 같다.   DFSRecursion.java  import java.util.LinkedList;  public class DFSRecursion {      static class Graph{         int vertices;         LinkedList&lt;Integer&gt;[] adjList;          Graph(int vertices){             this.vertices = vertices;             adjList = new LinkedList[vertices];             for (int i = 0; i &lt;vertices ; i++) {                 adjList[i] = new LinkedList&lt;&gt;();             }         }         public void addEgde(int source, int destination){             adjList[source].add(destination);             adjList[destination].add(source);         }          public void DFSRecursion(int startVertex){             boolean [] visited = new boolean[vertices];             dfs(startVertex, visited);         }          public void dfs(int start, boolean [] visited){             visited[start] = true;             System.out.print(start + \" \");             for (int i = 0; i &lt;adjList[start].size() ; i++) {                 int destination = adjList[start].get(i);                 if(!visited[destination])                     dfs(destination,visited);             }         }     }      public static void main(String[] args) {         int vertices = 6;         Graph graph = new Graph(vertices);         graph.addEgde(0, 1);         graph.addEgde(0, 2);         graph.addEgde(0, 3);         graph.addEgde(1, 2);         graph.addEgde(2, 4);         graph.DFSRecursion(0);     } }   Output:  0 1 2 4 3    References      Wikipedia   JavaTpoint   Algorithms  ","categories": ["Algorithm"],
        "tags": ["Search Algorithm","DFS","Stack","Recursive","Graph","Tree","Back Tracking"],
        "url": "http://localhost:4000/algorithm/DFS-Implementation-recursive/",
        "teaser":null},{
        "title": "너비우선탐색(Breadth First Search, BFS)",
        "excerpt":"너비우선탐색(Breadth First Search)   너비우선탐색(BFS)은 트리나 그래프 혹은 다른 구조 상에서 탐색을 위한 알고리즘이다. 이 알고리즘은 루트 노드를 시작으로(그래프의 경우에는 임의의 노드를 루트 노드로 정하게 된다.) 다음 레벨로 가기전에 현재 레벨에서 인접한 모든 이웃노드들을 탐색한다.   더 이상 탐색할 노드가 없어 백트랙 하기 전까지 가지를 따라 가능한 한 깊이 탐색하는 깊이우선탐색과는 다르게 너비우선탐색은 해당 정점에서 인접한 정점들을 모두 방문하는 레벨 탐색 즉, 깊이보다는 넓게 탐색하는 전략을 쓴다. 이를 위해 너비우선탐색은 큐(Queue) 자료구조를 이용하여 탐색 방법을 구성하게 된다.   시간 및 공간 복잡도 분석은 많은 응용분야에 따라 다른데, 이론적인 컴퓨터 과학 분야에서 BFS는 전체 그래프를 탐색하는데 사용되기 때문에 수행 시간은 선형인 $O(|V|+|E| )$가 된다. 공간 복잡도면을 보면 BFS는 어떤 해당 정점에서 인접 정점들의 정보를 모두 큐에 저장하기 때문에, 최악의 설정으로 하나의 정점이 다른 모든 정점과 직접 연결되어 있다면  최악 $O(|V|)$의 공간을 요구한다. ($|V|$는 정점의 수, $|E|$는 간선의 수이다.)   너비우선탐색(BFS)의 시간 및 공간 상한은 깊이우선탐색(BFS)과 같기 때문에, 탐색 알고리즘의 사용면에서 두 알고리즘이 만드는 정점 방문 순서의 다름과 그 복잡성을 생각해 어느 알고리즘을 사용해야 할지 생각해야한다.   예제   다음 트리를 보고 너비우선탐색이 어떤 것인지 이해해보자.      위에서 보이는 트리에서 정점들의 번호는 너비우선탐색을 적용한 뒤 정점들의 방문 순서와 같다.   1번 정점을 루트로 하여 탐색을 시작하면, 1번 정점을 방문하고 그 인접한 정점 2, 3, 4를 순서대로 방문한다. 그 다음 레벨의 5, 6, 7, 8을 순서대로 방문하고 그 다음 레벨 9, 10, 11, 12순으로 방문하게 된다.   너비우선탐색이 어떻게 동작하는지 알아보자.   가정      현재 방문하고 있는 정점에서 인접한 왼쪽 간선을 오른쪽 간선보다 먼저 선택한다.   정점들의 방문 순서를 위해 큐 자료구조를 사용한다.   정점들의 방문은 중복되지 않는다.   1번 정점 부터 탐색을 시작한다.     먼저 1번 정점을 루트로 하여 BFS 탐색을 시작한다.         1번 정점을 큐에 넣는다.  Queue: [1]         큐에서 제일 앞에 있는 1번을 pop하고, 1번 정점을 방문한다.  1번 정점과 인접한 정점 중에서 방문하지 않은 2, 3, 4번을 순서대로 큐에 넣는다.  Queue: [2, 3, 4]         큐에서 제일 앞에 있는 2번을 pop하고, 2번 정점을 방문한다.  2번 정점과 인접한 정점 중에서 방문하지 않은 5, 6번을 순서대로 큐에 넣는다.  Queue: [3, 4, 5, 6]         큐에서 제일 앞에 있는 3번을 pop하고, 3번 정점을 방문한다.  3번 정점과 인접한 정점 중에서 방문하지 않은 정점이 없으므로 다음 스탭으로 간다.  Queue: [4, 5, 6]         큐에서 제일 앞에 있는 4번을 pop하고, 4번 정점을 방문한다.  4번 정점과 인접한 정점 중에서 방문하지 않은 7, 8번을 순서대로 큐에 넣는다.  Queue: [5, 6, 7, 8]         큐에서 제일 앞에 있는 5번을 pop하고, 5번 정점을 방문한다.  5번 정점과 인접한 정점 중에서 방문하지 않은 9, 10번을 순서대로 큐에 넣는다.  Queue: [6, 7, 8, 9, 10]         큐에서 제일 앞에 있는 6번을 pop하고, 6번 정점을 방문한다.  6번 정점과 인접한 정점 중에서 방문하지 않은 정점이 없으므로 다음 스탭으로 간다.  Queue: [7, 8, 9, 10]         큐에서 제일 앞에 있는 7번을 pop하고, 7번 정점을 방문한다.  7번 정점과 인접한 정점 중에서 방문하지 않은 11, 12번을 순서대로 큐에 넣는다.  Queue: [8, 9, 10, 11, 12]         큐에서 제일 앞에 있는 8번을 pop하고, 8번 정점을 방문한다.  8번 정점과 인접한 정점 중에서 방문하지 않은 정점이 없으므로 다음 스탭으로 간다.  Queue: [9, 10, 11, 12]         큐에서 제일 앞에 있는 9번을 pop하고, 9번 정점을 방문한다.  9번 정점과 인접한 정점 중에서 방문하지 않은 정점이 없으므로 다음 스탭으로 간다.  Queue: [10, 11, 12]         큐에서 제일 앞에 있는 10번을 pop하고, 10번 정점을 방문한다.  10번 정점과 인접한 정점 중에서 방문하지 않은 정점이 없으므로 다음 스탭으로 간다.  Queue: [11, 12]         큐에서 제일 앞에 있는 11번을 pop하고, 11번 정점을 방문한다.  11번 정점과 인접한 정점 중에서 방문하지 않은 정점이 없으므로 다음 스탭으로 간다.  Queue: [12]         큐에서 제일 앞에 있는 12번을 pop하고, 12번 정점을 방문한다.  12번 정점과 인접한 정점 중에서 방문하지 않은 정점이 없으므로 다음 스탭으로 간다.  Queue: [ ]         큐가 비었으므로 너비우선탐색(BFS)가 완료되었다.   의사코드   Input: 그래프 G, 그래프 G의 시작 루트 정점 v   다음은 Queue를 이용한 BFS의 의사코드이다.   1 procedure BFS(G, start_v) is 2      let Q be a queue 3      label start_v as discovered 4      Q.enqueue(start_v) 5      while Q is not empty do 6          v := Q.dequeue() 7          for all edges from v to w in G.adjacentEdges(v) do 8             if w is not labeled as discovered then 9                 label w as discovered 10                Q.enqueue(w)   한 구문씩 보자.           let Q be a queue: Queue를 생성한다.            label start_v as discovered: 시작 루트 정점을 방문표시 한다.            Q.enqueue(start_v): 시작 루트 정점을 Queue에 넣는다.            while Q is not empty do: Queue가 빈 공간이 아닐 때 까지 아래를 반복한다.            v := Q.dequeue(): 현재 방문할 정점 v를 Queue에서 꺼낸다.            for all edges from v to w in G.adjacentEdges(v) do: v와 인접한 모든 정점 w에 대하여            if w is not labeled as discovered then: w가 방문표시 되지 않았으면                       label w as discovered: w를 방문표시 하고                        Q.enqueue(w): w를 Queue에 넣는다.                   위에서 살펴본 예제와 이 의사코드의 한 가지 차이점이 있다면 예제에서는 정점을 큐에서 꺼낼 때 방문표시를 하는 반면, 의사코드 방식에서는 인접 정점들을 큐에 넣을 때 같이 방문표시를 한다는 것이다.   정점의 방문표시를 큐에 꺼낼 때 하거나 큐에 넣을 때 하는것은 어느 구현을 하느냐에 따라 정해진다.   구현   프로그래밍 언어로의 구현은 다음 글을 참고하면 좋다.      BFS Implementation Using Queue   Applications   너비우선탐색(BFS)은 그래프 이론 분야에서 많은 문제를 해결하는데에 쓰이고 있다.           두 정점 u, v간의 최단 경로 찾기 (경로의 길이는 간선의 수에 따라 정해질 때)            플로우 네트워크에서 Edmonds–Karp algorithm을 사용하여 최대 유량을 계산 할 때            문자열 알고리즘 아호-코라식(Aho-Corasick) 패턴 매칭의 실패 함수(failure function)를 구축할 때            그래프에서 정점들이 두개의 독립적인 서로소 그룹으로 나누어질 수 있는가 하는 이분성(bipartiteness) 테스팅            Copying garbage collection, Cheney’s algorithm       시간복잡도 및 공간복잡도   시간복잡도: $O(|V|+|E|)$ - ($O(|E|)$ may vary between $O(1)$ and $O(|V^2|)$)   너비우선탐색(BFS)의 시간복잡도는 최악의 경우 모든 정점과 간선을 탐색하기 때문에 $O(|V|+|E|)$으로 표현 될 수 있다. $O(|E|)$는 그래프가 얼마나 조밀한가에 따라 $O(1)$와 $O(|V^2|)$사이의 값이 될 수 있다.($|V|$는 정점의 수, $|E|$는 간선의 수이다.)   공간복잡도: $O(|V|)$   그래프의 정점들의 수를 미리 알고 있고, 어떤 정점들이 Queue에 추가되었는지와 같은 정보를 저장하기 위한 추가적인 자료구조를 사용하므로, 공간복잡도는 $O(|V|)$로 표현될 수 있다. 이 공간복잡도는 BFS의 탐색을 위한 공간 요구사항 이므로, 그래프 구축을 위해 사용되는 공간 요구사항과는 별개이다.   References      Wikipedia   JavaTpoint  ","categories": ["Algorithm"],
        "tags": ["Search Algorithm","BFS","Queue","Iterative","Graph","Tree"],
        "url": "http://localhost:4000/algorithm/BFS/",
        "teaser":null},{
        "title": "너비우선탐색(Breadth First Search, BFS) - 구현",
        "excerpt":"너비우선탐색 글 참고하기      Breadth First Search   그래프의 구현 글 참고하기      Graph     이번 글에서는 Queue를 사용한 BFS를 이해하고 구현해 봅니다.   너비우선탐색(Breadth First Search)   너비우선탐색(BFS)은 트리나 그래프 혹은 다른 구조 상에서 탐색을 위한 알고리즘이다. 이 알고리즘은 루트 노드를 시작으로(그래프의 경우에는 임의의 노드를 루트 노드로 정하게 된다.) 다음 레벨로 가기전에 현재 레벨에서 인접한 모든 이웃노드들을 탐색한다.   더 이상 탐색할 노드가 없어 백트랙 하기 전까지 가지를 따라 가능한 한 깊이 탐색하는 깊이우선탐색과는 다르게 너비우선탐색은 해당 정점에서 인접한 정점들을 모두 방문하는 레벨 탐색 즉, 깊이보다는 넓게 탐색하는 전략을 쓴다. 이를 위해 너비우선탐색은 큐(Queue) 자료구조를 이용하여 탐색 방법을 구성하게 된다.   시간 및 공간 복잡도 분석은 많은 응용분야에 따라 다른데, 이론적인 컴퓨터 과학 분야에서 BFS는 전체 그래프를 탐색하는데 사용되기 때문에 수행 시간은 선형인 $O(|V|+|E| )$가 된다. 공간 복잡도면을 보면 BFS는 어떤 해당 정점에서 인접 정점들의 정보를 모두 Queue에 저장하기 때문에, 최악의 설정으로 하나의 정점이 다른 모든 정점과 직접 연결되어 있다면  최악 $O(|V|)$의 공간을 요구한다. ($|V|$는 정점의 수, $|E|$는 간선의 수이다.)   너비우선탐색(BFS)의 시간 및 공간 상한은 깊이우선탐색(BFS)과 같기 때문에, 탐색 알고리즘의 사용면에서 두 알고리즘이 만드는 정점 방문 순서의 다름과 그 복잡성을 생각해 어느 알고리즘을 사용해야 할지 생각해야한다.   알고리즘   BFS 알고리즘은 다음과 같은 순서로 실행된다.           그래프의 정점 중 하나를 Queue에 추가한다. (시작 정점)            Queue에서 제일 앞에 있는 아이템 v를 pop하고 방문 완료 배열에 넣는다.            현재 정점 v에 인접한 모든 정점 중에서 방문 완료 되지 않았고, Queue에 추가되지 않은 인접 정점을 Queue에 추가한다.            Queue가 빈 공간이 될 때 까지 2, 3번을 반복한다.       예제   예를 들어 BFS 알고리즘을 이해 해보자.   인접 정점 추가 우선순위: 현재 정점과 인접한 정점이 여러개면 번호가 작은 순서대로 Queue에 추가한다.   먼저 1번 정점을 루트로 하여 BFS 탐색을 시작한다.         1번 정점을 Queue에 넣는다.  Queue: [1]         Queue에서 제일 앞에 있는 1번을 pop하고, 1번 정점을 방문한다.  1번 정점과 인접한 정점 중에서 방문하지 않은 2, 3, 4번을 순서대로 Queue에 넣는다.  Queue: [2, 3, 4]         Queue에서 제일 앞에 있는 2번을 pop하고, 2번 정점을 방문한다.  2번 정점과 인접한 정점 중에서 방문하지 않은 5, 6번을 순서대로 Queue에 넣는다.  Queue: [3, 4, 5, 6]         Queue에서 제일 앞에 있는 3번을 pop하고, 3번 정점을 방문한다.  3번 정점과 인접한 정점 중에서 방문하지 않은 정점이 없으므로 다음 스탭으로 간다.  Queue: [4, 5, 6]         Queue에서 제일 앞에 있는 4번을 pop하고, 4번 정점을 방문한다.  4번 정점과 인접한 정점 중에서 방문하지 않은 7, 8번을 순서대로 Queue에 넣는다.  Queue: [5, 6, 7, 8]         Queue에서 제일 앞에 있는 5번을 pop하고, 5번 정점을 방문한다.  5번 정점과 인접한 정점 중에서 방문하지 않은 9, 10번을 순서대로 Queue에 넣는다.  Queue: [6, 7, 8, 9, 10]         Queue에서 제일 앞에 있는 6번을 pop하고, 6번 정점을 방문한다.  6번 정점과 인접한 정점 중에서 방문하지 않은 정점이 없으므로 다음 스탭으로 간다.  Queue: [7, 8, 9, 10]         Queue에서 제일 앞에 있는 7번을 pop하고, 7번 정점을 방문한다.  7번 정점과 인접한 정점 중에서 방문하지 않은 11, 12번을 순서대로 Queue에 넣는다.  Queue: [8, 9, 10, 11, 12]         Queue에서 제일 앞에 있는 8번을 pop하고, 8번 정점을 방문한다.  8번 정점과 인접한 정점 중에서 방문하지 않은 정점이 없으므로 다음 스탭으로 간다.  Queue: [9, 10, 11, 12]         Queue에서 제일 앞에 있는 9번을 pop하고, 9번 정점을 방문한다.  9번 정점과 인접한 정점 중에서 방문하지 않은 정점이 없으므로 다음 스탭으로 간다.  Queue: [10, 11, 12]         Queue에서 제일 앞에 있는 10번을 pop하고, 10번 정점을 방문한다.  10번 정점과 인접한 정점 중에서 방문하지 않은 정점이 없으므로 다음 스탭으로 간다.  Queue: [11, 12]         Queue에서 제일 앞에 있는 11번을 pop하고, 11번 정점을 방문한다.  11번 정점과 인접한 정점 중에서 방문하지 않은 정점이 없으므로 다음 스탭으로 간다.  Queue: [12]         Queue에서 제일 앞에 있는 12번을 pop하고, 12번 정점을 방문한다.  12번 정점과 인접한 정점 중에서 방문하지 않은 정점이 없으므로 다음 스탭으로 간다.  Queue: [ ]         Queue가 비었으므로 너비우선탐색(BFS)가 완료되었다.   구현   의사코드   Input: 그래프 G, 그래프 G의 시작 루트 정점 v   다음은 Queue를 이용한 BFS의 의사코드이다.   1 procedure BFS(G, start_v) is 2      let Q be a queue 3      label start_v as discovered 4      Q.enqueue(start_v) 5      while Q is not empty do 6          v := Q.dequeue() 7          for all edges from v to w in G.adjacentEdges(v) do 8             if w is not labeled as discovered then 9                 label w as discovered 10                Q.enqueue(w)   한 구문씩 보자.           let Q be a queue: Queue를 생성한다.            label start_v as discovered: 시작 루트 정점을 방문표시 한다.            Q.enqueue(start_v): 시작 루트 정점을 Queue에 넣는다.            while Q is not empty do: Queue가 빈 공간이 아닐 때 까지 아래를 반복한다.            v := Q.dequeue(): 현재 방문할 정점 v를 Queue에서 꺼낸다.            for all edges from v to w in G.adjacentEdges(v) do: v와 인접한 모든 정점 w에 대하여            if w is not labeled as discovered then: w가 방문표시 되지 않았으면                       label w as discovered: w를 방문표시 하고                        Q.enqueue(w): w를 Queue에 넣는다.                   위 의사코드에서는 Queue에 인접 정점의 중복 저장이 되는 것을 방지하기 위해 w를 Queue에 넣음과 동시에 방문표시를 해주고 있다.     BFS 알고리즘 - Java   위 의사코드를 바탕으로 한 BFS 알고리즘 코드는 다음과 같다.   public void BFS(int start){     Queue&lt;Integer&gt; queue = new LinkedList&lt;Integer&gt;();     boolean visited[] = new boolean[V];     queue.offer(start);     visited[start] = true;     while (!queue.isEmpty()){         int V = queue.poll();         for (int i : adj[V]) {             if (!visited[i]){                 queue.offer(i);                 visited[i] = true;             }         }     } }   위의 코드 설명   Queue&lt;Integer&gt; queue = new LinkedList&lt;Integer&gt;(); boolean visited[] = new boolean[V]; }   정점 방문 순서를 위한 Queue와 정점 방문 표시를 할 visited[] 배열을 선언한다.   queue.offer(start); visited[start] = true;  시작 정점을 Queue 추가하고 방문 표시를 한다.   for (int i = 0; i &lt;adjList[start].size() ; i++) {}  현재 탐색 중인 인접 정점들에 대하여   while (!queue.isEmpty()){}  Queue가 빌 때 까지 다음 연산을 실행한다.   int V = queue.poll(); for (int i : adj[V]) {     if (!visited[i]){         queue.offer(i);         visited[i] = true;     } }   Queue에서 제일 앞에 있는 정점을 꺼내 V로 하고, V에 인접한 모든 정점에 대하여 방문하지 정점은 Queue에 추가하고 방문 표시를 함께 한다.     위의 예제 그래프를 사용한 전체 코드는 다음과 같다.      BFS 메소드에 print문을 추가하여 정점 방문 순서를 출력하게 하였다.   BreadthFirstSearch.java  import java.util.*; import java.util.LinkedList;  public class BreadthFirstSearch{     static class Graph{         public int V;         public LinkedList &lt;Integer&gt; adj[];           Graph(int v){             V = v+1;             adj = new LinkedList[V];             for(int i = 0; i&lt;V; i++){                 adj[i] = new LinkedList();             }          }          public void addEdge(int a, int b){             adj[a].add(b);             adj[b].add(a);         }           public void BFS(int start){             Queue&lt;Integer&gt; queue = new LinkedList&lt;Integer&gt;();             boolean visited[] = new boolean[V];             queue.offer(start);             visited[start] = true;             while (!queue.isEmpty()){                 int V = queue.poll();                 System.out.print(V + \" \");                 for (int i : adj[V]) {                     if (!visited[i]){                         queue.offer(i);                         visited[i] = true;                     }                 }             }         }     }      public static void main(String[] args){          Graph g = new Graph(12);         g.addEdge(1, 2);         g.addEdge(1, 3);         g.addEdge(1, 4);         g.addEdge(2, 1);         g.addEdge(2, 5);         g.addEdge(2, 6);         g.addEdge(3, 1);         g.addEdge(4, 1);         g.addEdge(4, 7);         g.addEdge(4, 8);         g.addEdge(5, 2);         g.addEdge(5, 9);         g.addEdge(5, 10);         g.addEdge(6, 2);         g.addEdge(7, 4);         g.addEdge(7, 11);         g.addEdge(7, 12);         g.addEdge(8, 4);         g.addEdge(9, 5);         g.addEdge(10, 5);         g.addEdge(11, 7);         g.addEdge(12, 7);         System.out.print(\"Breath First Search : \");         g.BFS(1);     } }   Output:  Breath First Search : 1 2 3 4 5 6 7 8 9 10 11 12    References      Wikipedia   JavaTpoint  ","categories": ["Algorithm"],
        "tags": ["Search Algorithm","BFS","Queue","Iterative","Graph","Tree"],
        "url": "http://localhost:4000/algorithm/BFS-Implementation/",
        "teaser":null},{
        "title": "그리디 알고리즘(Greedy Algorithm)-예정 포스트",
        "excerpt":" ","categories": ["Algorithm"],
        "tags": ["Spanning Tree"],
        "url": "http://localhost:4000/algorithm/greedy-algorithm/",
        "teaser":null},{
        "title": "위상정렬(Topological sorting)",
        "excerpt":"위상정렬(Topological sorting)   컴퓨터 과학에서 위상정렬(Topological sorting)은 방향 그래프에서 정점들의 선형적인 순서를 말하는데, 여기서 정점들의 선형적 순서란 정점 u로 부터 정점 v로 가는 간선에 대해 순서상 정점 u가 정점 v보다 앞에 있다는 것을 뜻한다. 예를 들어, 방향 그래프에서 정점들은 수행될 작업들을 뜻할 수 있고, 간선은 어떤 작업이 다른 작업보다 먼저 수행되어야 한다는 제약을 나타낼 수 있다. 즉, 위상정렬의 결과는 작업들이 수행되는 일련의 순서를 의미한다. 위상정렬은 사이클이 형성되지 않은 그래프에서 가능하다. 즉, 사이클이 없는 방향 그래프에서 적용이 가능한데, 이런 그래프를 DAG(Directed acyclic graph)라고 한다. 어떤 DAG에 대해서도 위상정렬을 적용하면 적어도 하나의 위상순서를 가지게 되고 경우에 따라 여러개의 위상순서를 가질수 있다. 위상정렬 알고리즘은 DAG에서 위상순서를 구하는데 선형시간이 걸린다고 알려져 있다.   Example   위상정렬은 현실적인 예로는 제약에 따른 작업들의 스케줄링 순서라고 이해하면 된다. 작업들은 정점으로 나타내어지고 정점에서 다른 정점으로의 간선이 있는데, 이는, x, y 두 정점을 끝 점으로 하고 x-&gt;y로의 방향 간선 E(x,y)이 있을 때 작업 y가 수행되기 위해서는 x가 사전에 먼저 수행 완료되어야 한다는 것을 뜻한다. 작업 y의 제약은 x인 것이다. 이처럼 제약이 있는 해당 작업들에 대해서 위상정렬은 작업들의 수행순서를 나타낸다.   밑 그림에서 5번 정점과 11번 정점을 보자. 정점은 작업으로 생각하고 간선은 제약 또는 작업 흐름으로 보면 위상정렬에서는 5번 작업이 완료되고 11번 작업이 수행된다는 것이다. 즉, 11번 작업이 수행되기 위해선 5번 작업이 사전에 완료가 되어야 한다는 것을 말한다. 다른 작업들도 마찬가지로, 9번 정점이 수행되기 위해서는 11번과 8번 작업이 사전에 완료가 되어야 한다.      위상순서: DAG의 모든 간선 u-&gt;v에 대해서, 정점 u는 v보다 순서상에서 먼저 나와야 한다.   다음은 위 그림에서의 위상정렬 순서인데 기준에 따라 여러가지가 있을 수 있다.      5-&gt;7-&gt;3-&gt;11-&gt;8-&gt;2-&gt;9-&gt;10 (왼쪽에서 오른쪽, 밑에서 아래로)   3-&gt;5-&gt;7-&gt;8-&gt;11-&gt;2-&gt;9-&gt;10 (현재 작업 가능한 작업들의 번호가 작은순서)   3-&gt;7-&gt;8-&gt;5-&gt;11-&gt;10-&gt;2-&gt;9 (현재 작업 가능한 작업들의 무작위 선택)   Algorithm   DAG에서의 위상정렬을 구하는 두 가지 알고리즘을 살펴보자.  이 두 알고리즘은 모두 $O(V+E)$의 선형시간에 동작한다. V는 정점의 개수, E는 간선의 개수이다.   Kahn’s algorithm   위상정렬을 구하는 이 알고리즘은 Kahn (1962)에 의해 처음 소개 되었다.   Kahn’s algorithm은 해당 그래프에서의 진입간선(Incoming edge)을 가지고 있지 않은 정점으로 부터 시작해서 그 정점과 연결된 정점의 진입간선(Incoming edge)을 삭제 하면서 동작한다.   다음은 Kahn’s algorithm의 위상정렬 의사코드이다.   S ← Set of all nodes with no incoming edge L ← Empty list that will contain the sorted elements  while S is non-empty do     remove a node n from S     add n to tail of L     for each node m with an edge e from n to m do         remove edge e from the graph         if m has no other incoming edges then             insert m into S  if graph has edges then     return error   (graph has at least one cycle) else      return L   (a topologically sorted order)      진입간선이 없는 없는 정점들을 시작 리스트 S에 넣는다.   S가 빈 공간이 아닐 때 까지 다음을 반복한다.   S의 앞에서 부터 정점 n을 하나 취해서 위상정렬 리스트 L의 끝에 추가한다.   정점 n과 m을 양 끝점으로 하는 간선 e와 정점 m에 대해서            간선 e를 삭제한다. (정점 m의 진입간선 삭제와 같은 의미이다.)       정점 m의 진입간선의 개수가 0개라면, S에 m을 추가한다.           그래프에 간선이 남아있으면 적어도 하나의 사이클이 있다는 의미이므로 error를 리턴한다. 그렇지 않으면 위상정렬 순서를 리턴한다.     위상정렬을 적용할 그래프가 DAG이라면 이 알고리즘은 위상정렬 순서 L을 리턴할 것이고, 그래프에 사이클이 하나라도 있다면 위상정렬은 불가능하다.   집합 S에서 n이 삭제되는 순서에 따라 위상정렬의 결과는 달라지기 때문에, 한 그래프에서 위상정렬은 특정하지 않고 여러개가 존재할 수 있다. S는 큐와 스택 같은 정점들을 담을 수 있는 집합이 될 수 있다.   구현에 있어서 간선을 삭제하는 방법과 정점 m의 진입간선 개수를 추적하는 방법은 각 정점마다 진입간선의 개수를 가지고 있는 배열을 둠으로써 쉽게 구현이 가능하다.      indegree[m]은 m의 진입간선 개수를 의미한다.   indegree[m] = indegree[m] - 1 을 함으로써 m의 진입간선을 하나 삭제할 수 있다.   indegree[m] == 0 이면 m의 진입간선은 없으므로 m을 S에 추가한다.   Depth-first search   위상정렬을 구하는 다른 방법은 깊이우선탐색(Depth-first search)에 기반한 것이다.   이 방법은 그래프의 기준에 따라 또는 임의의 순서로 노드들을 탐색해 나가다가 이미 방문이 완료된 정점 또는 더 이상 탐색할 정점을 가지지 않은 정점에 대해서 위상정렬 리스트에 노드를 추가하는 방법이다.   다음은 Depth-first search에 기반한 위상정렬의 의사코드이다.      permanent mark: 더 이상 방문할 정점이 없어 DFS 탐색이 끝난 정점의 표시를 뜻한다.   temporary mark: DFS 탐색이 진행 중인 정점의 표시를 뜻한다.   L ← Empty list that will contain the sorted nodes while exists nodes without a permanent mark do     select an unmarked node n     visit(n)  function visit(node n)     if n has a permanent mark then         return     if n has a temporary mark then         stop   (not a DAG)      mark n with a temporary mark      for each node m with an edge from n to m do         visit(m)      remove temporary mark from n     mark n with a permanent mark     add n to head of L   DAG에서 방문완료 되지 않은 정점들이 있는 동안, 정점을 하나 선택해 탐색을 진행한다.   function visit(node n):     정점 n이 방문완료 정점이면 백트랙 한다.   정점 n이 현재 방문 중인 정점이면 역 간선(Back edge)이 있다는 것이므로 사이클이 있다는 말이된다. 알고리즘을 종료한다.   위 1, 2번 조건이 아니라면, 정점 n을 진행 중인 정점으로 표시한다.   정점 n과 m을 양 끝점으로 하는 간선의 정점 m에 대해서   정점 m을 재귀적으로 탐색한다. (1번으로 간다.)   정점 n을 방문완료 표시하고 L의 맨 처음에 추가한다.   DFS 함수에서 temporary mark검사를 하고 있는데, DFS 탐색에 있어서 방문되어 지고 있는 정점이 방문완료 되지 못한 채 다른 정점에 의해서 방문이 되면, 역 간선(Back edge)이 있다는 의미가 된다. 이는 사이클이 있다는 것과 같은 의미이다.   Implementation   다음의 구현들은 밑의 그래프를 예제로 사용하였다.      다음은 Kahn’s algorithm을 구현한 java 코드이다.      Graph class: 간선 정보들로 부터 그래프를 구축한다.   indegree.set(dest, indegree.get(dest) + 1);: 간선 정보들로 부터 그래프를 구축하면서 해당 정점에 해당하는 진입간선을 하나씩 추가한다.   Stack&lt;Integer&gt; S = new Stack&lt;&gt;();: 정점들을 담을 집합 S로는 스택을 사용하였다.   import java.util.*;  // data structure to store graph edges class Edge { \tint source, dest;  \tpublic Edge(int source, int dest) { \t\tthis.source = source; \t\tthis.dest = dest; \t} };  // class to represent a graph object class Graph { \t// A List of Lists to represent an adjacency list \tList&lt;List&lt;Integer&gt;&gt; adjList = null;  \t// stores indegree of a vertex \tList&lt;Integer&gt; indegree = null;  \t// Constructor \tGraph(List&lt;Edge&gt; edges, int N) { \t\tadjList = new ArrayList&lt;&gt;(N); \t\tfor (int i = 0; i &lt; N; i++) { \t\t\tadjList.add(i, new ArrayList&lt;&gt;()); \t\t}  \t\t// initialize indegree of each vertex by 0 \t\tindegree = new ArrayList&lt;&gt;(Collections.nCopies(N, 0));  \t\t// add edges to the undirected graph \t\tfor (int i = 0; i &lt; edges.size(); i++) \t\t{ \t\t\tint src = edges.get(i).source; \t\t\tint dest = edges.get(i).dest;  \t\t\t// add an edge from source to destination \t\t\tadjList.get(src).add(dest);  \t\t\t// increment in-degree of destination vertex by 1 \t\t\tindegree.set(dest, indegree.get(dest) + 1); \t\t} \t} }  class TopologicalSort { \t// performs Topological Sort on a given DAG \tpublic static List&lt;Integer&gt; doTopologicalSort(Graph graph, int N) \t{ \t\t// list to store the sorted elements \t\tList&lt;Integer&gt; L = new ArrayList&lt;&gt;();  \t\t// get indegree information of the graph \t\tList&lt;Integer&gt; indegree = graph.indegree;  \t\t// Set of all nodes with no incoming edges \t\tStack&lt;Integer&gt; S = new Stack&lt;&gt;(); \t\tfor (int i = 0; i &lt; N; i++) { \t\t\tif (indegree.get(i) == 0) { \t\t\t\tS.add(i); \t\t\t} \t\t}  \t\twhile (!S.isEmpty()) \t\t{ \t\t\t// remove a node n from S \t\t\tint n = S.pop();  \t\t\t// add n to tail of L \t\t\tL.add(n);  \t\t\tfor (int m : graph.adjList.get(n)) \t\t\t{ \t\t\t\t// remove edge from n to m from the graph \t\t\t\tindegree.set(m, indegree.get(m) - 1);  \t\t\t\t// if m has no other incoming edges then \t\t\t\t// insert m into S \t\t\t\tif (indegree.get(m) == 0) { \t\t\t\t\tS.add(m); \t\t\t\t} \t\t\t} \t\t}  \t\t// if graph has edges then graph has at least one cycle \t\tfor (int i = 0; i &lt; N; i++) { \t\t\tif (indegree.get(i) != 0) { \t\t\t\treturn null; \t\t\t} \t\t}  \t\treturn L; \t}  \tpublic static void main(String[] args) \t{ \t\t// List of graph edges as per above diagram \t\tList&lt;Edge&gt; edges = Arrays.asList(             new Edge(0, 6), new Edge(1, 2), new Edge(1, 4),             new Edge(1, 6), new Edge(3, 0), new Edge(3, 4),             new Edge(5, 1), new Edge(7, 0), new Edge(7, 1)         );  \t\t// Set number of vertices in the graph \t\tfinal int N = 8;  \t\t// create a graph from edges \t\tGraph graph = new Graph(edges, N);  \t\t// Perform Topological Sort \t\tList&lt;Integer&gt; L = doTopologicalSort(graph, N);  \t\tif (L != null) { \t\t\tSystem.out.print(L);  // print topological order \t\t} else { \t\t\tSystem.out.println(\"Graph has at least one cycle. \" + \t\t\t\t\t\t\t  \"Topological sorting is not possible\"); \t\t} \t} }  Output: 7 5 1 2 3 4 0 6   References      Topological Sorting - Kahn’s algorithm   Topological Sorting  ","categories": ["Algorithm"],
        "tags": ["Sort","DFS","Cycle","DAG"],
        "url": "http://localhost:4000/algorithm/topological-sorting/",
        "teaser":null},{
        "title": "플로이드 와샬 알고리즘(Floyd Warshall Algorithm)-예정 포스트",
        "excerpt":" ","categories": ["Algorithm"],
        "tags": ["Shortest Path"],
        "url": "http://localhost:4000/algorithm/floyd-warshall/",
        "teaser":null},{
        "title": "SPFA(Shortest Path Faster Algorithm)",
        "excerpt":"Graph 글 참고하기      Graph   Queue 글 참고하기      Queue     SPFA(Shortest Path Faster Algorithm)   The Shortest Path Faster Algorithm (SPFA)는 Bellman–Ford algorithm 을 개선한 알고리즘 으로서, 방향 가중치 그래프에서 단일 출발 정점 최단 거리를(Single source shortest path distance) 계산한다. 다른 여타 Bellman–Ford algorithm 이나 Dijkstra’s algorithm 과 같은 Single source shortest path algorithm 처럼 SPFA도 변 경감(Edge relaxation)을 핵심 연산으로 하여 동작한다.   이 SPFA는 무작위 희소 그래프에서 잘 동작한다고 알려져 있고, 음수 가중치 간선(Nagative weighted edge)을 가진 그래프에서도 적합하다. 그러나 최악 시간복잡도는 $O(|V|\\cdot|E|)$ 로서 Bellman–Ford algorithm과 같기 때문에, 음수 가중치 간선이 없는 그래프의 경우에는 최악 시간복잡도를 고려한다면 Dijkstra’s algorithm이 더 적합하다고 볼 수 있다.   Algorithm   방향 가중치 그래프가 주어지고 $G = (V, E)$ 그리고 출발 정점을 $s$라고 하자. SPFA는 출발 정점 $s$으로부터 다른 모든 정점 $v$로의 최단 경로를 찾는다. $s$로 부터 $v$로의 최단 경로 거리는 각 정점 $v$에 대하여 $d(v)$에 저장된다.   SPFA는 각 정점의 인접 정점을 필요하다면 변 경감(Edge relaxation)하기 위해 각 정점을 후보자로 사용한다. 이 점은 Bellman–Ford algorithm과 같다. 하지만 Bellman–Ford algorithm과 비교했을 때의 개선점은 모든 정점들을 무조건 적으로 연산을 시도하기 보다는 SPFA는 후보자 정점에 대한 Queue를 가지고, 어떤 정점에 대해 그 정점이 변 경감 연산이 이루어졌을 때만 후보자 정점으로서 Queue에 삽입을 한다. 이런 행동들은 변 경감 연산이 실행될 정점이 없을 때까지 반복된다.     다음은 SPFA의 의사코드이다.   Input: 그래프 G, 시작 정점 s   $Q$는 변 경감 연산이 되고 난 후의 후보자를 담을 Queue를 의미한다.  $w(u,v)$는 간선 $(u,v)$의 간선 가중치를 의미한다.   Notice: Q 안에 v의 존재 유무를 판단하기 위해 구현 시에는 이를 추적하기 위한 추가적인 자료구조가 요구된다.    0 procedure Shortest-Path-Faster-Algorithm(G, s)  1    for each vertex v ≠ s in V(G)  2        d(v) := ∞  3    d(s) := 0  4    offer s into Q  5    while Q is not empty  6        u := poll Q  7        for each edge (u, v) in E(G)  8            if d(u) + w(u, v) &lt; d(v) then  9                d(v) := d(u) + w(u, v) 10                if v is not in Q then 11                    offer v into Q    하나씩 보자.   1    for each vertex v ≠ s in V(G) 2        d(v) := ∞  그래프 G의 출발 정점 s를 제외한 모든 정점 v에 대하여 s로부터 각 v에 대한 최단경로 거리 d(v)를 INF로 초기화 한다.    3    d(s) := 0  4    offer s into Q   먼저 출발 정점 s의 최단경로 거리를 0으로 초기화하고 s를 Q에 넣는다.   5    while Q is not empty   큐가 빌 때 까지 아래 연산들을 반복한다.   6    u := poll Q 7    for each edge (u, v) in E(G)   Q에서 정점하나를 꺼내 u라 하고, 그래프 G에서 u와 인접한 정점 v와의 간선 (u, v)에 대하여   8    if d(u) + w(u, v) &lt; d(v) then 9       d(v) := d(u) + w(u, v)  s로부터 u로의 최단경로 거리 d(u) + 간선 (u, v)의 값이 s로부터 v로의 최단경로 거리 d(v)보다 작다면 d(v)값을 d(u) + w(u, v)로 업데이트 한다. (Edge Relaxation)   10      if v is not in Q then 11          offer v into Q  변 경감 연산(Edge Relaxation)이 된 정점 v가 현재 Q에 없으면, v를 Q에 추가한다.   Step by step   실제 그래프를 예로 들어 SPFA가 어떻게 동작하는지 알아보자.   0번을 시작 정점으로 하여 5번 정점으로의 최단 경로를 구한다.   해당 정점에 연결된 인접 정점이 여러개 일 땐, 번호가 작은 것을 먼저 선택한다.      시작 정점으로 부터 모든 정점까지의 최단거리 d(v)를 무한대(INF)로 초기화 한다.  d(s)는 0으로 초기화 한다.   Queue에 시작 정점 0을 넣는다.  Queue : [0]      Queue에서 원소 하나를 pop한다.  0번 정점과 인접한 정점 1번에 대하여 d(0) + w(0, 1) &lt; d(1): 0 + 4 &lt; INF이므로  d(1)을 4로 업데이트 한다.   업데이트 되었으므로 1번 정점을 Queue에 넣는다.  Queue : [1]      0번 정점과 인접한 정점 2번에 대하여 d(0) + w(0, 2) &lt; d(1): 0 + 2 &lt; INF이므로  d(2)을 2로 업데이트 한다.   업데이트 되었으므로 2번 정점을 Queue에 넣는다.  Queue : [1 2]      Queue에서 원소 하나를 pop한다.  1번 정점과 인접한 정점 2번에 대하여 d(1) + w(1, 2) &lt; d(2): 4 + 5 &gt; 2이므로  d(2)를 업데이트 하지 않는다.   Queue : [2]      1번 정점과 인접한 정점 3번에 대하여 d(1) + w(1, 3) &lt; d(3): 4 + 10 &lt; INF이므로  d(3)을 14로 업데이트 한다.   업데이트 되었으므로 3번 정점을 Queue에 넣는다.  Queue : [2, 3]      Queue에서 원소 하나를 pop한다.  2번 정점과 인접한 정점 4번에 대하여 d(2) + w(2, 4) &lt; d(4): 2 + 3 &lt; INF이므로  d(4)을 5로 업데이트 한다.   업데이트 되었으므로 4번 정점을 Queue에 넣는다.  Queue : [3, 4]      Queue에서 원소 하나를 pop한다.  3번 정점과 인접한 정점 5번에 대하여 d(3) + w(3, 5) &lt; d(5): 14 + 11 &lt; INF이므로  d(5)을 25로 업데이트 한다.   업데이트 되었으므로 5번 정점을 Queue에 넣는다.  Queue : [4, 5]      Queue에서 원소 하나를 pop한다.  4번 정점과 인접한 정점 3번에 대하여 d(4) + w(4, 3) &lt; d(3): 5 + 4 &lt; 14이므로  d(3)을 9로 업데이트 한다.   업데이트 되었으므로 3번 정점을 Queue에 넣는다.  Queue : [5, 3]      Queue에서 원소 하나를 pop한다.  5번 정점과 인접한 정점이 없다.   Queue : [3]      Queue에서 원소 하나를 pop한다.  3번 정점과 인접한 정점 5번에 대하여 d(3) + w(3, 5) &lt; d(5): 9 + 11 &lt; 25이므로  d(5)을 20로 업데이트 한다.   업데이트 되었으므로 5번 정점을 Queue에 넣는다.  Queue : [5]      Queue에서 원소 하나를 pop한다.  5번 정점과 인접한 정점이 없다.   Queue : [ ]      큐가 비었으므로 SPFA가 완료되었다.   0번 부터 5번으로의 최단경로는 빨간선을 따라간 경로이고 그 거리는 20이다.      Implementation   다음은 위 의사코드를 바탕으로 SPFA를 구현한 자바 메소드이다.   static void shortestPathFasterAlgorithm(int s){     dist = new int[n];     onQueue = new boolean[n];     Arrays.fill(dist, INF);     Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();     queue.offer(s);     dist[s] = 0;     onQueue[s] = true;     while (!queue.isEmpty()){         int cur = queue.poll();         onQueue[cur] = false;         for (Edge e : graph[cur]){             if (dist[cur] + e.cost &lt; dist[e.to]){                 dist[e.to] = dist[cur] + e.cost; // Edge Relaxation             }         }     } }   현재 Queue에서 정점 $v$의 존재 유무를 추적하기 위해 위 코드에서는 onQueue[] 를 사용한다.     그래프의 가중치 간선 정보를 구성하기 위해 아래의 Edge 클래스를 사용한다.   to는 다음 인접 정점의 번호, cost는 간선 비용(가중치)를 나타낸다.   ... // static ArrayList&lt;Edge&gt; [] graph; ...  static class Edge{     int to;     int cost;      // Constructor     public Edge(int to, int cost) {         this.to = to;         this.cost = cost;     } }    다음은 SPFA를 구현한 자바 코드이다.   그래프의 입력은 예제 그래프를 사용하였고, 최단경로를 추적하고 구성하기 위해 pred[]배열을 선언한 뒤 SPFA의 실행 중에 어느 한 포인트에서 정점 u, v가 있고(정점 v가 u에 의해 relaxation 되어지는 정점), relaxation 되어진 정점 v가 있으면, 그 정점을 relaxation하게 만든 정점 u가 최단경로 상의 이전 노드 이므로 pred[e.to] = cur;를 하여 경로를 구축한다. 그 다음 printPathReconstruction함수로 경로를 출력한다.   이 프로그램은 최단경로 거리와 그 경로를 출력한다.      Input: Graph G, start vertex   Output: Distance of shortest path of Graph G, shortest path of Graph G   시작 정점은 0번이다.   import java.io.*; import java.util.*; import java.util.LinkedList;  /**  * This program is to find Shortest path in weighted graph using SPFA.  * Time Complexity : Worst case : O(VE) same as Standard Bellman ford  *                   Average case : O(E) - not proved  *  * @author Lemidia(Gyeong)  */  public class ShortestPathFasterAlgorithm{       // the number of vertices in Graph G     static int n;     // Shortest distance from s to each vertex v     static int dist[];     // for construct shortest path     static int pred[];     static ArrayList&lt;Edge&gt; [] graph;     static final int INF = Integer.MAX_VALUE;     // For check whether the vertex is on queue or not     static boolean onQueue[];       // Init Graph G     static void createGraph(){         graph = new ArrayList[n];         for (int i = 0; i &lt; n; i++){             graph[i] = new ArrayList&lt;&gt;();         }     }      // Add weighted direct edges.     static void addEdge(int from, int to, int cost){         Edge e = new Edge(to, cost);         graph[from].add(e);     }      static void shortestPathFasterAlgorithm(int s){         dist = new int[n];         pred = new int[n];         onQueue = new boolean[n];         Arrays.fill(dist, INF);         Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();         queue.offer(s);         dist[s] = 0;         onQueue[s] = true;         while (!queue.isEmpty()){             int cur = queue.poll();             onQueue[cur] = false;             for (Edge e : graph[cur]){                 if (dist[cur] + e.cost &lt; dist[e.to]){                     dist[e.to] = dist[cur] + e.cost; // Edge Relaxation                     pred[e.to] = cur; // store previous node                     if (onQueue[e.to] == false){ // Node(e.to) is not in the queue                         onQueue[e.to] = true;                         queue.offer(e.to);                     }                 }             }         }     }      static void printPathReconstruction(int start, int end){         if (end == start) {             System.out.print(start);             return;         }         pathReconstruction(start, pred[end]);         System.out.print(\" -&gt; \" + end );     }      public static void main(String[] args) throws IOException {         BufferedReader br = new BufferedReader(new InputStreamReader(System.in));          n = 6;         int start = 0;         createGraph();         addEdge(0, 1, 4);         addEdge(0, 2, 2);         addEdge(1, 2, 5);         addEdge(1, 3, 10);         addEdge(2, 4, 3);         addEdge(3, 5, 11);         addEdge(4, 3, 4);          shortestPathFasterAlgorithm(start);          System.out.println(\"Shortest path distance : \" + dist[5]);         System.out.print(\"Shortest path : \");         printPathReconstruction(start, 5);     }      static class Edge{         int to;         int cost;          public Edge(int to, int cost) {             this.to = to;             this.cost = cost;         }     } }   Output:  Shortest path distance : 20 Shortest path : 0 -&gt; 2 -&gt; 4 -&gt; 3 -&gt; 5   Optimization techniques   Small Label First (SLF) technique.   변 경감(Edge relaxation) 되어진 정점 $v$를 항상 Queue 뒤에 추가하였지만 이 technique에서는 그 추가되어진 정점 $v$의 $d(v)$와 Queue의 맨 앞 정점의 거리 $d(front(Q))$를 비교하고 $d(v)$가 더 작다면 $d(v)$를 Queue의 맨 앞으로 보낸다. 이 technique은 front에 원소 추가를 요구하므로 front와 rear 전부 pop(), offer()연산을 지원하는 Deque(데크) 자료구조를 사용함으로써 구현할 수 있다.   위 SPFA 자바 메소드에서 Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();를 Deque&lt;Integer&gt; queue = new LinkedList&lt;&gt;();로 하여 Deque를 사용한다.   다음은 이 technique의 의사코드이다.   procedure Small-Label-First(G, Q)      if d(back(Q)) &lt; d(front(Q)) then          u := pop back of Q          push u into front of Q   다음은 SPFA에 위 최적화를 적용한 코드이다.   static void shortestPathFasterAlgorithm(int s){     dist = new int[n];     pred = new int[n];     onQueue = new boolean[n];     Arrays.fill(dist, INF);     Deque&lt;Integer&gt; queue = new LinkedList&lt;&gt;();     queue.offer(s);     dist[s] = 0;     onQueue[s] = true;     while (!queue.isEmpty()){         int cur = queue.poll();         onQueue[cur] = false;         for (Edge e : graph[cur]){             if (dist[cur] + e.cost &lt; dist[e.to]){                 dist[e.to] = dist[cur] + e.cost; // Edge Relaxation                 pred[e.to] = cur; // store previous node                 if (onQueue[e.to] == false){ // Node(e.to) is not in the queue                     onQueue[e.to] = true;                     queue.offer(e.to);                     // Optimization &lt;Small Label First&gt;                     if (dist[e.to] &lt; dist[queue.peekFirst()]){                         queue.offerFirst(queue.pollLast());                     }                 }             }         }     } }    Large Label Last (LLL) technique.   Queue의 front 원소의 값이 현재 Queue에 들어있는 모든 정점의 평균보다 작게 하기 위해, Queue에 들어있는 모드 정점 $v$의 평균을 구하고, Queue 앞에서 부터 평균보다 큰 값을 가진 정점 $v$들을 Queue의 맨 뒤로 보내는 연산이다. 평균보다 작은 값을 가진 정점 $v$가 나오면 loop를 빠져나온다.   다음은 이 technique의 의사코드이다.    procedure Large-Label-Last(G, Q)      x := average of d(v) for all v in Q      while d(front(Q)) &gt; x          u := pop front of Q          push u to back of Q   Running time   The worst-case running time : $O(|V|\\cdot|E|)$   SPFA의 최악 실행 시간은 standard Bellman-Ford algorithm과 같은 $O(|V|\\cdot|E|)$ 이다.   The average running time : $O(|E|)$   실험으로 보여지는 SPFA의 평균 실행 시간은 $O(|E|)$ 수준이다. 그러나 평균 실행 시간은 아직 증명 되지 않았다.   References      Wikipedia - SPFA   wcipeg - Shortest path  ","categories": ["Algorithm"],
        "tags": ["Graph","Shortest Path","Queue","Search Algorithm"],
        "url": "http://localhost:4000/algorithm/SPFA/",
        "teaser":null},{
        "title": "다익스트라 알고리즘(Dijkstra Algorithm)- 예정 포스트",
        "excerpt":" ","categories": ["Algorithm"],
        "tags": ["Shortest Path"],
        "url": "http://localhost:4000/algorithm/Dijkstra/",
        "teaser":null},{
        "title": "연결 리스트(Linked List)",
        "excerpt":"Linked List  배열과 같이 선형 자료구조 이다.  원소들이 메모리 공간상에 연속적으로 저장 되어있지 않고, 그림과 같이 각 원소들이 포인터로 링크되어 있는 자료 구조이다.   하나의 원소를 노드라고 표현하고, 데이터를 저장하는 Data 필드와 그 다음 노드를 가리키는 Next필드로 구성되어 있다.   추가적으로 연결 리스트의 맨 처음 노드를 가리키는 헤드라는 포인터를 두고 있다.   그림을 참고하자.      배열과 비교해 연결 리스트가 가지는 장점   베열은 유사한 타입의 선형 데이터를 저장하는데 사용될 수 있다.  하지만 배열은 다음과 같은 제한을 가진다.      배열 크기가 고정되어 있다.  그래서 우리는 배열의 상한크기를 미리 알고 있어야 한다.  또한, 일반적으로, 할당된 메모리는 사용량에 관계없이 상한과 동일하다.   배열에 원소를 삽입하는 연산은 연결 리스트와 비교해 다소 비용이 많이든다.  원소를 저장할 공간이 만들어져야 하며, 특정 위치에 값을 삽입한다면 다른 원소를 한칸 씩 쉬프트 해야할 수도 있다.   연결 리스트가 배열과 비교해 가지는 장점      동적 크기  연결 리스트의 크기는 고정되어 있지 않고, 프로그램 실행중에 동적으로 변할 수 있다.  운영체제가 프로그램상의 메모리 공간을 허용하는 한 연결 리스트의 크기를 신경 쓸 필요가 없다.   원소의 삽입 및 삭제가 수월하다.  배열과 비교해 연결 리스트의 삽입 삭제는 노드들 간에 포인터만 설정해주면 된다.  새로운 원소를 위해 다른 원소를 위치를 쉬프트 한다든지의 수고를 할 필요가 없다.   배열과 비교해 연결 리스트가 가지는 단점           임의 접근이 되지 않는다.  배열은 각 원소를 index 번호로 바로 접근할 수 있는 반면(Random access), 연결 리스트에서는 처음 노드부터 순차적으로 탐색해야 한다.            포인터로 인한 메모리상 추가적인 공간이 필요하다.  배열과 달리 연결 리스트는 다른 노드를 가리키는 포인터(Next)공간을 추가로 요구한다.            캐시 친화적이지 않다.  배열 요소는 연속된 메모리 공간상에 위치하므로 참조 지역성이 좋은 반면, 연결 리스트는 요소들이 링크되어 있고 메모리 상에 흩어져 존재하므로 참조 지역성이 없다.       Representation   연결 리스트는 첫번째 노드를 가리키는 헤드를 가지고 있다.  연결 리스트에 노드가 없다면 헤드는 NULL이다.      노드는 두개의 부분으로 구성되어 있다.      Data - 데이터를 저장하는 필드(Integer, Double, String, Object …)   Next(Pointer Or Reference) - 다음 노드를 참조하는 필드   다음은 자바로 구현한 연결 리스트 클래스이다.   class LinkedList {      Node head; // head of the list         /* Linked list Node*/     static class Node {          int data;          Node next;          Node(int d)          {              data = d;              next = null;          } // Constructor      }  }   연결 리스트는 하나의 클래스로 표현되고 있고, 노드는 그 안의 분리된 클래스로 표현되고 있다.   연결 리스트 클래스의 헤드는 노드를 참조하므로 노드 클래스 타입으로 선언 되어있다.   노드 클래스는 데이터를 저장하는 data필드와 다음 노드를 참조할 수 있는 next필드를 가지고 있다. 또한 생성자를 가지고 있는데, 이는 노드가 생성될 때 데이터를 d로 초기화하고, 포인터를 null로 초기화하는 역할을 한다.     위 클래스를 이용하여 노드 3개를 가진 연결리스트를 자바로 구현해 보자.   // A simple Java program to introduce a linked list  class LinkedList {      Node head; // head of list         /* Linked list Node.  This inner class is made static so that         main() can access it */     static class Node {          int data;          Node next;          Node(int d)          {              data = d;              next = null;          } // Constructor      }         /* method to create a simple linked list with 3 nodes*/     public static void main(String[] args)      {          /* 빈 연결 리스트 생성 */         LinkedList llist = new LinkedList();             llist.head = new Node(1);          Node second = new Node(2);          Node third = new Node(3);             /* 3개의 노드가 메모리상에 할당된다.            head와 second, third가 각 노드를 참조한다.              llist.head        second              third               |                |                  |               |                |                  |           +----+------+     +----+------+     +----+------+           | 1  | null |     | 2  | null |     |  3 | null |           +----+------+     +----+------+     +----+------+ */            llist.head.next = second; // 첫번째 노드와 두번째 노드를 연결한다.            /*  첫번째 노드의 next가 두번째 노드를 참조한다.             llist.head        second              third              |                |                  |              |                |                  |          +----+------+     +----+------+     +----+------+          | 1  |  o--------&gt;| 2  | null |     |  3 | null |          +----+------+     +----+------+     +----+------+ */            second.next = third; // 세번째 노드와 두번째 노드를 연결한다.            /*  두번째 노드의 next가 세번째 노드를 참조한다.             llist.head        second              third              |                |                  |              |                |                  |          +----+------+     +----+------+     +----+------+          | 1  |  o--------&gt;| 2  |  o--------&gt;|  3 | null |          +----+------+     +----+------+     +----+------+ */     }  }    Inserting a node   연결 리스트에 노드를 추가 해보자.   노드를 추가하는 데에는 3 가지 케이스가 있다.      연결 리스트 맨 앞에 추가   특정 노드 뒤에 추가   연결 리스트 맨 뒤에 추가   연결 리스트 맨 앞에 추가      추가할 노드를 할당한다.   노드에 데이터를 넣는다.   추가할 노드의 next 포인터가 첫번째 노드를 참조하게 한다.   헤드가 추가한 노드를 참조하게 함으로써 처음 노드임을 가리킨다.      다음은 위의 연산을 구현한 자바 메소드이다.   /* This function is in LinkedList class. Inserts a     new Node at front of the list. */ public void push(int new_data)  {      /* 1 &amp; 2: Allocate the Node &amp;                Put in the data*/     Node new_node = new Node(new_data);         /* 3. Make next of new Node as head */     new_node.next = head;         /* 4. Move the head to point to new Node */     head = new_node;  }    이 연산의 시간복잡도는 O(1)이 된다.   특정 노드 뒤에 추가      특정 노드가 null인지 확인한다.  null이면 아무런 작업이 수행되지 않는다.   추가할 노드를 할당한다.   추가할 노드에 데이터를 넣는다.   추가할 노드가 특정노드가 참조하는 다음 노드를 참조하게 한다.   특정 노드가 추가할 노드를 참조하게 한다.      다음은 위의 연산을 구현한 자바 메소드이다.   /* This function is in LinkedList class.     Inserts a new node after the given prev_node. */ public void insertAfter(Node prev_node, int new_data)  {      /* 1. Check if the given Node is null */     if (prev_node == null)      {          System.out.println(\"The given previous node cannot be null\");          return;      }         /* 2. Allocate the Node &amp;         3. Put in the data*/     Node new_node = new Node(new_data);         /* 4. Make next of new Node as next of prev_node */     new_node.next = prev_node.next;         /* 5. make next of prev_node as new_node */     prev_node.next = new_node;  }    이 연산의 시간복잡도는 O(1)이 된다.   연결 리스트 맨 뒤에 추가      추가할 노드를 할당한다.   추가할 노드에 데이터를 넣는다.   연결 리스트가 null이면, 헤드가 추가할 노드를 참조하게 함으로써 연산을 끝낸다.   그렇지 않다면, 처음 노드부터 탐색을 시작하여 마지막 노드를 찾는다.   마지막 노드가 추가할 노드를 참조하게 한다.      다음은 위의 연산을 구현한 자바 메소드이다.    // Appends a new node at the end.  public void append(int new_data)  {      /* 1. Allocate the Node &amp;         2. Put in the data */     Node new_node = new Node(new_data);         /* 3. If the Linked List is empty, then make the             new node as head */     if (head == null)      {          head = new Node(new_data);          return;      }      /* 4. Else traverse till the last node */     Node last = head;       while (last.next != null)          last = last.next;         /* 5. Change the next of last node */     last.next = new_node;      return;  }    이 연산의 시간복잡도는 탐색으로 인하여 O(n)이 된다.  연결 리스트의 끝 노드의 정보를 가지고 있는 tail 포인터를 둔다면, 이 연산의 시간복잡도는 O(1)이 된다.   다음은 위 연산을 포한한 예제 자바 코드이다.   // A complete working Java program to demonstrate all insertion methods  // on linked list  class LinkedList  {      Node head;  // head of list         /* Linked list Node*/     class Node      {          int data;          Node next;          Node(int d) {data = d; next = null; }      }         /* Inserts a new Node at front of the list. */     public void push(int new_data)      {          /* 1 &amp; 2: Allocate the Node &amp;                    Put in the data*/         Node new_node = new Node(new_data);             /* 3. Make next of new Node as head */         new_node.next = head;             /* 4. Move the head to point to new Node */         head = new_node;      }         /* Inserts a new node after the given prev_node. */     public void insertAfter(Node prev_node, int new_data)      {          /* 1. Check if the given Node is null */         if (prev_node == null)          {              System.out.println(\"The given previous node cannot be null\");              return;          }             /* 2 &amp; 3: Allocate the Node &amp;                    Put in the data*/         Node new_node = new Node(new_data);             /* 4. Make next of new Node as next of prev_node */         new_node.next = prev_node.next;             /* 5. make next of prev_node as new_node */         prev_node.next = new_node;      }            /* Appends a new node at the end.  This method is          defined inside LinkedList class shown above */     public void append(int new_data)      {          /* 1. Allocate the Node &amp;             2. Put in the data */         Node new_node = new Node(new_data);             /* 3. If the Linked List is empty, then make the                new node as head */         if (head == null)          {              head = new Node(new_data);              return;          }             /* 4. Else traverse till the last node */         Node last = head;           while (last.next != null)              last = last.next;             /* 5. Change the next of last node */         last.next = new_node;          return;      }         /* This function prints contents of linked list starting from          the given node */     public void printList()      {          Node tnode = head;          while (tnode != null)          {              System.out.print(tnode.data+\" \");              tnode = tnode.next;          }      }         /* Driver program to test above functions. Ideally this function         should be in a separate user class.  It is kept here to keep         code compact */     public static void main(String[] args)      {          /* Start with the empty list */         LinkedList llist = new LinkedList();             // Insert 6.  So linked list becomes 6-&gt;NUllist          llist.append(6);             // Insert 7 at the beginning. So linked list becomes          // 7-&gt;6-&gt;NUllist          llist.push(7);             // Insert 1 at the beginning. So linked list becomes          // 1-&gt;7-&gt;6-&gt;NUllist          llist.push(1);             // Insert 4 at the end. So linked list becomes          // 1-&gt;7-&gt;6-&gt;4-&gt;NUllist          llist.append(4);             // Insert 8, after 7. So linked list becomes          // 1-&gt;7-&gt;8-&gt;6-&gt;4-&gt;NUllist          llist.insertAfter(llist.head.next, 8);             System.out.println(\"\\nCreated Linked list is: \");          llist.printList();      }  }  // This code is contributed by Rajat Mishra    Output: Created Linked list is:  1  7  8  6  4   Deleting a node   이번에는 연결 리스트에서 특정 키 값을 갖고 있는 노드를 삭제 해보자.      삭제될 노드를 참조할 temp 포인터와 그 이전 노드를 참조하는 prev 포인터를 둔다.   temp는 헤드를 참조하게 함으로써 처음 노드를 참조하게 한다.   만약 삭제될 노드가 처음 노드라면, 헤드가 temp 다음 노드를 참조하게 하고 연산을 끝낸다.   그렇지 않다면, 삭제할 키 값을 가지고 있는 노드를 탐색한다.   탐색함에 따라 삭제될 노드와 그 이전 노드 정보를 가지고 있는 temp, prev 포인터들을 갱신한다.   temp가 null이거나 삭제될 키 값을 가진 노드를 찾으면 반복문을 빠져나온다.   temp가 null이면 원하는 키값을 가진 노드를 찾지 못한 것이므로 아무런 작업도 하지 않고 연산을 끝낸다.   그렇지 않다면 찾은 것이므로, prev 포인터가 temp.next 참조하게 함으로써 작업을 끝낸다.      다음은 위의 연산을 구현한 자바 메소드이다.    /* Given a key, deletes the first occurrence of key in linked list */     void deleteNode(int key)      {          // 1 &amp; 2. Store head node to temp, prev         Node temp = head, prev = null;             // 3. If head node itself holds the key to be deleted          if (temp != null &amp;&amp; temp.data == key)          {              head = temp.next; // Changed head              return;          }             // 4. Search for the key to be deleted, keep track of the          // previous node as we need to change temp.next          while (temp != null &amp;&amp; temp.data != key) // 6.         {              // 5. keep track of the previous node             //    as we need to change temp.next              prev = temp;                     temp = temp.next;          }                 // 7. If key was not present in linked list          if (temp == null) return;             // 8. Unlink the node from linked list          prev.next = temp.next;      }     이 연산의 시간복잡도는 O(n)이 된다.  순수 삭제연산은 O(1)이지만, 삭제될 키 값을 찾아 탐색하는 연산이 추가되었으므로 O(n)이 된다.   특정 키 값의 노드 찾기   연결 리스트에서 특정 키 값 x를 가진 노드를 찾아보자.   search 메소드는 키 값 x를 가진 노드가 존재하면 true, 존재하지 않으면 false를 리턴한다.      리스트를 순회할 current를 헤드로 초기화한다.   current가 null 아닐 때 까지 반복한다.  null이면 while 빠져나와 false 리턴하고 연산을 끝낸다.   current가 참조하는 노드의 데이터가 x라면 true 리턴하고 연산을 끝낸다.   그렇지 않다면 다음 노드를 참조하고 2번으로 다시 간다.   다음은 위의 연산을 구현한 자바 메소드이다.   //Checks whether the value x is present in linked list      public boolean search(Node head, int x)      {          Node current = head;    // 1 포인터 초기화         while (current != null) // 2. current가 null 아닐 때 까지 반복한다         {              if (current.data == x)                  return true;    //3. 찾았다             current = current.next; // 4. 다음 노드를 참조한다         }          return false;    // 데이터를 찾지 못하였다     }    다음은 위 연산을 포한한 예제 자바 코드이다.   // Iterative Java program to search an element  // in linked list     //Node class  class Node  {      int data;      Node next;      Node(int d)      {          data = d;          next = null;      }  }     //Linked list class  class LinkedList  {      Node head;    //Head of list         //Inserts a new node at the front of the list      public void push(int new_data)      {          //Allocate new node and putting data          Node new_node = new Node(new_data);             //Make next of new node as head          new_node.next = head;             //Move the head to point to new Node          head = new_node;      }         //Checks whether the value x is present in linked list      public boolean search(Node head, int x)      {          Node current = head;    //Initialize current          while (current != null)          {              if (current.data == x)                  return true;    //data found              current = current.next;          }          return false;    //data not found      }         //Driver function to test the above functions      public static void main(String args[])      {             //Start with the empty list          LinkedList llist = new LinkedList();             /*Use push() to construct below list          14-&gt;21-&gt;11-&gt;30-&gt;10  */         llist.push(10);          llist.push(30);          llist.push(11);          llist.push(21);          llist.push(14);             if (llist.search(llist.head, 21))              System.out.println(\"Yes\");          else             System.out.println(\"No\");      }  }  // This code is contributed by Pratik Agarwal    Output: Yes  연결 리스트 연산들의 시간복잡도  시간복잡도 - 최악 기준        접근     검색      삽입     삭제\t O(n)    O(n)\t O(1)\t O(1)\t    References  GeeksforGeeks  ","categories": ["Data Structure"],
        "tags": ["programming","Data Structure","Linked List"],
        "url": "http://localhost:4000/data%20structure/LinkedList/",
        "teaser":null},{
        "title": "스택(Stack)",
        "excerpt":"스택(Stack)  스택은 원소의 특정한 순서를 유지하고 특정 연산을 가지고 있는 선형 자료구조이다.   스택은 후입선출의 선형 자료 구조로서, 한쪽 끝에서만 삽입 및 삭제가 수행된다.  나중에 들어간 원소가 먼저 들어온 원소보다 먼저 나간다 하여 후입선출이라 불리게 된다.   스택은 또한 Top이라 불리는 포인터를 가지고 있는데 이는, 스택의 맨 위의 원소를 가리킨다.(그림상)      스택의 기본 연산   스택이 가지고 있는 연산들을 보자.   Push   스택에 원소를 삽입한다.  스택이 Full이라면 Overflow 에러가 난다.      Notice: 새로운 원소가 삽입됨에 따라 Top이 10을 가리키고 있다.   Pop - 스택에서 원소를 삭제한다.   스택에서 원소를 삭제한다.  스택이 빈 공간이면, Underflow 에러가 난다.      Notice: 기존 원소가 삭제됨에 따라 Top이 93을 가리키고 있다.   Peek  스택에서 Top 가리키고 있는 원소를 반환한다.   Notice: 원소가 삽입, 삭제 되는 것이 아닌 원소 반환이므로 Top의 위치는 변화가 없다.      isEmpty  스택이 빈 공간이라면 true, 아니라면 false를 반환한다.   스택의 응용   스택은 많은 곳에서 응용되어 쓰인다.      괄호의 균형성 검사. ex) (()) 짝이 맞는지   웹브라우저의 앞으로 가기 또는 뒤로 가기   그래프 알고리즘 중에서 위상정렬이나 강한연결요소   대표적 백트래킹 문제 - N-Queen, Knight tour, rat in a maze, sudoku   스택을 이용한 여러 알고리즘 문제 - 하노이 탑, 트리순회, 히스토그램 면적 등   중위식 표기법의 후위식 표기법으로의 변환   구현   스택을 구현하는 데에는 크게 두 가지 방법이 있다.      배열을 이용   연결 리스트를 이용   먼저 배열을 이용한 스택 구현을 보자.   배열을 이용한 스택 구현   스택 클래스의 프로퍼티와 생성자   스택의 최대 크기를 결정하는 MAX 상수, top 포인터, 원소를 담을 배열을 선언한다.  스택이 생성되면 top을 -1로 초기화할 생성자를 선언한다.  class Stack {      static final int MAX = 1000;      int top;      int a[] = new int[MAX]; // Maximum size of Stack       public Stack() // Constructor of Stack Class     {          top = -1;      }  }   스택 클래스의 메서드 - push   스택에 원소를 삽입하는 메서드이다.   top이 배열의 끝(MAX-1)을 가리키고 있으면 스택은 다 차서 더 이상 원소 삽입이 안되므로 에러 메세지를 출력하고 false를 리턴한다.   그렇지 않다면 top을 한 칸 올리고 그 자리에 원소를 삽입한다.   boolean push(int x)  {      if (top &gt;= (MAX - 1)) {          System.out.println(\"Stack Overflow\");          return false;      }      else {          a[++top] = x;          System.out.println(x + \" pushed into stack\");          return true;      }  }    스택 클래스의 메서드 - pop   스택에서 원소를 삭제하는 메서드이다.   top이 0보다 작으면 스택은 빈 공간이므로 에러 메세지를 출력하고 false를 리턴한다.   그렇지 않다면 top이 가리키는 원소를 리턴하고 top은 한 칸 감소한다.   int pop()  {      if (top &lt; 0) {          System.out.println(\"Stack Underflow\");          return 0;      }      else {          int x = a[top--];          return x;      }  }    스택 클래스의 메서드 - peek   스택의 top이 가리키는 원소를 반환하는 메서드이다.   top이 0보다 작으면 스택은 빈 공간이므로 에러 메세지를 출력하고 false를 리턴한다.   그렇지 않다면 top이 가리키는 원소를 리턴한다.   int peek()  {      if (top &lt; 0) {          System.out.println(\"Stack Underflow\");          return 0;      }      else {          int x = a[top];          return x;      }  }    스택 클래스의 메서드 - isEmpty   스택이 빈 공간인지 확인하는 메서드이다.   top이 0보다 작으면 스택은 빈 공간이므로 true 리턴   그렇지 않다면 원소가 있다는 뜻이므로 false 리턴   int peek()  boolean isEmpty()  {      return (top &lt; 0);  }    전체 코드   다음은 배열을 이용하여 스택을 구현한 전체 코드이다.   /* Java program to implement basic stack  operations */ class Stack {      static final int MAX = 1000;      int top;      int a[] = new int[MAX]; // Maximum size of Stack         boolean isEmpty()      {          return (top &lt; 0);      }      Stack()      {          top = -1;      }         boolean push(int x)      {          if (top &gt;= (MAX - 1)) {              System.out.println(\"Stack Overflow\");              return false;          }          else {              a[++top] = x;              System.out.println(x + \" pushed into stack\");              return true;          }      }         int pop()      {          if (top &lt; 0) {              System.out.println(\"Stack Underflow\");              return 0;          }          else {              int x = a[top--];              return x;          }      }         int peek()      {          if (top &lt; 0) {              System.out.println(\"Stack Underflow\");              return 0;          }          else {              int x = a[top];              return x;          }      }  }     // Driver code  class Main {      public static void main(String args[])      {          Stack s = new Stack();          s.push(10);          s.push(20);          s.push(30);          System.out.println(s.pop() + \" Popped from stack\");      }  }   Output : 10 pushed into stack 20 pushed into stack 30 pushed into stack 30 popped from stack   연결 리스트 이용한 스택 구현   연결 리스트를 이용한 스택 클래스 표현   스택의 top을 표현할 StackNode 타입의 root 레퍼런스 가지고 있다.   또한, 스택 원소 즉, 노드를 표현할 내부 클래스를 가지고 있다.  내부 클래스인 스택 노드 클래스는 데이터를 담을 data 변수, 다음 원소를 가리키는 next 레퍼런스 변수를 가지고 있다.   public class StackAsLinkedList {     StackNode root;       static class StackNode {          int data;          StackNode next;          StackNode(int data) {              this.data = data;          }      }  }   스택 클래스의 메서드 - push   데이터를 받아 노드를 할당한다.   스택이 빈 공간이면 단순히 root가 새로 생성된 노드를 가리키게 한다.   빈 공간이 아니라면 임시 레퍼런스 변수 temp가 root를 가리키게한다.  root는 새로 생성된 노드를 가리키게 하고, 새로 생성된 노드는 temp를 가리키게 한다.   public void push(int data)  {      StackNode newNode = new StackNode(data);       if (root == null) {          root = newNode;      }      else {          StackNode temp = root;          root = newNode;          newNode.next = temp;      }      System.out.println(data + \" pushed to stack\");  }    스택 클래스의 메서드 - pop   스택이 빈 공간이면 에러 메세지를 출력하고 int 최소 값을 반환한다.  (여기서는 Integer.MIN_VALUE는 빈 공간임을 표시하는 수로 쓰였다.)   빈 공간이 아니라면 popped 변수에 값을 담고, root는 다음 변수를 가리키게 한다.  popped을 리턴한다.   public int pop()  {      int popped = Integer.MIN_VALUE;      if (root == null) {          System.out.println(\"Stack is Empty\");      }      else {          popped = root.data;          root = root.next;      }      return popped;  }    스택 클래스의 메서드 - peek   스택이 빈 공간이면 에러 메세지를 출력하고 int 최소 값을 반환한다.  (여기서도 Integer.MIN_VALUE는 빈 공간임을 표시하는 수로 쓰였다.)   빈 공간이 아니라면 root가 가리키는 값을 리턴한다.   public int peek()  {      if (root == null) {          System.out.println(\"Stack is empty\");          return Integer.MIN_VALUE;      }      else {          return root.data;      }  }    스택 클래스의 메서드 - isEmpty   스택이 빈 공간 즉, root가 null이면 true 리턴, 아니라면 false 리턴   public boolean isEmpty()  {      if (root == null) {          return true;      }      else         return false;  }    전체 코드   다음은 연결 리스트를 이용하여 스택을 구현한 전체 코드이다.   public class StackAsLinkedList {         StackNode root;         static class StackNode {          int data;          StackNode next;             StackNode(int data)          {              this.data = data;          }      }         public boolean isEmpty()      {          if (root == null) {              return true;          }          else             return false;      }         public void push(int data)      {          StackNode newNode = new StackNode(data);             if (root == null) {              root = newNode;          }          else {              StackNode temp = root;              root = newNode;              newNode.next = temp;          }          System.out.println(data + \" pushed to stack\");      }         public int pop()      {          int popped = Integer.MIN_VALUE;          if (root == null) {              System.out.println(\"Stack is Empty\");          }          else {              popped = root.data;              root = root.next;          }          return popped;      }         public int peek()      {          if (root == null) {              System.out.println(\"Stack is empty\");              return Integer.MIN_VALUE;          }          else {              return root.data;          }      }         public static void main(String[] args)      {             StackAsLinkedList sll = new StackAsLinkedList();             sll.push(10);          sll.push(20);          sll.push(30);             System.out.println(sll.pop() + \" popped from stack\");             System.out.println(\"Top element is \" + sll.peek());      }  }   Output : 10 pushed to stack 20 pushed to stack 30 pushed to stack 30 popped from stack Top element is 20   스택 연산들의 시간복잡도  시간복잡도 - 최악 기준        push    pop      peek    isEmpty\t O(1)    O(1)\t O(1)\t O(1)\t    References  GeeksforGeeks  ","categories": ["Data Structure"],
        "tags": ["programming","Data Structure","Linked List","Array","Stack"],
        "url": "http://localhost:4000/data%20structure/Stack/",
        "teaser":null},{
        "title": "버블소트(Bubble Sort)",
        "excerpt":"Bubble(버블 정렬)   비교 기반 정렬 알고리즘이다.   정렬이 실행되면서 마치 형태가 거품이 수면위로 떠오르는 것 같은 모양을 한다고 하여 붙여진 이름이다.   인접한 두 원소를 비교하여 기준에 따라 스왑하고, 한 칸씩 옆으로 가면서 이를 n번째 원소까지 반복한다.   이를 모든 원소에 대해 n번 반복한다.  (최적화를 하면 배열의 원소 위치상태에 따라 횟수가 n번 보다 낮아질 수 있다.)   다른 O(nlongn)의 성능을 내는 정렬 알고리즘에 비해 성능이 좋지 않으므로 실무에서는 사용되지 않고 교육용 목적으로 사용 되어진다.   더 효율적인 정렬 알고리즘인 팀소트(Timsort)나 머지소트(Merge sort)가 인기있는 프로그래밍 언어(java, python)의 내장 정렬 라이브러리로 사용되고 있다.    Algorithm   밑의 애니메이션을 먼저 보고 알고리즘을 읽으면 이해가 빠를 수 있다.      처음 원소를 시작으로 n번째 원소까지 차례대로 인접한 원소와 오른쪽으로 비교하며 스왑을 진행한다.   n번째 원소와 비교가 끝이나면 n번째 원소는 정렬이 완료된 것이다.   다시 처음 원소부터 n-1번째 원소까지 인접한 원소와 비교하며 필요하면 스왑을 한다.   n-1번째 원소와 비교가 끝이나면 n-1번째 원소는 정렬이 완료된 것이다.   이를 반복하여, n-2..n-3..2번째 원소까지 정렬이 완료되면 알고리즘은 끝이난다.   Animation - Bubble sort     Analysis   버블소트는 최악과 평균 시간복잡도가 $O(n^2)$인 (2중 루프로 인해) 정렬 알고리즘이다.   최악과 평균 시간복잡도가 $O(nlog_{2}n)$인 실용적인 정렬 알고리즘 보다 성능이 좋지않고  시간복잡도가 $O(n^2)$인 삽입정렬도 버블소트보다는 빠르게 동작하기 때문에 버블소트는 다소 실용적인 정렬 알고리즘이 아니다.   다른 정렬들과 비교해(삽입정렬을 제외한) 버블소트의 최대 장점은 배열이 정렬되어 있는 것을 탐지해낼 수 있는 능력이다.   리스트가 정렬이 완료되어 있을 때의 버블정렬은 O(n)이다.   Step-by-step example   배열 [5 1 4 2 8]이 있다고 하자.   처음 원소부터 끝 원소까지 오름차순으로 버블소트를 이용하여 정렬하려고 한다.   첫번째 패스   ( 5 1 4 2 8 ) → ( 1 5 4 2 8 )   첫번째 원소와 두번째 원소를 비교한다, 5 &gt; 1 이므로 스왑한다.  ( 1 5 4 2 8 ) → ( 1 4 5 2 8 )   두번째 원소와 세번째 원소를 비교한다, 5 &gt; 4 이므로 스왑한다.  ( 1 4 5 2 8 ) → ( 1 4 2 5 8 )   세번째 원소와 네번째 원소를 비교한다, 5 &gt; 2 이므로 스왑한다.  ( 1 4 2 5 8 ) → ( 1 4 2 5 8 )   네번째 원소와 다섯번째 원소를 비교한다, 5 &lt; 8 이므로 그대로 둔다.  첫번째 패스가 끝났다.  두번째 패스  ( 1 4 2 5 8 ) → ( 1 4 2 5 8 )   첫번째 원소와 두번째 원소를 비교한다, 1 &lt; 4 이므로 그대로 둔다. ( 1 4 2 5 8 ) → ( 1 2 4 5 8 )   두번째 원소와 세번째 원소를 비교한다, 4 &gt; 2 이므로 스왑한다.  ( 1 2 4 5 8 ) → ( 1 2 4 5 8 )   세번째 원소와 네번째 원소를 비교한다, 4 &lt; 5 이므로 그대로 둔다. ( 1 2 4 5 8 ) → ( 1 2 4 5 8 )   첫번째 원소와 두번째 원소를 비교한다, 5 &lt; 8 이므로 그대로 둔다.  두번째 패스가 끝났다.  이제, 배열은 이미 오름차순으로 정렬이 완료되었다. 그러나, 알고리즘은 정렬이 완료되었는지 아직 모른다.  정렬이 완료되었는지 알기 위해선 하나의 패스를 더 거쳐야 한다.  (불리언 변수 하나를 두어 이를 알 수 있는데, 밑의 구현에서 알아본다.)  세번째 패스  ( 1 2 4 5 8 ) → ( 1 2 4 5 8 )   ( 1 2 4 5 8 ) → ( 1 2 4 5 8 )   ( 1 2 4 5 8 ) → ( 1 2 4 5 8 )   ( 1 2 4 5 8 ) → ( 1 2 4 5 8 )    세번째 패스가 끝났다.  스왑된 원소가 없으므로 알고리즘은 더 이상 패스를 수행하지 않는다.  알고리즘을 종료한다.   Implementation   다음은 버블소트를 의사코드로 구현한 것이다.   버블소트 의사코드 구현 (index is 0 base)   procedure bubbleSort(A : list of sortable items)     n := length(A) // 배열 길이, 원소 개수     repeat // 반복한다.         swapped = false // 스왑이 되었는지 여부         for i := 1 to n - 1 inclusive do // [1 ~ n-1]까지             /* 만약 두 원소가 순서에 어긋나면 */             if A[i - 1] &gt; A[i] then                 /* 스왑하고, 스왑되었다는 것을 체크한다. */                 swap(A[i - 1], A[i])                 swapped := true              end if         end for     // 스왑이 안되었을때 까지, 즉, swapped가 true면 repeat로 간다.     until not swapped end procedure   버블소트 최적화   n번째 패스가 끝이나면 n번째로 큰 원소는 이미 정렬이 완료되어 그자리에 위치가 변하지 않기에, 내부 루프는 매 패스마다, 0번째 부터 n번째 까지 원소를 비교할 필요가 없다.   한번의 패스가 끝이나면 n을 n-1로, 즉 1씩 줄여 쓸때없는 연산을 피할 수 있다.   procedure bubbleSort(A : list of sortable items)     n := length(A)     repeat         swapped := false         for i := 1 to n - 1 inclusive do             if A[i - 1] &gt; A[i] then                 swap(A[i - 1], A[i])                 swapped = true             end if         end for         // n을 1 감소시켜 다음번 패스 때 불필요한 연산을 하지 않는다.         n := n - 1     until not swapped end procedure   한가지 더 최적화를 해보자.   한 번의 패스로 하나 이상의 원소가 최종 정렬된 자리에 올 수 있다.  그렇다면 우리는 최종 정렬된 원소를 굳이 비교하지 않고 스킵할 수 있다.   다음은 이를 구현한 슈도 코드이다.   새로운 변수 newn을 주목하라.   procedure bubbleSort(A : list of sortable items)     n := length(A)     repeat         // newn: 몇 번째 원소까지 비교가 완료 되었는지         newn := 0         for i := 1 to n - 1 inclusive do             if A[i - 1] &gt; A[i] then                 swap(A[i - 1], A[i])                 newn := i             end if         end for         n := newn         // n이 1보다 작거나 같으면 반복문을 빠져 나온다.     until n ≤ 1 end procedure   [3 2 1 4 5]인 배열이 있다고 해보자.   첫번째 패스를 거치면  인덱스 0~4번 까지 비교를 하게 된다.  [2 1 3 4 5]가 된다.   이 때, newn은 2가 된다.  이는 2번 인덱스에서 마지막으로 스왑이 되었고, 그 이후로는 스왑이되지 않았다.  즉, 그 이후로는 정렬이 완료되었으니 정렬이 불필요하다는 것을 의미한다.   두번때 패스에서는  원래 대로라면 인덱스 0~3번 까지 비교를 하게 되겠지만  최적화를 거치면 첫번째 패스에서 newn은 2인 것을 아니까  인덱스 0~3, 0~2를 스킵하고, 0~1번 까지만 비교가 진행되게 된다.   이로서 불필요한 패스를 줄임으로서 최악 기준 약 50%의 성능 향상을 기대할 수 있다.   시간복잡도   최악 시간복잡도\t$O(n^2)$  최선 시간복잡도\t$O(n)$ - 배열이 이미 정렬 완료되었을 때  평균 시간복잡도\t$O(n^2)$   References   Bubble Sort - wikipedia  ","categories": ["Algorithm"],
        "tags": ["Sort","Array","Mathematics"],
        "url": "http://localhost:4000/algorithm/bubble-sort/",
        "teaser":null},{
        "title": "선형구조와 탐색(Linear Structure and Search)",
        "excerpt":"선형구조의 탐색   선형구조란 자료의 순서를 유일하게 결정할 수 있는 형태의 구조를 말한다. $i$번째 자료 를 탐색한 다음, $i+1$번째로 탐색 해야할 자료가 유일한 형태를 의미한다. 2차원, 3차원 구조라도 순서가 일정하게 정해져 있으면 이는 선형이라고 할 수 있다.   선형구조는 주로 배열과 리스트의 형태로 저장된다. 일반적으로 1차원 배열에 자료를 저장하는 1차원 선형구조와 2차원 이상의 배열에 자료가 저장이 되어있는 다차원 선형구조로 나눌 수 있다.   선형구조의 탐색은 선형구조로 저장된 자료들 중에서 원하는 것을 찾는 작업을 말한다. 선형구조를 탐색하는 방법은 기본적으로 순차탐색과 이분탐색이 있고, 이들을 적절히 응용한 탐색법도 만들어 사용할 수 있다. 이 단원에서는 순차탐색과 이분탐색을 익히고 이를 통하여 간단한 문제를 해결하는 실습을 한다.   순차탐색   순차탐색은 자료의 특성에 관계없이 사용할 수 있는 일반적인 방법으로 전체탐색기법의 한 방법이다. 첫 번째 원소로부터 시작하여 한 원소씩 차례로 다음 원소를 탐색해 나가는 방법으로 자료가 $n$개 있을 때의 계산량은 $O(n)$이다.   탐색 순서를 그림으로 나타내면 다음과 같다.      다음은 선형탐색을 구현한 소스코드이다.  public class LinearSearch {     public static boolean linearSearch(int S[], int k){         for (int i = 0; i &lt; S.length; i++) {             if (S[i] == k)                 return true;         }         return false;     }      public static void main(String[] args) {         int S[] = {5, 2, 6, 2, 1, 8};         int k = 4;         System.out.print(linearSearch(S, k));     } }   이분탐색   이분탐색은 배열에서 중간 원소를 선택하여 찾는 값과 비교하고 중간 원소의 값이 찾는 값보다 작다면 중간 원소를 기준으로 오른쪽을 탐색, 중간 원소의 값이 찾는 값보다 크다면 중간 원소를 기준으로 왼쪽을 탐색하는 기법이다. 이 알고리즘은 오름차순이나 내림차순으로 정렬된 선형구조에서 원하는 원소를 찾는 것으로 계산량은 $O(log_2n)$이다.      이분탐색의 탐색순서(원은 처음 접근하는 원소이고, 사각형은 찾은 곳의 값이 찾으려는 값보다 작으면 찾는 위치, 둥근 사각형은 그 값의 반대조건일 경우에 탐색하는 위치이다. 조건의 결과에 따라 왼쪽 또는 오른쪽 중 하나를 탐색하게 된다.)   다음은 이분탐색을 구현한 C++ 소스코드이다.  $S$에 $n$개의 원소를 입력받고, 그 중에 $k$가 있는지를 찾는 알고리즘이다.   // 이분탐색 - 반복 #include &lt;stdio.h&gt; int S[100], n, k; int find(int s, int e) {   while(s&lt;=e) {  // s가 e보다 작거나 같을 때 까지     int m=(s+e)/2; // 중간 원소     if(S[m]==k) return m; // 찾았다      // 탐색한 원소가 찾고자 하는 원소 보다 크다     //탐색한 원소의 왼쪽 배열 탐색     if(S[m]&gt;k) e=m‐1;      // 탐색한 원소가 찾고자 하는 원소 보다 작다     //탐색한 원소의 오른쪽 배열 탐색     else s=m+1;   }   return ‐1; // 원하는 원소를 찾지 못했다. } int main() {   scanf(\"%d%d\", &amp;n, &amp;k);   for(int i=0; i&lt;n; i++ )     scanf(\"%d\", &amp;S[i]);    printf(\"%d\\n\", find(0, n‐1));   return 0; }   다음은 재귀로 이분탐색을 구현한 java 소스코드이다.    // 이분탐색 - 재귀 import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.Arrays; import java.util.StringTokenizer;  public class BinarySearchRecur {     private static int S[] = new int[100];     private static int n, k; // 배열 크기, 찾고자 하는 원소      public static int find(int s, int e){         if (s &gt; e) // 원하는 원소를 찾지 못했다             return -1;         int m = (s+e)/2; // 중간 원소         if (S[m] == k) // 찾았다             return m;         else if (S[m] &lt; k) // 탐색한 원소가 찾고자 하는 원소 보다 작다             return find(m+1, e); //탐색한 원소의 오른쪽 배열 탐색         else               // 탐색한 원소가 찾고자 하는 원소 보다 크다             return find(s, m-1); //탐색한 원소의 왼쪽 배열 탐색     }      public static void main(String[] args) throws IOException {         BufferedReader br = new BufferedReader(new InputStreamReader(System.in));         StringTokenizer st = new StringTokenizer(br.readLine()); // n, k         n = Integer.parseInt(st.nextToken());         k = Integer.parseInt(st.nextToken());         st = new StringTokenizer(br.readLine()); // S array         Arrays.sort(S);         for (int i = 0; i &lt; n; i++) {             S[i] = Integer.parseInt(st.nextToken());         }         System.out.print(find(0, n-1)); // index 반환     } }  /*  Test Case ----------- input 5 19 3 4 2 19 4  output 3 ----------- input 5 10 3 4 2 19 4  output -1  */    기본적인 탐색방법을 익힐 수 있는 다음 문제들을 해결해보자.   최댓값   9개의 서로 다른 자연수가 주어질 때, 이들 중 최댓값을 찾고  그 값이 몇 번째 수 인지를 구하는 프로그램을 작성하시오.  예를 들어, 서로 다른 9개의 자연수가 각각 3, 29, 38, 12, 57, 74, 40, 85, 61 라면,   이 중 최댓값은 85이고, 이 값은 8번째 수이다.  ----------------------------------------  입력 첫째 줄부터 아홉째 줄까지 한 줄에 하나의 자연수가 주어진다.  주어지는 자연수 는 100보다 작다.  출력 첫째 줄에 최댓값을 출력하고, 둘째 줄에 최댓값이  몇 번째 수인지를 출력한다.  입력 예      출력 예 3          85 29         8 38 12 57 74  40  85  61   이 문제는 자료를 1차원 배열에 저장한 후 반복문을 이용하여 전체탐색법을 구현하면 쉽게 구할 수 있다. 전체탐색을 하더라도 탐색해야할 자료의 수가 9개뿐이므로 충분히 빠른 시간 내에 해를 구할 수 있는 기본적인 문제이다.   따라서 반복문을 구현하는 연습을 할 수 있는 문제로 이 문제를 해결하는 방법이 다른 문제들을 해결하는 도구로 많이 활용될 수 있으므로 꼭 익혀둘 수 있도록 한다.   일단 먼저 문제해결 아이디어를 생각하자. 최종적으로 출력할 해를 변수 ans로 두고, 최댓값의 인덱스를 저장할 변수를 index로 설정한다.   먼저 모든 자료를 탐색하기 전에 ans를 모든 원소들 보다 작은 값으로 설정한다. 이 문제에서는 100 이하의 자연수가 데이터의 정의역이므로, 0으로 설정하면 된다. 다음 으로 첫 번째 자료부터 마지막 자료까지 하나씩 검사해가며 현재까지 ans보다 더 큰 값이 나타나면 ans를 갱신하고, index값도 갱신한다.   마지막 자료까지 탐색을 마치면, ans와 index를 출력하면 된다. 이 과정을 입출력 예를 통해서 알아보자.            이와 같이 배열을 선형으로 전체탐색을 하면서 최댓값을 구할 수 있다. 이 방법은 가장 기본적인 방법 중 하나로 다른 알고리즘에 많이 응용되는 방법이다.   이를 프로그램으로 구현하면 다음과 같다.   #include &lt;stdio.h&gt;  #define MAXN 9 int ans, A[MAXN+1];  void solve(void) {   for(int i=1; i&lt;10; i++) {     scanf(\"%d\", A+i);     if(A[ans]&lt;A[i]) ans=i;    } } int main() {   solve();   printf(\"%d\\n%d\\n\", A[ans], ans);   return 0; }   ans, index를 하나의 변수 ans로 처리하고 있다. 그리고 9행에서 입력 받을 때 “&amp;A[i]” 대신 “A+i”를 활용하고 있다. 이러한 코딩 스타일도 자주 활용되는 방법으로 배열과 포인터를 이해하면 위와 같이 사용할 수 있음을 알 수 있다. 이와 같을 때에는 특수문자로 인한 오타의 확률도 줄일 수 있으므로 다양한 방법을 익힐 수 있도록 하자.   3의 배수 게임   3의 배수 게임을 하던 정올이는 3의 배수 게임에서 잦은 실수로  계속해서 벌칙을 받게 되었다. 3의 배수 게임의 왕이 되기 위한 마스터 프로그램을 작성해 보자.  ** 3의 배수 게임이란?  여러 사람이 순서를 정해 순서대로 수를 부르는 게임이다. 만약 3의 배수를 불러야 하는 상황이라면, 그 수 대신 \"박수\" 를 친다.  ----------------------------------------------  입력 첫 째 줄에 하나의 정수 n이 입력된다(n은 10000미만의 자연수이다.). 출력 1부터 그 수까지 순서대로 공백을 두고 수를 출력하는데,  3 또는 6 또는 9인 경우 그 수 대신 영문 대문자 X 를 출력한다.  입력 예      출력 예 7          1 2 X 4 5 X 7   이 문제도 앞선 문제와 마찬가지로 단순히 반복문을 이용하여 전체탐색법으로 해결할 수 있다. 단지 이 문제는 특정 값을 찾거나 하는 것이 아니라 전체 데이터를 읽으면서 특정 자료가 있으면 변경한다는 점은 다르나 전반적으로 같은 방법으로 해결할 수 있다. 이 문제에서 특정 자료란 입력된 숫자가 3의 배수일 경우를 말한다.   임의의 변수 n이 3의 배수인지 판정하는 가장 일반적인 방법은 다음과 같은 방법을 이용한다.   n % 3 == 0  1부터 n까지 1씩 증가하여 탐색하면서 각 수가 3의 배수인지 판정하여 3의 배수이면 “X”를 아니면 그 수를 출력하도록 작성하면 쉽게 해결할 수 있다.   이 문제를 해결한 예시는 다음과 같다.   #include &lt;stdio.h&gt;  int n; void solve(void) {   for(int i=1; i&lt;=n; i++) {     if(i%3==0) printf(\"X \");     else printf(\"%d \", i);   } } int main() {   scanf(\"%d\", &amp;n); s   solve();   return 0; }   linear structure search   n개로 이루어진 정수 집합에서 원하는 수의 위치를 찾으시오.  단, 입력되는 집합은 오름차순으로 정렬되어 있으며, 같은 수는 없다.  -------------------------------------------  입력 첫 줄에 한 정수 n이 입력된다. 둘째 줄에 n개의 정수가 공백으로 구분되어 입력된다. 셋째 줄에는 찾고자 하는 수가 입력된다. (단, 2 &lt;= n &lt;= 1,000,000, 각 원소의 크기는 100,000,000을 넘지 않는다.)  출력 찾고자 하는 원소의 위치를 출력한다. 없으면 -1을 출력한다.  입력 예                       출력 예 8                           1 2 3 5 7 9 11 15 11        7 11  3 2 5 7                       -1 3                 이 문제는 앞에서 다룬 이분탐색의 예제 프로그램을 거의 그대로 활용할 수 있는 문제이다.   이분탐색으로 풀어보자.   이분탐색 알고리즘   배열을 A라고 할 때, A[m] == k 인 경우와 A[m] &gt; k, A[m] &lt; k인 경우로 나누어 처리 하는 방법으로 문제를 해결할 수 있다.   탐색 범위를 [s, e]로 정한 다음, 이분탐색을 진행한다. (이분탐색 - 반복)      s &lt;= e를 만족할 때까지(만족하지 않으면 3번으로 간다), 가운데 위치의 값을 m( (s+e)/2 )으로 설정하고 탐색 진행.   A[m] == k인 경우, 찾았으므로 위치를 반환한다. (예제에서는 m+1)  A[m] &gt; k인 경우, 가운데 위치의 값이 찾고자 하는 값보다 크므로 탐색 범위를[s, m-1]로 하여 다시 이분탐색(1번으로 간다)  A[m] &lt; k인 경우, 가운데 위치의 값이 찾고자 하는 값보다 작으므로 탐색 범위를[m+1, e]로 하여 다시 이분탐색(1번으로 간다)   s &gt; e인 경우, 원하는 값이 없으므로 -1을 반환한다.   그림과 함께 자세한 과정을 보자.         위 방법을 소스코드로 작성하면 다음과 같다.   #include &lt;stdio.h&gt; int n, k, A[1000001];  int solve(int s, int e) {   int m;    while(s&lt;=e) {     m=(s+e)/2;      if(A[m]==k)       return m+1;      if(A[m]&lt;k) s=m+1;      else e=m‐1;   }   return ‐1; } int main() {   scanf(\"%d\",&amp;n);    for(int i=0; i&lt;n; i++ )     scanf(\"%d\", A+i);    scanf(\"%d\",&amp;k);    printf(\"%d\\n\", solve(0, n‐1));    return 0; }   위 소스코드를 다음과 같은 재귀함수로도 만들 수 있다. 재귀함수는 매우 다양한 응용이 가능하므로 이해해두면 많은 도움이 된다.   #include &lt;stdio.h&gt; int n, k, A[1000001];  int solve(int s, int e) {   if(s&gt;e)      return ‐1;   int m=(s+e)/2;    if(A[m]==k)     return m+1;    if(A[m]&lt;k)     return solve(m+1, e);    else     return solve(s, m‐1); } int main() {   scanf(\"%d\",&amp;n);    for(int i=0; i&lt;n; i++ )     scanf(\"%d\", A+i);    scanf(\"%d\",&amp;k);    printf(\"%d\\n\", solve(0, n‐1));    return 0; }   References      문제해결을 위한 창의적 알고리즘  ","categories": ["Algorithm"],
        "tags": ["이분탐색","순차탐색","Data structure","programming"],
        "url": "http://localhost:4000/algorithm/%EC%84%A0%ED%98%95%EA%B5%AC%EC%A1%B0%EC%9D%98-%ED%83%90%EC%83%89/",
        "teaser":"http://localhost:4000/assets/images/creativealgorithm43.png"},{
        "title": "Huddle landing page with alternating feature blocks",
        "excerpt":"Frontend Mentor - Huddle landing page with alternating feature blocks   7일 동안 하루에 하나씩 웹 사이트 랜딩 페이지를 만들어 봅시다.   1일차 : huddle landing page   이 프로젝트는 유튜버 Florin pop에 진행되었으며, Frontend Mentor 사이트에 있는 프로젝트들을 가지고 진행합니다.   프로젝트 따라하기   다음 링크를 따라가셔서 프로젝트에 필요한 이미지와 텍스트 그리고 가이드라인이 들어있는 파일을 다운로드 할 수 있습니다.   해당 프로젝트 기초파일   이 프로젝트는 유튜버 Florin pop에 의해서도 실시간으로 진행되었으니 같이 따라하셔도 좋습니다.   유튜브에서 이 프로젝트 같이 실습하기   결과 프로젝트 실행 방법   다음 링크의 저장소로 가시면 완성된 결과 프로젝트의 파일을 확인 하실 수 있습니다.   프로젝트 완성 파일   저장소를 클론하여, 압축을 푼 다음, index.html 파일을 실행시켜 주세요.   밑은 프로젝트의 README.md 입니다.      Welcome! 👋   Thanks for checking out this front-end coding challenge.   Frontend Mentor challenges allow you to improve your skills in a real-life workflow.   To do this challenges, you need a basic understanding of HTML and CSS.   Where to find everything   Your task is to build out the project to the designs inside the /design folder. You will find both a mobile and a desktop version of the design to work to.   The designs are in JPG static format. This will mean that you’ll need to use your best judgment for styles such as font-size, padding and margin. This should help train your eye to perceive differences in spacings and sizes.   If you would like the Sketch file in order to see sizes etc, it is available to download from the challenge page.   You will find all the required assets in the /images folder. The assets are already optimized.   There is also a style-guide.md file, which contains the information you’ll need, such as color palette and fonts.   Building your project   Feel free to use any workflow that you feel comfortable with. Below is a suggested process, but do not feel like you need to follow these steps:      Initialize your project as a public repository on GitHub. This will make it easier to share your code with the community if you need some help. If you’re not sure how to do this, have a read through of this Try Git resource.   Configure your repository to publish your code to a URL. This will also be useful if you need some help during a challenge as you can share the URL for your project with your repo URL. There are a number of ways to do this, but we recommend using ZEIT Now. We’ve got more information about deploying your project with ZEIT below.   Look through the designs to start planning out how you’ll tackle the project. This step is crucial to help you think ahead for CSS classes that you could create to make reusable styles.   Before adding any styles, structure your content with HTML. Writing your HTML first can help focus your attention on creating well-structured content.   Write out the base styles for your project, including general content styles, such as font-family and font-size.   Start adding styles to the top of the page and work down. Only move on to the next section once you’re happy you’ve completed the area you’re working on.   If you’d like to try making your project fully responsive, we’d recommend checking out Sizzy. It’s a great browser that makes it easy to view your site across multiple devices.   Deploying your project   As mentioned above, there are a number of ways to host your project for free. We recommend using ZEIT Now as it’s an amazing service and extremely simple to get set up with. If you’d like to use ZEIT, here are some steps to follow to get started:      Sign up to ZEIT Now and go through the onboarding flow, ensuring your GitHub account is connected by using their ZEIT Now for GitHub integration.   Connect your project to ZEIT Now from the “Create a new project” page, using the “New Project From GitHub” button and selecting the project you want to deploy.   Once connected, every time you git push, ZEIT Now will create a new deployment and the deployment URL will be shown on your ZEIT Dashboard. You will also receive an email for each deployment with the URL.   Sharing your solution   There are multiple places you can share your solution:      Submit it on the platform so that other users will see your solution on the site. Other users will be able to give you feedback, which could help improve your code for the next project.   Share your repository and live URL in the #finished-projects channel of the Slack community.   Tweet @frontendmentor and mention @frontendmentor including the repo and live URLs in the tweet. We’d love to take a look at what you’ve built and help share it around.   Giving feedback   Feedback is always welcome, so if you have any to give on this challenge please email hi[at]frontendmentor[dot]io.   This challenge is completely free. Please share it with anyone who will find it useful for practice.   Have fun building! 🚀  ","categories": ["Development"],
        "tags": ["HTML","CSS","Web"],
        "url": "http://localhost:4000/development/Huddle-landing-page/",
        "teaser":null},{
        "title": "이진 탐색 트리-예정포스트",
        "excerpt":" ","categories": ["Data Structure"],
        "tags": ["programming","Data Structure","Tree"],
        "url": "http://localhost:4000/data%20structure/binary-search-tree/",
        "teaser":"http://localhost:4000/assets/images/tree1.png"},{
        "title": "트리(Tree)",
        "excerpt":"트리(Tree)   트리는 부모와 자식간의 관계가 계층적으로 구성되는 자료구조이다.  하나의 노드가 여러개의 자식들을, 다시 자식들은 다른 자식들을 가질 수 있는 구조이다.   다음 그림은 전형적인 트리를 보여준다.      트리 용어  트리에 쓰이는 용어들을 알아보자.   루트(Root)  트리의 계층적 구조상 가장 위에 위치한 노드를 지칭한다.  위의 그림에서 A가 루트이다.   루트는 유일하게 부모 노드가 없는 노드이다.   리프 노드(Reaf Node)  아무런 자식도 가지지 않는 노드를 리프 노드라고 한다.  위의 그림에서 E, F, C, G, H가 리프 노드이다.   조상 노드(Ancestor)  특정 노드에서 루트로의 선행자가 이에 해당한다.  노드 F의 조상 노드는 B, A가 된다.   형제 노드(Sibling)  같은 부모를 가지는 노드들을 형제 노드라고 한다.  위의 그림에서 B, C, D가 형제 노드이다.   서브 트리(Sub Tree)  위의 그림에서 A가 null이 아니면, 그 밑의 자식 트리 T1, T2, T3를 노드 A의 서브 트리라고 한다.   레벨(Level)  트리는 계층적 구조로서 레벨을 가지고 있다.  루트는 0레벨이며, 밑 자식으로 갈수록 레벨이 1씩 커진다.   이진 트리   한 노드가 최대 2개의 자식 노드를 가질 수 있는 트리를 이진 트리라고 한다.  한 노드의 왼쪽에 오는 자식을 왼쪽 자식 노드, 오른쪽에 오는 자식을 오른쪽 자식 노드라고 부른다.   다음은 전형적인 이진 트리를 나타내는 그림이다.      이진 트리의 종류   이진 트리를 구성하는 노드의 형태에 따라 다음과 같이 분류된다.   Full Binary Tree   모든 노드가 자식을 0개 혹은 2개 가진 트리를 일컽는다.   다음은 전부 Full Binary Tree이다.            18        /    \\         15      30        /  \\     /  \\    40   50  100   40              18            /    \\             15     20             /  \\              40    50        /   \\    30   50            18          /   \\           40   30               /  \\           100   40   Full Binary Tree에서 리프노드의 수는 내부노드의 수 + 1 이다.   Complete Binary Tree   트리의 마지막 레벨을 제외한 모든 레벨에서 노드가 자식을 두개 가지고 있고, 마지막 레벨에서는 왼쪽 부터 자식이 빠짐없이 차 있는 트리를 일컽는다.   다음은 전부 Complete Binary Tree 이다.                18            /    \\            15      30           /  \\    /  \\       40   50 100   40                18            /    \\            15      30           /  \\    /  \\       40   50  100 40      / \\   /     8  7  9    Binary Heap은 Complete Binary 트리이다.   Perfect Binary Tree   리프노드를 제외한 모든 내부노드가 자식 노드를 2개 가지고, 모든 리프노드가 동일 레벨 선상에 있는 트리를 일컽는다.   다음은 전부 Perfect Binary Tree 이다.                 18            /       \\  --- 높이 h: 3          15         30         /  \\        /  \\       40    50    100   40                18            /    \\  -- 높이 h: 2          15     30    Perfect Binary Tree의 높이가 h일 때 $2^h-1$개의 노드를 가진다.  (높이 h: 루트로부터 리프노드 까지의 경로에 있는 노드의 수)   Degenerate (or pathological) tree   트리의 내부노드가 오직 하나의 자식만을 갖는 트리를 일컽는다.   다음은 Degenerate tree 이다.       10     /    20     \\      30        \\        40       연결 리스트와 성능면에서 동일하다.   이진 트리 표현   이진 트리를 어떻게 표현하고 구현할 수 있을지 알아본다.   이진 트리 클래스는 최상위 노드를 가리키는 root 레퍼런스를 갖고 있다.   class BinaryTree  {      // Root of Binary Tree      Node root;         // Constructors      BinaryTree(int key)      {          root = new Node(key);      }         BinaryTree()      {          root = null;      }  }   또한 이진 트리 클래스는 각 노드를 표현할 노드 클래스를 가지고 있다.   class Node  {      int key;      Node left, right;         public Node(int item)      {          key = item;          left = right = null;      }  }    노드는 다음과 같은 부분으로 구성된다.      Data - 데이터를 저장하는 필드   왼쪽 자식에 대한 레퍼런스   오른쪽 자식에 대한 레퍼런스   트리 예제 코드   위의 표현들을 이용하여 트리를 만들어보고 이해해보자.   먼저 전체 코드이다.   /* Class containing left and right child of current     node and key value*/    // A Java program to introduce Binary Tree  class BinaryTree  {      // Root of Binary Tree      Node root;         // Constructors      BinaryTree(int key)      {          root = new Node(key);      }         BinaryTree()      {          root = null;      }       static class Node      {          int key;          Node left, right;             public Node(int item)          {          key = item;          left = right = null;          }      }         public static void main(String[] args)      {          BinaryTree tree = new BinaryTree();             /*create root*/         tree.root = new Node(1);             tree.root.left = new Node(2);          tree.root.right = new Node(3);          tree.root.left.left = new Node(4);      }  }    BinaryTree tree = new BinaryTree();    이진 트리를 생성하는 구문이다.  아직은 아무런 노드가 없으므로 root 레퍼런스는 null이다.    tree.root = new Node(1);  노드를 할당하여 1을 넣고, 트리의 root 레퍼런스가 할당된 노드를 가리키게 한다.   그림으로 표현하면 다음처럼 도식화 된다.                 1              /   \\            null  null    1번 노드는 루트가 되었다.  1번 노드의 왼쪽, 오른쪽 자식노드는 없으므로 left, right 레퍼런스는 null이다.   그 다음을 보자.   tree.root.left = new Node(2);  tree.root.right = new Node(3);   노드를 할당하여 2를 넣고, 트리의 root 왼쪽 자식 레퍼런스가 할당된 노드를 가리키게 한다. 노드를 할당하여 3을 넣고, 트리의 root 오른쪽 자식 레퍼런스가 할당된 노드를 가리키게 한다. 2, 3번 노드는 아직 자식들이 없으므로 left, right 레퍼런스는 null이다.   그림으로 표현하면 다음과 같다.                   1               /    \\              2       3            /   \\    /  \\          null null null null   계속해서 그 다음을 보자.   tree.root.left.left = new Node(4);   노드를 할당하여 4를 넣고, root의 왼쪽 노드의 왼쪽 자식 레퍼런스가 할당된 노드를 가리키게 한다.   그림으로 표현하면 다음과 같다.                       1                  /       \\                 2          3               /   \\       /  \\              4    null  null  null             /   \\            null null    4번 노드는 2번 노드의 자식이 되었다.   References  GeeksforGeeks  ","categories": ["Data Structure"],
        "tags": ["programming","Data Structure","Linked List","Tree"],
        "url": "http://localhost:4000/data%20structure/Tree/",
        "teaser":null},{
        "title": "트리의 순회(Tree Traversal)",
        "excerpt":"트리의 순회(Tree Traversal)   트리를 순회하는데 여러가지 방법이 있지만 이번 포스트에서는 그 중 깊이우선탐색(DFS)의 성질을 가진 3가지 순회 방법을 알아본다.   다음은 트리를 순회하는 대표적인 3가지 방법이다. (깊이우선탐색(DFS))      Inorder - 중위 순회   Preorder - 전위 순회   Postorder - 후위 순회   3가지 순회들은 다음의 공통된 패턴을 가지고 있다.   (L) 현재 노드의 왼쪽 서브트리를 재귀적으로 순회한다.  (R) 현재 노드의 오른쪽 서브트리를 재귀적으로 순회한다.  (N) 현재 노드를 방문한다.   모든 노드에 대해서, 이 패턴들이 실행되는 순서에 따라 3가지 순회 방법이 결정되게 된다.   여기서 ‘재귀적으로’라는 말은 작업이 다른 서브루틴으로 분기된다는 뜻이다.  서브루틴에서의 작업이 끝나게 되면 다시 현재의 작업으로 백트랙하게 된다.   Inorder - 중위 순회   트리의 중위 순회를 위해서 루트 노드 부터 모든 노드에 대해 다음의 작업을 수행한다.   중위 순회(LNR)  현재 노드가 null인지 확인한다.   아니라면 다음의 순서대로 순회를 한다.    (L) 현재 노드의 왼쪽 서브트리를 재귀적으로 순회한다.   (N) 현재 노드를 방문한다.   (R) 현재 노드의 오른쪽 서브트리를 재귀적으로 순회한다.    다음의 그림은 Inorder의 예를 보여준다.      위의 그림에서 볼 수 있듯이, 어떤 노드가 처리되기 전에 왼쪽 서브트리가 먼저 처리되고(L) 그 다음 해당 노드가 처리되고(N) 그 다음 오른쪽 서브트리 처리된다(R).   모든 노드에 대해서 (L), (R) 연산들은 재귀적으로 수행이 된다.   다음은 위를 구현한 자바 코드이다.   // Recursive function to perform in-order traversal of the tree public static void inorder(TreeNode root) { \t// 현재 노드가 null이면 리턴 \tif (root == null) { \t\treturn; \t}  \t// 재귀적으로 왼쪽 서브트리를 탐색한다. \tinorder(root.left);  \t// 현재 노드의 데이터를 출력한다. (방문) \tSystem.out.print(root.data + \" \");  \t// 재귀적으로 오른쪽 서브트리를 탐색한다. \tinorder(root.right); }   Preorder - 전위 순회   트리의 전위 순회를 위해서 루트 노드 부터 모든 노드에 대해 다음의 작업을 수행한다.   전위 순회(NLR)  현재 노드가 null인지 확인한다.   아니라면 다음의 순서대로 순회를 한다.    (N) 현재 노드를 방문한다.   (L) 현재 노드의 왼쪽 서브트리를 재귀적으로 순회한다.   (R) 현재 노드의 오른쪽 서브트리를 재귀적으로 순회한다.    다음의 그림은 Preorder의 예를 보여준다.      위의 그림에서 볼 수 있듯이, 해당 노드가 처리되고(N) 그 다음 왼쪽 서브트리가 처리되고(L) 마지막으로 오른쪽 서브트리가 처리된다(R).   모든 노드에 대해서 (L), (R) 연산들은 재귀적으로 수행이 된다.   다음은 위를 구현한 자바 코드이다.   // Recursive function to perform pre-order traversal of the tree public static void preorder(TreeNode root) { \t// return if the current node is empty \tif (root == null) { \t\treturn; \t} \t// 현재 노드의 데이터를 출력한다. (방문) \tSystem.out.print(root.data + \" \");  \t// 재귀적으로 왼쪽 서브트리를 탐색한다. \tpreorder(root.left);  \t// 재귀적으로 오른쪽 서브트리를 탐색한다. \tpreorder(root.right); }   Postorder - 후위 순회   트리의 후위 순회를 위해서 루트 노드 부터 모든 노드에 대해 다음의 작업을 수행한다.   후위 순회(LRN)  현재 노드가 null인지 확인한다.   아니라면 다음의 순서대로 순회를 한다.    (L) 현재 노드의 왼쪽 서브트리를 재귀적으로 순회한다.   (R) 현재 노드의 오른쪽 서브트리를 재귀적으로 순회한다.   (N) 현재 노드를 방문한다.    다음의 그림은 Postorder의 예를 보여준다.      위의 그림에서 볼 수 있듯이, 해당 노드가 처리되기 전에 왼쪽 서브트리가 먼저 처리되고(L) 그 다음 오른쪽 서브트리 처리되고(R) 마지막으로 해당 노드가 처리된다(N).   모든 노드에 대해서 (L), (R) 연산들은 재귀적으로 수행이 된다.   다음은 위를 구현한 자바 코드이다.   // Recursive function to perform post-order traversal of the tree public static void postorder(TreeNode root) { \t// return if the current node is empty \tif (root == null) { \t\treturn; \t}  \t// 재귀적으로 왼쪽 서브트리를 탐색한다. \tpostorder(root.left);  \t// 재귀적으로 오른쪽 서브트리를 탐색한다. \tpostorder(root.right);    // 현재 노드의 데이터를 출력한다. (방문) \tSystem.out.print(root.data + \" \"); }   References  GeeksforGeeks  ","categories": ["Algorithm"],
        "tags": ["programming","Traversal","DFS","Tree"],
        "url": "http://localhost:4000/algorithm/treeTraversal/",
        "teaser":null},{
        "title": "그래프(Graph)",
        "excerpt":"Graph  정점들과 간선들로 이루어진 집합이다.   V: Vertex, E: Edge, G: Graph  그래프 G는 (V, E)의 집합으로 정의 될 수 있다. =&gt; G = (V, E)  V(G)는 정점의 집합 그리고 E(G)는 두 정점들의 연결을 나타내는 간선의 집합이다.   Info: 그래프는 트리를 포함하는 개념이고, 트리는 사이클을 포함하지 않는 그래프라고 볼 수 있다.  그래서 모든 트리는 그래프이지만, 모든 그래프는 트리가 아니다.   Undirected and Directed Graph   그래프는 방향 그래프 또는 비방향 그래프가 될 수 있다.   비방향 그래프는 두 정점 간의 간선에 방향이 없다.  A - B의 비방향 간선이 있다면, 이것은 A -&gt; B로, B -&gt; A로의 탐색이 가능하다는 것을 의미한다.   방향 그래프는 두 정점 간의 간선에 방향을 가지고 있다.  A -&gt; B의 방향 간선이 있다면, 이것은 A -&gt; B로의 탐색이 가능, 그러나 B -&gt; A로의 탐색이 가능하지 않다는 것을 의미     Unweighted and weighted Graph   두 정점 간의 간선에 추가 정보가 없다면 Unweighted(비가중치) 그래프.  두 정점 간의 간선에 추가 정보가 있다면 weighted(가중치) 그래프.      Representation  그래프를 표현하는 2가지 방법을 알아본다.  인접 행렬(Adjacency matrix)   2차원 행렬로 표현하는 방법.  행은 출발 정점을 나타내고 열을 도착 정점을 나타낸다. 꼭짓점 x에서 꼭짓점 y로 변이 존재하면 행렬 성분 x행 y열의 값은 1이고 그렇지 않으면 0이다.      Note: 그래프가 100개의 정점과 1개의 간선으로 이루어져 있어도, 인접행렬 표현 시 100x100 크기의 매트릭스를 써야한다. 즉, 비교적 적은 간선의 그래프를 표현하는데에는 불필요한 공간이 많이 소비된다.   인접 리스트(Adjacency list)  인접 리스트를 이용하여 그래프를 표현하는 방법  이 표현에서는, 각 정점이 인접리스트 배열로 표현이 되어 있고, 자신과 인접한 노드들을 리스트로 연결한다.   표현방식: A - B 와 같이 방향성이 없을 때는 A의 인접리스트에 B 원소를 추가하고, B의 뒤에도 A를 추가한다.  A -&gt; B 와 같이 방향성이 있을 때는 A의 인접리스트에 B 원소만 추가한다.      Note: 위 그래프는 방향 그래프임에 주의하라.  A 정점은 B와 C 노드와 이웃하므로 A의 인접리스트 뒤로 B와 C의 원소가 따라 붙는다.  B 정점은 D와 E 노드와 이웃하므로 B의 인접리스트 뒤로 D와 E의 원소가 따라 붙는다.   Pros: 인접 행렬 방식에 비해 메모리 공간을 많이 절약할 수 있다.  각 정점들 간의 이웃관계를 보다 쉽고 확실하게 표현할 수 있다.   Cons: 두 정점이 서로 연결되어 있는지 찾는 연산은 인접 행렬에 비해 다소 느리다.   Implementation   Example Graph  예제에서 나타내고자 하는 그래프는 다음과 같다.   Graph G (Bidirectional):  V = (0, 1, 2, 3, 4) E = (0, 1), (0, 2), (1, 2), (1, 3), (2, 4), (3, 4)  G: 0 ------ 2 |      /   \\ |    /      4 |  /       / 1 ------ 3    위 그래프로 부터 표현되어지는 인접 리스트는 다음과 같다.   0 =&gt; 1 =&gt; 2       // 0번 정점은 1, 2번 정점과 연결되어 있다. 1 =&gt; 0 =&gt; 2 =&gt; 3  // 1번 정점은 0, 2, 3번 정점과 연결되어 있다. 2 =&gt; 0 =&gt; 1 =&gt; 4  // 2번 정점은 0, 1, 4번 정점과 연결되어 있다. 3 =&gt; 1 =&gt; 4       // 3번 정점은 1, 4번 정점과 연결되어 있다. 4 =&gt; 2 =&gt; 3   Graph Class  public class Graph {     private int V; // 그래프의 정점 갯수     private LinkedList&lt;Integer&gt; adjListArray[]; // 그래프의 정점을 저장할 인접리스트 배열      public Graph(int V) { // 그래프 생성자, 정점과 인접리스트 배열을 초기화 한다.         this.V = V;         adjListArray = new LinkedList[V]; // 인접리스트 배열 생성         for (int i = 0; i &lt; V; i++) {             adjListArray[i] = new LinkedList&lt;&gt;(); // 인접리스트 노드 초기화 및 생성         }     } }    addEdge  // 양방향 간선 정보 저장 static void addEdge(Graph graph, int src, int dest) {      graph.adjListArray[src].add(dest); // src -&gt; dest     graph.adjListArray[dest].add(src); // dest -&gt; src }    Graph.java  import java.util.LinkedList;  public class Graph {     private int V; // 그래프의 정점 갯수     LinkedList&lt;Integer&gt; adjListArray[]; // 그래프의 정점을 저장할 인접리스트 배열      public Graph(int V) { // 그래프 생성자, 정점과 인접리스트 배열을 초기화 한다.         this.V = V;         adjListArray = new LinkedList[V];         for (int i = 0; i &lt; V; i++) {             adjListArray[i] = new LinkedList&lt;&gt;();         }     }     // 그래프 출력 메소드     public void printGraph() {         for (int v = 0; v &lt; V; v++) {             System.out.print(v);             for (Integer i : adjListArray[v]) {                 System.out.print(\" =&gt; \" + i);             }             System.out.print(\"\\n\");         }     }     // 양방향 간선 생성 메소드     static void addEdge(Graph graph, int src, int dest) {         graph.adjListArray[src].add(dest);         graph.adjListArray[dest].add(src);     }       public static void main(String[] args) {         int V = 5; // 정점의 갯수는 5개 (0, 1, 2, 3, 4)         Graph graph = new Graph(V); // 그래프 초기화          addEdge(graph, 0, 1); // 0번과 1번을 정점으로 하는 간선을 생성한다.         addEdge(graph, 0, 2); // 0번과 2번을 정점으로 하는 간선을 생성한다.         addEdge(graph, 1, 2); // 1번과 2번을 정점으로 하는 간선을 생성한다.         addEdge(graph, 1, 3);         addEdge(graph, 2, 4);         addEdge(graph, 3, 4);          graph.printGraph();     } }  Output: 0 =&gt; 1 =&gt; 2       // 0번 정점은 1, 2번 정점과 연결되어 있다. 1 =&gt; 0 =&gt; 2 =&gt; 3  // 1번 정점은 0, 2, 3번 정점과 연결되어 있다. 2 =&gt; 0 =&gt; 1 =&gt; 4  // 2번 정점은 0, 1, 4번 정점과 연결되어 있다. 3 =&gt; 1 =&gt; 4       // 3번 정점은 1, 4번 정점과 연결되어 있다. 4 =&gt; 2 =&gt; 3       // 4번 정점은 2, 3번 정점과 연결되어 있다.   References  Graph - Wikipedia  Graph - javapoint  ","categories": ["Data Structure"],
        "tags": ["programming","Data Structure"],
        "url": "http://localhost:4000/data%20structure/graph/",
        "teaser":null},{
        "title": "Restful API Authentication App",
        "excerpt":"Restful API Authentication App   Used Packages, Libraris, Dependencies and Database in the project.     Node.js   Express.js: Node.js package   nodemon: To restart server   Mongoose: DB package   MongoDB: To save user data   bcryptjs: Encrypt the user’s password so that 3rd party don’t see   dotenv: Configuration private setting data   @hapi/joi: To validate user input form data   Make sure   Make sure that node.js must be installed in your computer.   Make sure that you must have your own mongoDB cluster.  Make sure that postman which is used to requset get or post method with data to server should be installed.   Usage      clone the repository.   Inside .env file, Replace  with your mongoDB account password.   Open the terminal.   Start Server by typing ‘npm start’ or ‘npm run dev’ in the terminal (Make sure that except for quotation mark in the terminal).   Open the postman   Try to send ‘POST’ request with JSON data(below 6) format with URL - http://localhost:5000/api/user/register   Try with Example JSON data =&gt; { “name”: “lemidia”, “email”: “poiu2186@gmail.com”, “password”:”own password” }   Once you have done this, Try to send ‘POST’ request with JSON data(below 7) format with URL - http://localhost:5000/api/user/login   Try with Example JSON data =&gt; { “poiu2186@gmail.com”, “password”:”&lt;own passowrd” }   Repository   Github - lemidia  ","categories": ["Development"],
        "tags": ["Development","JavaScript","Node.js","API"],
        "url": "http://localhost:4000/development/restfulauth/",
        "teaser":null},{
        "title": "합병 정렬(Merge Sort)",
        "excerpt":"Merge Sort(합병 정렬)   합병 정렬 또는 병합 정렬(merge sort)은 O(n log n) 비교 기반 정렬 알고리즘입니다.  일반적인 방법으로 구현했을 때 이 정렬은 안정 정렬에 속하며, 분할 정복 알고리즘의 하나입니다. 존 폰 노이만이 1945년에 개발했습니다.   Algorithm   밑의 애니메이션을 먼저 보시고 알고리즘을 읽으시면 이해가 빠를 수 있습니다.      리스트의 길이가 1 이하이면 이미 정렬된 것으로 본다. 그렇지 않은 경우에는   분할(divide) : 정렬되지 않은 리스트를 절반으로 잘라 비슷한 크기의 두 부분 리스트로 나눈다.   정복(conquer) : 각 부분 리스트를 재귀적으로 합병 정렬을 이용해 정렬한다.   결합(combine) : 두 부분 리스트를 다시 하나의 정렬된 리스트로 합병한다. 이때 정렬 결과가 임시배열에 저장된다.   복사(copy) : 임시 배열에 저장된 결과를 원래 배열에 복사한다.   Animation - Merge sort      Analysis      Note: 7개의 원소가 들어있는 배열에 재귀적 병합 정렬을 적용했을 때 우리가 상상할 수 있는 그림입니다.  배열의 원소가 1개가 될 때까지 원래 배열의 1/2씩 분할을 계속 진행합니다.  배열의 원소가 1개가 되면 병합을 진행합니다.  [38][27]  38은 27보다 크므로 두 원소가 스왑되어 합병됩니다.  [43][3]  43은 3보다 크므로 두 원소가 스왑되어 합병됩니다.  [27, 38] [3, 43]  27과 3이 스왑되고 38과 43은 그대로 배열에 들어갑니다.  이와 마찬가지로 다른 분할 배열들도 위와 같이 진행됩니다.   Java로 구현 - 재귀적(Top-down, Recursive)   설명: 재귀적으로 서브배열의 크기가 1이 될 때까지 계속 분할을 진행합니다.  분할된 배열들을 정렬하고 합병합니다.  // @author lemidia public class MergeSort {     static void divide(int data[], int p, int r){         if(p &lt; r){             int q = (p+r)/2; // Middle             divide(data, p, q); // Left             divide(data, q+1, r); // Right             merge(data, p, q, r); // Merge         }     }      static void merge(int data[], int p, int q, int r){         int i = p; int j = q+1; int k = p;         int temp[] = new int[data.length];          for (int l = p; l &lt; r+1 ; l++) {             if (i &lt;= q &amp;&amp; (j &gt; r || data[i] &lt; data[j])){                 temp[k++] = data[i++];             }else                 temp[k++] = data[j++];         }         for(int l = p; l &lt;= r; l++){             data[l] = temp[l];         }          /*         while (i&lt;=q &amp;&amp; j&lt;=r){             if(data[i] &lt;= data[j]){                 temp[k++] = data[i++];             }else{                 temp[k++] = data[j++];             }         }         while (i&lt;=q)             temp[k++] = data[i++];         while (j&lt;=r)             temp[k++] = data[j++];         for(int l = p; l&lt;=r; l++){             data[l] = temp[l];         }         */      }      public static void main(String[] args) {         int limit = 10;         int arr[] = new int[limit];          for(int i = limit-1; i &gt;= 0; --i){             arr[i] = limit-i;         }         divide(arr, 0, limit-1);         for (int i = 0; i &lt; arr.length; i++) {             System.out.print(arr[i] + \" \");         }     } }   1 2 3 4 5 6 7 8 9 10    시간복잡도  최악 시간복잡도\tO(n log n) 최선 시간복잡도\tO(n log n) 평균 시간복잡도\t일반적으로, O(n log n)  쉬운 설명: 배열의 원소가 n개일 때 깊이는 log(n)만큼 진행 됩니다. (매번 2개씩 분할 되므로)  각 깊이마다 n개의 원소들이 제자리를 찾아 스왑됩니다.  그래서 시간복잡도는 깊이 * n개의 원소 즉, nlog(n)이 됩니다.   References   Merge Sort - wikipedia  ","categories": ["Algorithm"],
        "tags": ["Sort","Mathematics"],
        "url": "http://localhost:4000/algorithm/merge-sort/",
        "teaser":"http://localhost:4000/assets/images/merge-sort-rec.png"},{
        "title": "큐(Queue)",
        "excerpt":"Queue  큐(queue)는 컴퓨터의 기본적인 자료 구조의 한가지로, 먼저 집어 넣은 데이터가 먼저 나오는 FIFO (First In First Out)구조로 저장하는 형식을 말한다. 영어 단어 queue는 표를 사러 일렬로 늘어선 사람들로 이루어진 줄을 말하기도 하며, 먼저 줄을 선 사람이 먼저 나갈 수 있는 상황을 연상하면 된다.      Representation     Array: 기본적으로 배열을 사용해서 큐를 구현할 수 있다.   Linked List: 링크드 리스트를 이용하면 배열에 비해 쉽게 구현이 가능하다.   Note: 이번 포스트에서는 자바로 Linked List를 이용해서 큐를 구현해 본다.   Queue Node - 큐 원소를 표현하기 위한 노드 클래스   // A linked list (LL) node to store a queue entry  class QNode {      int key;      QNode next;         // constructor to create a new linked list node      public QNode(int key)      {          this.key = key;          this.next = null;      }  }   Queue Node - 큐를 표현하는 클래스   class Queue {      QNode front, rear;         public Queue()      {          this.front = this.rear = null;      }  }   Note: 큐는 맨 처음 원소를 가리키는 front와 맨 끝 원소를 가리키는 rear 포인터를 가지고 있다.   Operation  큐가 지원하는 연산들을 알아보자.      Enqueue: 큐의 맨 끝에 원소를 추가하는 연산.   Dequeue: 큐의 맨 처음의 원소를 삭제하고 반환하는 연산. 큐가 비었으면 null을 반환한다.   Enqueue - 원소 추가 연산  void enqueue(int key) {      // Create a new LL node      QNode temp = new QNode(key);       // If queue is empty, then new node is front and rear both      if (this.rear == null) {          this.front = this.rear = temp;          return;      }       // Add the new node at the end of queue and change rear      this.rear.next = temp;      this.rear = temp;  }   Dequeue - 원소 삭제 연산   QNode dequeue() {      // If queue is empty, return NULL.      if (this.front == null)          return null;       // Store previous front and move front one node ahead      QNode temp = this.front;      this.front = this.front.next;       // If front becomes NULL, then change rear also as NULL      if (this.front == null)          this.rear = null;      return temp;  }   Queue Implementation - 전체 코드   // A linked list (LL) node to store a queue entry  class QNode {      int key;      QNode next;         // constructor to create a new linked list node      public QNode(int key)      {          this.key = key;          this.next = null;      }  }   // A class to represent a queue  // The queue, front stores the front node of LL and rear stores the  // last node of LL  class Queue {      QNode front, rear;         public Queue()      {          this.front = this.rear = null;      }         // Method to add an key to the queue.      void enqueue(int key)      {             // Create a new LL node          QNode temp = new QNode(key);             // If queue is empty, then new node is front and rear both          if (this.rear == null) {              this.front = this.rear = temp;              return;          }             // Add the new node at the end of queue and change rear          this.rear.next = temp;          this.rear = temp;      }         // 큐에서 원소를 삭제하는 연산     QNode dequeue()      {          // If queue is empty, return NULL.          if (this.front == null)              return null;             // Store previous front and move front one node ahead          QNode temp = this.front;          this.front = this.front.next;             // If front becomes NULL, then change rear also as NULL          if (this.front == null)              this.rear = null;          return temp;      }  }     // Driver class  public class Test {      public static void main(String[] args)      {          Queue q = new Queue();          q.enqueue(10);          q.enqueue(20);          q.dequeue();          q.dequeue();          q.enqueue(30);          q.enqueue(40);          q.enqueue(50);             System.out.println(\"Dequeued item is \" + q.dequeue().key);      }  }    Queue q = new Queue();  빈 큐가 생성이 된다.  현재: q = []  q.enqueue(10);  q.enqueue(20);  (10, 20)이 들어온다.  현재: q = [10, 20];  q.dequeue();  q.dequeue();  (10, 20)이 나간다.  현재: q = [];  q.enqueue(30);  q.enqueue(40);  q.enqueue(50);  (30, 40, 50)이 차례대로 들어온다.  현재: q = [30, 40, 50];  System.out.println(\"Dequeued item is \" + q.dequeue().key);  디큐 연산으로 인해 맨앞의 30이 삭제되고 반환된다.  Output: Dequeued item is 30   자바가 제공하는 큐   자바에서는 Queue Interface를 구현한 Linked List Class를 제공한다.   큐 선언: Queue&lt;T&gt; queue = new LinkedList&lt;T&gt;();  큐 연산: queue.offer(); // 삽입 연산 queue.pop();   // 삭제하고 원소 반환 queue.peek();  // 큐의 맨 앞 원소 반환 queue.isEmpty(); // 큐가 비었는지 확인   Time Complexity  Algorithm   Average  WorstCase Space       O(n)     O(n) Search      O(n)     O(n) Insert      O(1)     O(1) Delete      O(1)     O(1)   References  Queue - Wikipedia   Queue - Geeks  ","categories": ["Data Structure"],
        "tags": ["programming","Data Structure"],
        "url": "http://localhost:4000/data%20structure/queue/",
        "teaser":null},{
        "title": "자바스크립트를 이용한 날씨 웹 앱",
        "excerpt":"앱 개요   웹 화면 상으로 사용자의 지역 날씨 상태를 보여주는 웹 어플리케이션.   Look      설명   사용자가 웹 앱에 접속하면 사용자로부터 위치정보 엑세스에 대한 허용 여부를 묻는다.  허용이 되면 자바스크립트의 navigator.geolocation으로 부터 사용자의 위도와 경도 값을 읽어낸다.  DarkSky API로 부터 받은 사용자 키 값에 위도와 경도값을 넣어준다.  API로 부터 읽어낸 JSON 데이터를 자바스크립트 객체로 변환하여 앱에서 필요한 데이터를 얻는다.   사용되는 것들     HTML - 웹 엘리먼트 구조   CSS - 스타일 꾸미기 및 레이아웃   Pure JavaScript - 사용자 위치정보, Dom Tree 조작, 온도 계산   DarkSky Api - 날씨 정보를 받아오기 위해 사용 (월 1000건 까지의 쿼리는 무료)   SkyCons - DarkSky Api에서 제공하는 날씨 아이콘   실행 방법   하나의 폴더에 밑의 index.html, style.css, app.js파일을 넣어준다.  그리고, 날씨 데이터 사이트에 가서 Try For Free를 눌러 가입하여 API키 값을 얻어낸 다음  app.js 파일의 “자신의 키” 부분에 API 키 값을 넣어준다.  // app.js파일의 &lt;자신의 키&gt; 부분에 API 키 값을 넣어준다. const api = `${proxy}https://api.darksky.net/forecast/&lt;자신의 키&gt;/${lat}, ${long}`;   Source Code   index.html   &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt;     &lt;meta charset=\"UTF-8\"&gt;     &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;     &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt;     &lt;link rel=\"stylesheet\" href=\"./style.css\"&gt;     &lt;title&gt;Weather&lt;/title&gt; &lt;/head&gt; &lt;body&gt;      &lt;div class=\"location\"&gt;         &lt;h1 class=\"location-timezone\"&gt;Loading Location Data ...&lt;/h1&gt;         &lt;canvas id=\"icon1\" width=\"128\" height=\"128\"&gt;&lt;/canvas&gt;     &lt;/div&gt;     &lt;div class=\"temperature\"&gt;         &lt;div class=\"degree-section\"&gt;             &lt;h2 class=\"temperature-degree\"&gt;?&lt;/h2&gt;             &lt;span class=\"transition\"&gt;C&lt;/span&gt;         &lt;/div&gt;         &lt;div class=\"temperature-description\"&gt;Loading Data ... &lt;/div&gt;     &lt;/div&gt;     &lt;script src=\"./app.js\"&gt;&lt;/script&gt;     &lt;script src=\"skycons.js\"&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt;  style.css  *{     margin: 0;     padding: 0;     box-sizing: border-box; }  body{     height: 100vh;     display: flex;     justify-content: center;     flex-direction: column;     align-items: center;     background: linear-gradient(rgb(47,150,163), rgb(48, 62, 143));     font-family: sans-serif;     color: white; }  .location, .temperature{     height: 20vh;     width: 50%;     display: flex;     justify-content: space-around;     align-items: center; }  .temperature{     flex-direction: row;     align-items: baseline; }  .temperature-description{     font-size: 2rem;     transform: translateX(20%); }  .degree-section{     display: flex;     align-items: center;     cursor: pointer;     transform: translateX(30%); }  .degree-section span{     margin: 7px;     font-size: 35px; }  .degree-section h2{     font-size: 40px; }  @media screen and (max-width:550px){     .location-timezone{         margin-right: 3rem;     }      .degree-section{         margin-right: 6rem;         font-size: 30px;     }      .temperature-description{         transform: translateX(-20%);     } }  app.js  window.addEventListener('load', () =&gt;{     let long;     let lat;     let temperatureDescription = document.querySelector('.temperature-description');     let temperatureDegree = document.querySelector('.temperature-degree');     let locationTimezone = document.querySelector('.location-timezone');          if (navigator.geolocation) {         navigator.geolocation.getCurrentPosition( position =&gt; {             long = position.coords.longitude;             lat = position.coords.latitude;             const proxy = 'https://cors-anywhere.herokuapp.com/';             const api = `${proxy}https://api.darksky.net/forecast/&lt;자신의 키&gt;/${lat}, ${long}`;              fetch(api)                 .then(response =&gt; {                  return response.json();                 })                  .then(data =&gt; {                    console.log(data);                    const {dewPoint, summary, icon} = data.currently;                    // Set DOM Elements from the API                    temperatureDegree.textContent = Math.round((dewPoint - 32) / 1.8);                    temperatureDescription.textContent = summary;                    locationTimezone.textContent = data.timezone.replace(\"/\", \" / \");                    setIcons(icon, \"icon1\");                   });         }, () =&gt; {             alert(\"You have denied or please confirm location\");         });     } else{         alert(\"Geolocation is not supported by your browser\");     }     function setIcons(icon, iconID){         const skycons = new Skycons({color : \"white\"});         const weatherCondition = icon.replace(/-/g, \"_\").toUpperCase();         skycons.set(iconID, Skycons[weatherCondition]);         skycons.play();     }      let degreeSection = document.querySelector('.degree-section');     let transition = document.querySelector('.transition');     let isCelsius = true;     degreeSection.addEventListener('click', () =&gt; {         if (isCelsius) {             temperatureDegree.textContent              = Math.round(parseInt(temperatureDegree.textContent) * 1.8 + 32);             transition.textContent = 'F';             isCelsius = false;         }else{             temperatureDegree.textContent              = Math.round((parseInt(temperatureDegree.textContent) - 32) / 1.8);             transition.textContent = 'C';             isCelsius = true;         }     }) });  References   [Dev Ed - Youtube]  ","categories": ["Development"],
        "tags": ["JavaScript","Web","API"],
        "url": "http://localhost:4000/development/weather-app/",
        "teaser":null},{
        "title": "비선형 구조와 탐색(Non-linear Structure and Search)",
        "excerpt":"비선형 구조와 탐색   비선형 구조란 i번째 원소를 탐색한 다음 그 원소와 연결된 다른 원소를 탐색하려고 할 때, 여러 개의 원소가 존재하는 탐색구조를 말한다.   일반적으로 자료가 트리나 그래프로 구성되어 있을 경우를 비선형 구조라 하고 이러한 트리나 그래프의 모든 정점을 탐색하는 것을 비선형 탐색이라고 이해하면 된다.   비선형 구조는 선형과 달리 자료가 순차적으로 구성되어 있지 않으므로 단순히 반복문을 이용하여 탐색하기에는 어려움이 있다. 그러므로 비선형구조는 스택이나 큐와 같은 자료구 조를 활용하여 탐색하는 것이 일반적이다.   비선형 구조의 탐색은 크게 깊이우선탐색(depth first search, dfs)과 너비우선탐색 (breadth firth search, bfs)으로 나눌 수 있으며, 이 두 가지 탐색법에 대해서 알아본다.   비선형 구조   비선형 구조의 탐색을 다루기 전에 그래프와 트리에 대해서 간단히 알아보자.  트리와 그래프를 이루는 기본 요소를 정점(vertex)과 간선(edge)이라고 한다.      원은 정점, 선분은 간선을 나타내며, a-b는 보통간선, a-&gt;b는 방향간선, b-d는 가중치가 15인 양방향통행 간선, d-&gt;e는 가중치가 7인 일방통행 간선(방향간선)을 나타낸다.  정점은 점 또는 원으로 표현하며, 일반적으로 상태나 위치를 표현한다. 간선은 정점들을 연결하는 선으로 표현하며, 정점들 간의 관계를 표현한다.   경로(path)와 회로(cycle)   그래프에서 임의의 정점 s에서 임의의 정점 t로 이동할 때, s에서 t로 이동하는데 사용한 정점들을 연결하고 있는 간선들의 순서로 된 집합을 경로라고 한다. 회로는 그래프에서 임 의의 정점 s에서 같은 정점 s로의 경로들을 말한다.      자기간선(loop)과 다중간선(multi edge)   임의의 정점에서 자기 자신으로 연결하고 있는 간선을 자기간선, 임의의 정점에서 다른 정점으로 연결된 간선의 수가 2개 이상일 경우를 다중간선이라고 한다.      그래프의 차수(degree)  그래프의 임의의 한 정점에서 다른 정점으로 연결된 간선의 수를 차수라고 한다.      그래프의 구현   그래프를 구현하는 방법은 인접행렬(adjacency matrix)과 인접리스트(adjacency list)로 크게 나눌 수 있다.   tip: 프로그래밍 대회에서 그래프는 보통 정점의 수, 간선의 수, 각 간선들이 연결하고 있는 정점 2개로 이루어진 정보가 주어진다.   다음과 같은 그래프가 주어질 때, 이를 표현하는 2가지 방법을 알아본다.      위 그래프의 입력 형식과 입력 데이터의 예   입력 형식: 첫 번째 줄에 정점의 수 n과 간선의 수 m 이 공백으로 구분되어 입력된다. 두 번째 줄부터 m개의 줄에 걸쳐서 간선으로 연결된 두 정점의 번호와 가중치가   공백으로 구분되어 입력된다.  입력 데이터: 7 11 1 2 47  1 3 69  2 4 57  2 5 124  3 4 37  3 5 59  3 6 86  4 6 27  4 7 94  5 7 21  6 7 40   인접행렬의 구현   입력예시를 인접행렬로 받기 위해서는 2차원 배열을 이용한다.  먼저 최대 정점의 수에 맞추어 2차원 배열을 선언하고 각 배열의 칸에 연결된 정보를 저장한다.  앞 그래프를 2차원 행렬을 이용하여 다음과 같이 저장한다.      2차원 행렬을 이용하여 저장하는 소스코드는 다음과 같다. 단 최대 정점의 수는 100개 로 가정한다.   C language #include &lt;stdio.h&gt;  int n, m, G[101][101]; int main() {     scanf(\"%d %d\",&amp;n,&amp;m);     for(int i=0; i&lt;m; i++) {         int a, b, w;         scanf(\"%d %d %d\", &amp;a, &amp;b, &amp;w);         G[a][b]=G[b][a]=w;     }  }   인접리스트의 구현   인접행렬로 표현할 때에는 연결되지 않았던 부분까지 모두 표현이 된다. 즉, 각 칸에 0 이라고 기록된 부분은 연결이 되지 않은 부분을 의미한다. 사실 일반적인 그래프에서 행렬 상에서 0이라고 표현되는 부분이 많을 가능성이 크다.   알고리즘을 구현할 때에도 이 0이라고 표시된 부분까지 모두 조사를 해야 하므로 효율 이 떨어지는 경우가 많다. 이러한 단점을 극복하기 위하여 제안된 방법이 인접리스트이고 이 방법은 인접행렬에서 0으로 표시된 부분은 저장하지 않으므로 효율을 높이고 있다.         위의 입력 예시를 인접리스트로 구현하기 위해서는 [그림-10], [그림-11]과 같이 연결리스트로 구현할 수 있지만 STL에서 제공하는 C++의 std::vector()를 이용하면 보다 더 간단하게 구현할 수 있다. 위의 입력예시를 인접리스트로 구현하면 다음과 같은 그림이 된다.      C++의 std::vector()를 이용한다면 위와 같이 인접행렬로 구현하는 것보다 공간을 더 적게 사용한다. 따라서 전체탐색법을 구현할 때, 당연히 탐색시간도 줄일 수 있다. 계산량으로 표현하자면, 인접행렬로 모든 정점을 탐색하는데 O($n^2$)의 시간이 드는데 반해, 인접리스트로 표현하면 O(n+m)의 시간이 든다.   여러 가지 장점으로 인해 인접리스트를 이용한 방법을 활용하는 경우가 많으므로 반드시 익혀둘 수 있도록 하자.   비선형 구조의 탐색   깊이우선탐색(dfs)   그래프 중 회로(cycle)가 없는 그래프를 트리라고 한다. 다음 그림은 트리를 나타낸다. 이 트리의 가장 위에 있는 정점에서 출발하여 모든 정점들을 깊이우선으로 탐색하며, 탐색 하는 순서를 알아보자.      출발 정점을 트리의 가장 위에 있는 정점으로 하고, 한 정점에서 이동 가능한 정점이 여 러 개 있을 경우 왼쪽의 정점부터 방문한다고 가정하면, 단계별 탐색 과정은 다음과 같다.      깊이우선탐색과정에서 3단계 이후 더 이상 진행할 수 있는 정점이 없다. 그 이유는 간선 으로 연결된 정점들 중 아직 방문하지 않은 정점을 방문하기 때문이다.   이처럼 더 이상 진행할 수 없을 때는 다시 이전 정점으로 되돌아가는 과정이 필요하다. 일반적으로 이 과정을 백트랙(backtrack)이라고 한다. 백트랙은 비선형 구조의 탐색에서 매 우 중요하다. 백트랙은 스택(stack)이나 재귀함수(recursion)를 이용하면 쉽게 구현할 수 있다.      4, 5, 6단계는 연속으로 백트랙이 발생한다. 이는 더 이상 진행할 수 없는 정점까지 도달 했다는 것을 의미한다. 계속 해서 다음 단계로 진행하는 과정은 다음과 같다.      위 단계에서 마지막 정점을 방문하면 깊이우선탐색이 완료된다.      깊이우선탐색을 정리하여 설명하면 먼저 시작 정점에서 간선을 하나 선택하여 진행할 수 있을 때까지 진행하고 더 이상 진행할 수 없다면 백트랙하여 다시 다른 정점으로 진행 하여 더 이상 진행할 정점이 없을 때까지 이 과정을 반복하는 탐색법으로, 간선으로 연결 된 모든 정점을 방문할 수 있는 탐색법이다.   깊이우선탐색의 알고리즘은 다음과 같다. 이 탐색법은 백트래킹(backtracking)이라는 알 고리즘 설계 기법의 중심이 되며 백트래킹 기법은 모든 문제를 해결할 수 있는 가장 기본 적인 방법이므로 꼭 익혀둘 필요가 있다.   깊이우선탐색   bool visited[101]; //방문했는지 체크해 두는 배열 void dfs(int k){     for(int i=0; i&lt;G[i].size(); i++){ // 정점 k와 연결된 모든 정점 방문         if(!visited[G[k][i].to]){ // 만약 아직 방문하지 않았으면             visited[G[k][i].to]=true; // 방문했다고 체크하고             // 깊이우선탐색 진행             dfs(G[k][i]);         }     }     return; //더 이상 갈 길이 없으면 backtrack }   이 방법은 그래프를 인접리스트에 저장했을 경우에 활용할 수 있다. 전체를 탐색하는데 있어서 반복문의 실행횟수는 모두 m 번이 된다. 일반적으로 인접행렬 보다 속도가 더 빠르기 때문에 자주 활용된다.     너비우선탐색(bfs)   너비우선탐색은 깊이우선탐색과는 달리 현재 정점에서 깊이가 1인 정점을 모두 탐색한 뒤 깊이를 늘려가는 방식이다. 위에서 다룬 ‘10개의 정점과 9개의 간선을 가진 트리’를 통해서 너비우선탐색을 살펴보자.      먼저 1단계부터 4단계까지를 살펴보면 1에서 출발하여 깊이가 1인 세 정점을 모 두 순차적으로 방문한다. 계속해서 너비우선탐색의 결과를 살펴보면 다음과 같다.         너비우선탐색은 백트랙을 하지 않는다. 대신에 현재 정점에서 깊이가 1인 정점을 모두 방문해야 하므로 큐(queue)라는 선입선출(FIFO) 자료구조를 활용하여 현재 정점에서 깊이가 1 더 깊은 모든 정점을 순차적으로 큐에 저장하여 탐색에 활용한다.  따라서 STL에서 제 공하는 std::queue()를 활용하는 방법을 익힐 필요가 있다.   너비우선탐색 알고리즘은 다음과 같다.   #include &lt;queue&gt; bool visited[101]; void bfs(int k){     std::queue&lt;int&gt; Q;     Q.push(k), visited[k]=1;     while(!Q.empty()){         int current=Q.front();         Q.pop();         for(int i=0; i&lt;G[current].size(); i++){             if(!visited[G[current][i]]) {                 visited[G[current][i]]=1;                 Q.push(G[current][i]);             }         }     } }   이 방법은 그래프를 인접리스트에 저장했을 경우에 활용할 수 있으며, 전체를 탐색하는 데 있어서 반복문의 실행횟수는 모두 m번이 된다. 따라서 일반적으로 속도가 인접행렬 보다 더 빠르기 때문에 자주 활용된다.   References      문제해결을 위한 창의적 알고리즘  ","categories": ["Algorithm"],
        "tags": ["DFS","BFS","Data structure","programming"],
        "url": "http://localhost:4000/algorithm/%EB%B9%84%EC%84%A0%ED%98%95%EA%B5%AC%EC%A1%B0%EC%9D%98-%ED%83%90%EC%83%89/",
        "teaser":"http://localhost:4000/assets/images/creativealgorithm1.png"},{
        "title": "에라토스테네스의 체(Eratosthenes's Sieve)",
        "excerpt":"에라토스테네스의 체   수학에서 에라토스테네스의 체는 보다 빠르게 소수를 찾는 방법입니다.  고대 그리스 수학자 에라토스테네스가 발견하였습니다.     선행지식: 수학에서 소수란?   소수: 1을 제외한 수 중에서 1과 자기 자신을 제외하고 약수를 가지지 않는 수를 말합니다.   예)   예1) 2는 1과 자기 자신(2)을 제외하고는 약수를 가지지 않습니다. 소수입니다. 예2) 5는 1과 자기 자신(5)을 제외하고는 약수를 가지지 않습니다. 소수입니다. 예3) 13은 1과 자기 자신(13)을 제외하고는 약수를 가지지 않습니다. 소수입니다. 예4) 15는 1과 자기자신(15)를 제외하고도 3, 5의 약수를 가집니다. 소수가 아닙니다.   Algorithm   밑의 애니메이션을 먼저 보시고 알고리즘을 읽으시면 이해가 빠를 수 있습니다.      2부터 소수를 구하고자 하는 구간의 모든 수를 나열한다. 그림에서 회색 사각형으로 두른 수들이 여기에 해당한다.   2는 소수이므로 오른쪽에 2를 쓴다. (빨간색)   자기 자신을 제외한 2의 배수를 모두 지운다.   남아있는 수 가운데 3은 소수이므로 오른쪽에 3을 쓴다. (초록색)   자기 자신을 제외한 3의 배수를 모두 지운다.   남아있는 수 가운데 5는 소수이므로 오른쪽에 5를 쓴다. (파란색)   자기 자신을 제외한 5의 배수를 모두 지운다.   남아있는 수 가운데 7은 소수이므로 오른쪽에 7을 쓴다. (노란색)   자기 자신을 제외한 7의 배수를 모두 지운다.   위의 과정을 반복하면 구하는 구간의 모든 소수가 남는다.      Note: 만약 x까지의 소수를 구한다고 하면 우리는 x까지 검사하여 일일히 지울 필요가 없습니다.  x는 &gt;= $\\sqrt {x}$ * $\\sqrt {x}$으로 표현 할 수 있고, $\\sqrt {x}$까지 수를 지우면, 그 이후의 수들은 이미 $\\sqrt {x}$까지의 수에서 지워졋기 때문입니다.  예) x를 16 이라고 해봅시다. $\\sqrt {x}$은 4 입니다.  8은 16의 약수입니다. 하지만 8은 이미 전 단계 2에서 지워졌습니다. 2 * 8이기 때문입니다.  예제에서는 120까지 구하고 있으므로 120의 제곱근 $\\sqrt {120}$ = 10까지만 지워도 됩니다.  왜냐하면 $\\sqrt {120}$ = 10 이후의 배수들은 이미 전 단계에서 지워졋기 때문입니다.   Java로 구현  import java.util.Arrays;  public class Eratosthenes {     private static final int MAX = 30;      public static void main(String[] args) {          boolean [] flag = new boolean[MAX];         Arrays.fill(flag, true);         eratosthenes(flag, MAX);         for (int i = 2; i &lt; flag.length; i++){             if (flag[i]){                 System.out.println(i + \" is prime number\");             }         }     }      public static void eratosthenes(boolean[] flag, int k){         for (int i = 2; i*i &lt; k ; i++) {             if (flag[i]){                 for (int j = i*i; j &lt; k ; j+=i) {                     flag[j] = false;                 }             }         }     } }   2 is prime number 3 is prime number 5 is prime number 7 is prime number 11 is prime number 13 is prime number 17 is prime number 19 is prime number 23 is prime number 29 is prime number   References   Eratothenes - wikipedia  ","categories": ["Algorithm"],
        "tags": ["Data Structure","Mathematics"],
        "url": "http://localhost:4000/algorithm/eratosthenes-sieve/",
        "teaser":"http://localhost:4000/assets/images/Sieve_of_Eratosthenes_animation.gif"},{
        "title": "전체탐색법(Brute force)",
        "excerpt":"전체탐색법   전체탐색법은 모든 문제해결의 기초가 되는 가장 중요한 설계법 중 하나라고 할 수 있다. 주어진 문제에서 해가 될 수 있는 모든 가능성을 검사하여 해를 구하기 때문에 항상 정확한 해를 구할 수 있다는 점이 장점이다. 하지만 탐색해야할 내용이 너무 많으면 문제에서 제시한 시간 이내에 해결할 수 없다는 점을 유의해야 한다.   하지만 전체탐색을 기반으로 한 다양한 응용들이 있으며, 이러한 응용들을 통하여 탐색 해야할 공간을 배제해 나가면서 시간을 줄일 수 있는 다양한 방법들이 존재하기 때문에 잘 응용하면 많은 문제를 해결할 수 있는 강력한 도구가 될 수 있다. 따라서 전체탐색법을 잘 익혀두면 다른 알고리즘 설계법을 학습하는데 많은 도움이 된다.   전체탐색법은 선형구조의 탐색, 비선형구조의 탐색을 기반으로 하여 문제를 해결한다.   선형구조와 비선형구조의 전체탐색   선형구조의 전체탐색은 반복문을 이용하여 접근할 수 있다.  1차 원 뿐만 아니라 2차원 이상의 다차원 구조에 대해서도 선형구조로 탐색할 수 있다.   비선형구조의 전체탐색은 문제해결의 가장 기본이 되는 알고리즘 설계법인 백트래킹을 이용한다.  백트래킹 기법은 재귀함수를 이용하여 간단하게 구현할 수 있고, 다양한 문제를 해결하는데 많이 응용되는 방법이므로 반드시 익혀둘 필요가 있다.   주어진 문제들을 통하여 선형구조, 비선형구조의 전체탐색법을 익힐 수 있도록 하자.   선형 구조에서의 전체탐색   약수의 합  한 정수 n을 입력받아서 n의 모든 약수의 합을 구하는 프로그램을 작성하시오.    예를 들어 10의 약수는 1, 2, 5, 10이므로 이 값들의 합인 18이 10의 약수의 합이 된다.    입력   첫 번째 줄에 정수 n이 입력된다. (단, 1 &lt;= n &lt;= 100,000)    출력   n의 약수의 합을 출력한다. ------------------- 입력 예 10  출력 예 18   이 문제는 기본적으로 수학적인 아이디어를 이용하여 해결할 수 있는 문제이지만 이 단 원에서는 전체탐색법을 다루는 단원이므로 전체탐색법으로 해결해보자.   일단 n을 입력받으면 1부터 n까지의 모든 수를 차례로 반복문을 이용하여 선형으로 탐색하면서 n의 약수들을 검사한다. 만약 현재 탐색 중인 수가 n의 약수라면 누적하여 구할 수 있다. 이렇게 구한다면 계산량은 O(n)이 된다. 이 문제에서는 n의 최댓값이 100,000이므로 충분히 해결할 수 있는 문제가 된다.   어떤 수 x가 n의 약수라면 다음 조건을 이용해 구할 수 있다.   n % x == 0   이를 이용하여 문제를 해결한 소스코드는 다음과 같다.   #include &lt;stdio.h&gt; int n; int solve() {     int ans=0;     for(int i=1; i&lt;=n; i++ )         if(n%i==0)             ans+=i;     return ans; }  int main() {     scanf(\"%d\", &amp;n);     printf(\"%d\\n\", solve()); }   이문제는 이와 같은 방법으로 쉽게 해결할 수 있으나, n이 10억 이상의 값으로 커질 때는 다른 방법을 생각해야 한다.  아마 다른 포스트에서 다루게 될 것이므로 한 번 생각해보자.   최댓값  다음과 같이 9×9 격자판에 쓰여진 81개의 자연수가 주어질 때, 이들 중 최댓 값을 찾고   그 최댓값이 몇 행 몇 열에 위치한 수인지 구하는 프로그램을 작성하시오.    예를 들어, 다음과 같이 81개의 수가 주어질 경우에는 이들 중 최댓값은 90이고, 이 값은 5행 7열에 위치한다.    열 1  2  3  4  5  6  7  8  9 행 1    3 23 85 34 17 74 25 52 65 2   10  7 39 42 88 52 14 72 63 3   87 42 18 78 53 45 18 84 53 4   34 28 64 85 12 16 75 36 55 5   21 77 45 35 28 75 90 76  1 6   25 87 65 15 28 11 37 28 74 7   65 27 75 41  7 89 78 64 39 8   47 47 70 45 23 65  3 41 44 9   87 13 82 38 31 12 29 29 80  입력   첫째 줄부터 아홉째 줄까지 한 줄에 아홉 개씩 자연수가 주어진다. 주어지는 자연 수는 100보다 작다.  출력   첫째 줄에 최댓값을 출력하고, 둘째 줄에 최댓값이 위치한 행 번호와 열 번호를 빈칸을 사이에 두고 차례로 출력한다.   최댓값이 두 개 이상인 경우 그 중 한 곳의 위치를 출력한다. ---------------------------- 입력 예   3 23 85 34 17 74 25 52 65 10 7 39 42 88 52 14 72 63 87 42 18 78 53 45 18 84 53 34 28 64 85 12 16 75 36 55 21 77 45 35 28 75 90 76 1 25 87 65 15 28 11 37 28 74 65 27 75 41 7 89 78 64 39 47 47 70 45 23 65 3 41 44 87 13 82 38 31 12 29 29 80  출력 예 90 57    이 문제는 2차원 구조를 선형으로 모두 탐색하면 쉽게 해결할 수 있는 문제이다.  2차원 구조는 행 우선으로 탐색하는 방법과 열 우선으로 탐색하는 방법이 있는데, 이 문제는 어떤 방법으로 탐색해도 관계없으며, 일반적으로는 행 우선 탐색을 많이 사용한다.   다음은 행 우선을 반복문으로 구현한 소스코드이다.   for(int row=0; row&lt;5; row++) {     for(int col=0; col&lt;4; col++)         printf(\"[%d, %d]\", row, col);     uts(\"\"); }   이제 문제를 해결하는 방법에 대해서 알아보자.   탐색하기 전 먼저 해를 저장할 변수인 ans를 0으로 초기화한다. 여기서 주의할 점은 각 원소들 중 음수값이 존재할 경우 최댓값을 구하기 위해 ans를 0으로 초기화하면 안 된다는 점이다. 이 문제는 음수값이 존재하지 않기 때문에 ans를 0으로 초기화하고 문제를 해결한다.   참고로 어떤 변수에 값을 초기화하는 몇 가지 방법을 소개한다. 일단 int형의 최댓값은 0x7fffffff(2,147,483,647)이며, 최솟값은 0x80000000(-2,147,483,648)이다. 엄밀하게 최대, 최소를 지정할 때 이 값을 이용하면 되며, 16진법을 이용하면 쉽게 처리할 수 있다.   여기서 주의할 점은 위 값들을 설정한 후 값을 증가시키거나 감소시키면 오버플로 (overflow)로 인하여 답이 잘못될 수 있다.  예를 들어 다음 명령을 보자.   int max = 0x7fffffff; max=max+1;   위 예의 경우에 max값이 최댓값이었는데, 여기서 1을 증가하면 오버플로가 발생하 여 max값은 음수가 된다.  따라서 이런 점을 방지하기 위하여 적어도 2배 정도라 하더 라도 오버플로가 발생하지 않도록 처리하는 경우가 많다.  이럴 때는 주로 최댓값을 987654321 등의 자릿수도 쉽게 알 수 있고 2배를 하더라도 정수 범위에 있는 수 등을 활용하는 경우가 많다.  문제에 따라서는 탐색하고자 하는 데이터 중에서 임의의 한 값 을 최댓값 또는 최솟값으로 결정하는 방법도 있다.   위 문제를 해결하는 소스코드는 다음과 같다.   #include &lt;stdio.h&gt; int A[10][10], ans, mi, mj; void input() {     for(int i=0; i&lt;9; i++)         for(int j=0; j&lt;9; j++)         scanf(\"%d\", &amp;A[i][j]); } int solve() {     for(int i=0; i&lt;9; i++)         for(int j=0; j&lt;9 ; j++)             if(ans &lt; A[i][j]) {                 ans=A[i][j];                 mi=i+1; mj=j+1;             } } int main() {     input();     solve();     printf(\"%d\\n%d %d\\n\", ans, mi, mj);     return 0; }   가장 일반적으로 해결할 수 있는 방법이고 이 경우 계산량은 O(row x column)이 된다.  이를 보다 효율적으로 바꾸기 위해서, 입력받으면서 바로 처리할 수도 있으며, ans, mi, mj를 모 두 쓰지 않고 mi, mj만 가지고 처리하는 방법을 소개한다.   #include &lt;stdio.h&gt; int A[10][10], mi, mj; void input_solve() {     for(int i=0; i&lt;9; i++)         for(int j=0; j&lt;9; j++) {             scanf(\"%d\", &amp;A[i][j]);             if(A[mi][mj]&lt;A[i][j])                 mi=i, mj=j;         } } int main() {     printf(\"%d\\n%d %d\\n\", A[mi][mj], mi+1, mj+1);     return 0; }   고기잡이   우리나라 최고의 어부 정올이가 이번에 네모네모 배 고기잡이 대회에 참가한다.    이 대회에는 3개의 라운드가 있는데, 첫 번째 라운드는 1차원 형태로 표현될 수 있는 작은 연못에서 길쭉한 그물을 던져서 최대한 많은 고기를 잡는 것이 목적이다.    1라운드의 예를 들면 연못의 크기가 1*6이고 물고기의 위치와 가치가 다음과 같다고 하자.    1 0 2 0 4 3  여기서 그물의 크기는 1*3이라고 할 때, 잡을 수 있는 방법은 (1 0 2), (0 2 0), (2 0 4), (0 4 3)의 4가지 방법이 있다.    이 중 가장 이득을 보는 방법은 마지막 방법 0 + 4 + 3 = 7이다. 따라서 주어진 경우의 최대 이득은 7이 된다. 정올이는 최대한 가치가 큰 물고기를 잡아서 우승하고 싶어 한다.    연못의 폭과 각 칸에 있는 물고기의 가치, 그물의 가로의 길이와 세로의 길이가 주어질 때, 잡을 수 있는 물고기의 최대이득을 구하는 프로그램을 작성하시오.    입력 첫 번째 줄에 연못의 폭 N이 입력된다. ( N &lt;= 100 인 자연수 ) 두 번째 줄에 그물의 폭 W가 입력된다. ( W &lt;= N 인 자연수 ) 세 번째 줄 W개의 물고기의 가치가 공백으로 구분되어 주어진다. 각 물고기의 가 치는 7이하의 자연수이다. 0일 경우에는 물고기가 없다는 의미이다.  출력 잡을 수 있는 물고기의 최대 가치를 출력한다. --------------------------------- 입력 예 6 3 1 0 2 0 4 3   출력 예 7   이 문제는 전체탐색법을 이용하여 간단하게 해결할 수 있다.  폭이 n인 연못에서 폭이 w인 그물을 던졌을 때 최대 이득을 얻을 수 있는 구간을 찾는 문제이다.  가장 단순한 방 법으로 n개의 주어진 수들 중 연속된 w개의 수들을 탐색하여 합을 구한 다음 최댓값을 갱신하는 방법으로 접근할 수 있다.  먼저 첫 번째 데이터부터 탐색하여 w개의 합을 구한 다음 최댓값을 갱신하고, 두 번째 데이터부터 탐색하여 w개의 합을 구하여 최댓값을 갱신한다. 이런 방법으로 모든 구간을 전체탐색법으로 확인할 수 있다.   입출력 예의 경우 다음과 같은 과정으로 해를 구해나간다.      위의 과정을 보면 탐색을 시작하는 지점이 0번으로부터 시작하여 1씩 증가하는 것을 알 수 있으며, 시작점을 지정하면 그물의 폭인 w만큼 탐색을 진행한다. 따라서 마지막 탐색 의 시작 지점은 n - w + 1 이 된다. 핵심 탐색 부분을 구현하면 다음과 같다.   for(int i=0; i&lt;N‐W+1; i++) {     for(int j=0; j&lt;W; j++)         printf(\"%d \", i+j);     puts(\"\"); }   n = 8 이고 w = 5 일 때, 위 탐색방법의 출력결과는 결과는 다음과 같다.   0 1 2 3 4 1 2 3 4 5 2 3 4 5 6 3 4 5 6 7   즉, [0, 4] 구간, [1, 5]구간, [2, 6]구간, [3, 7]구간으로 모두 4번을 검사한다.   위 소스코드에서 n - w + 1 을 생각하기 어려운 경우에는 배열을 좀 더 크게 잡은 후 다음과 같이 작성해도 관계없다.   for(int i=0; i&lt;N; i++) {     for(int j=0; j&lt;W; j++)         printf(\"%d \", i+j);     puts(\"\"); }   위와 같이 작성하면 생각하기 쉽기 때문에 빠른 시간에 코딩이 가능하다. 위의 코드의 출력결과는 다음과 같다.   0 1 2 3 4 1 2 3 4 5  2 3 4 5 6 3 4 5 6 7 4 5 6 7 8  5 6 7 8 9 6 7 8 9 10  7 8 9 10 11   위의 아이디어 들을 이용하여 문제를 해결한 소스코드는 다음과 같다.   #include &lt;stdio.h&gt; int data[101], N, W, ans = 0; int main() {     scanf(\"%d%d\", &amp;N, &amp;W);     for(int i=0; i&lt;N; i++)         scanf(\"%d\", data+i);      for(int i=0; i&lt;N+W‐1; i++) {         int sum=0;         for(int j=0; j&lt;W; j++)             sum+=data[i+j];         if(sum&gt;ans) ans=sum;     }     printf(\"%d\", ans); }   이 알고리즘의 계산량은 1~N의 각 위치에 대해서 W만큼 탐색을 하므로 O(NW)가 됨 을 알 수 있다.  문제에서 제시한 N의 최대치가 100,000이 입력되고 그물의 크기가 적당히 크면 수행시 간이 많이 걸리므로 좀 더 효율적인 알고리즘이 필요하다.   비선형 구조에서의 전체탐색   계단 오르기   길동이는 n개의 단으로 구성된 계단을 오르려고 한다.   길동이는 계단을 오를 때 기분에 따라서 한 번에 1단 또는 2단을 올라갈 수 있다.   계단의 크기 n이 주어질 때, 길동이가 이 계단을 올라갈 수 있는 모든 경우의 수를   구하는 프로그램을 작성하시오.    만약 계단이 3개라면 길동이는 1, 1, 1로 올라가는 법과 1, 2로 올라가는 법, 2, 1로  올라가는 법의 3가지 서로 다른 방법이 있다.   ----------------------------------------- 입력 계단의 수 n이 입력된다(단 n은 20보다 작은 자연수).    출력 길동이가 계단을 오르는 모든 방법의 수를 출력한다.  입력 예         출력 예 3              3     이 문제도 비선형구조로 전체탐색을 하여 해를 구할 수 있다.  현재 상태에서 1칸 또는 2 칸을 올라갈 수 있으므로, 탐색구조를 다음과 같이 설정할 수 있다.   단, 주의할 점은 정확 하게 n칸에 도착했을 때만 한 가지 경우로 처리해야한다는 점이다.  예를 들어 도착점까지 한 칸 남았을 경우에는 2칸을 올라갈 수 없다.      위의 탐색 과정으로 5칸의 계단을 오르는 과정을 보면 다음과 같다.      위와 같은 트리를 구성하면서 전체탐색을 하면 n은 5일 때, 방법은 8임을 알 수 있다.  이와 같은 구조의 탐색을 소스코드로 구현하면 다음과 같다.   #include &lt;stdio.h&gt; int n, ans; void solve(int v) {     if(v&gt;n) return; // --- (a)     if(v==n){ // 현재 n칸이면          ans++;         return;     }     solve(v+1); // 1칸 오르기     solve(v+2); // 2칸 오르기 } int main() {     scanf(\"%d\", &amp;n);      solve(0);      printf(\"%d\\n\", ans); }   Warning: (a)행의 조건은 마지막 계단을 넘어가는 경우를 처리한다. 이 구문이 없으면 무한 재귀에 빠지게 된다.   거스름 돈   여러분은 실력을 인정받아 전 세계적으로 사용할 수 있는 자동판매기용 프로그램의   개발을 의뢰받았다. 거스름돈에 사용될 동전의 수를 최소화하는 것이다.   입력으로 거슬러 줘야할 돈의 액수와 그 나라에서 이용하는 동전의 가짓수   그리고 동전의 종류가 들어오면 여러 가지 방법들 중 가장 적은 동전의 수를 구하는   프로그램을 작성하시오.  ----------------------------------------- 입력 첫 번째 줄에는 거슬러 줘야할 돈의 액수 m이 입력된다.   ( 10 &lt;= m &lt;= 10,000 )   다음 줄에는 그 나라에서 사용되는 동전의 종류의 수 n이 입력된다.   ( 1 &lt;= n &lt;= 10 )   마지막 줄에는 동전의 수만큼의 동전 액수가 오름차순으로 입력된다.   ( 10 &lt;= 액수 &lt;= m )    출력 최소의 동전의 수를 출력한다.    입력 예 730 5 10 50 100 500 1250  출력 예 6   이 문제는 매우 잘 알려진 유명한 문제 중 하나로 다양한 방법으로 해결할 수 있는 대표적인 문제이다. 이 단원에서는 전체탐색법을 기반으로 하여 해결하는 방법에 대해서 소개한다. 대부분의 문제들에서도 마찬가지지만 문제를 전체탐색으로 구조화하는 방법에 따라 해법의 계산량이 달라질 수 있다.   이 문제에서는 2가지 서로 다른 구조화로 해결하는 방법을 소개한다. 먼저 첫 번째 방법은 문제의 상태를 지금까지 지불한 액수로 설정하고, 서로 다른 동전 1개를 이용하여 지불하는 경우를 간선으로 생각할 수 있다.   이 방법으로 구조화하는 방법은 다음 그림과 같다. 이 때 $x$의 값은 지금까지 지불한 액수이며 사용 가능한 동전은 4가지 종류로 10원, 50원, 100원, 500원일 때를 가정한 것이다.      처음에 0원으로 출발하여 각 동전을 지불해 나가며, 지불할 금액과 일치할 때의 깊이가 지불한 동전의 개수이므로, 지불할 금액과 일치하는 최소 깊이를 구하는 문제가 된다. 만약 지불할 금액과 일치했거나 금액을 초과했을 경우에는 백트랙하면서 탐색을 진행하도록 코드를 작성하면 된다.   지불해야할 금액이 120원이고, 사용가능한 동전이 30원, 50원, 60원, 100원일 때의 전체 탐색구조는 다음과 같다. 먼저 처음 깊이 1까지의 구조이다.      다음은 30원 이하의 정점들의 전체적인 구조이다. 파란색 정점은 120원 지불에 성공한 것을 나타낸다.      계속해서 50원과 60원 정점의 전체 탐색구조를 나타낸다. 100원 이하에서는 더 이상의 탐색이 불가능하다.      #include&lt;stdio.h&gt; int m, n, coin[10], ans=987654321; void solve(int mon, int d) {     if(mon&gt;m) return;     if(mon==m){         if(d&lt;ans) ans=d;          return;     }     for(int i=0; i&lt;n; i++)         solve( mon+coin[i], d+1 ); } int main() {     scanf(\"%d %d\", &amp;m, &amp;n);     for(int i=0; i&lt;n ; i++ )         scanf(\"%d\", coin+i);      solve(0, 0);      printf(\"%d\\n\", ans);      return 0; }   위 프로그램에서의 solve()함수는 다음과 같은 상태를 표현하고 있다.   solve(mon, d) = “d개의 동전으로 mon원을 사용한 상태”   이 방법은 정확하게 해를 구할 수는 있으나 이론상으로 최대 금액이 10,000원이고 최소 액수가 10원이므로 최대 깊이가 1,000까지 갈 수 있기 때문에 시간 내에 해결할 수 없다.   시간을 줄이기 위한 다양한 방법이 있지만, 이번에는 다른 구조를 이용하여 해결할 수 있는 방법을 소개한다. 탐색구조를 어떻게 설계하느냐에 따라서 해법의 계산량이 달라질 수 있다는 것을 알고, 문제를 해결할 때, 탐색구조를 어떻게 구성해야하는지 먼저 고민하는 것이 중요하다.   이번에 소개하는 구조는 이전과는 달리 같은 깊이에서는 같은 동전으로만 지불하는 방법으로 구조를 구성한다. 한 깊이에서 간선의 수는 해당 깊이의 동전을 0개로부터 해당 금액을 최대한 지불할 수 있는 최대한의 수로 설정하여 진행한다. 다음 그림을 통하여 자세히 알아보자. 동전은 30원, 50원, 60원, 100원이다.      실제 지불할 금액은 120원, 지불가능한 동전의 수는 50원, 60원, 100원일 때의 경우 전체 구조는 다음과 같다.      이 방법으로 구현한 소스코드는 다음과 같다.   #include &lt;stdio.h&gt; int n, m, coin[10], ans=987654321; void solve(int mon, int k, int cnt) {      if(mon==m){         if(ans&gt;cnt) ans=cnt;         return; // 백트랙     }     if(k==n) return; // 더 이상 깊이 진행 X, 백트랙     for(int i=0; mon+coin[k]*i&lt;=m; i++) // 조건 만족하지 않을 시 백트랙         solve(mon+coin[k]*i, k+1, cnt+i); } int main() {     scanf(\"%d %d\", &amp;m, &amp;n);      for(int i=0; i&lt;n; i++)          scanf(\"%d\", coin+i);     solve(0, 0, 0);     printf(\"%d\\n\", ans);      return 0; }   위 프로그램에서의 solve()함수는 다음과 같은 상태를 표현하고 있다.   solve(mon, k, cnt )= “k번째 이하의 동전을 cnt개 사용하여 mon원을 거슬러 준 상태”   이 방법은 앞에서 시도했던 방법보다 속도가 획기적으로 빨라진다. 그 이유는 전체 상태를 그려보면 앞의 방법보다 이번에 구조화한 방법의 정점의 수가 훨씬 적기 때문이다. 이와 같이 구조를 어떻게 설계하느냐에 따라 알고리즘의 계산량이 달라지기 때문에, 문제를 해결할 때 먼저 최적의 구조를 설계하는 것이 중요하다.   연구활동 가는 길      *위의 그래프를 참고하여 문제를 풀어보자*  정올이는 GSHS에서 연구활동 교수님을 뵈러 A대학교를 가려고 한다. 출발점과 도착점을 포함하여 경유하는 지역 n개, 한 지역에서 다른 지역으로 가는 방법이 총 m 개이며  GSHS는 지역 1이고 A대학교는 지역 n이라고 할 때 대학까지 최소 비용을 구하시오.  단, n은 10 이하, m은 30 이하, 그리고 한 지역에서 다른 지역으로  가는 데에 필요한 비용은 모두 200 이하 양의 정수이며 한 지역에서 다른 지역으로 가는 어떠한 방법이 존재하면  같은 방법과 비용을 통해 역방향으로 갈 수 있다.  위의 그래프는 예를 보여준다. (단, 정점 a -&gt; 정점 b로의 간선이 여러 개 있을 수 있으 며, 자기 자신으로 가는 정점을 가질 수도 있다.)  최소 비용이 드는 경로 : 1→3→5→7, 최소 비용 : 69+59+21=149  입력 첫 번째 줄에는 정점의 수 n과 간선의 수 m이 공백으로 구분되어 입력된다. 다음 줄부터 m개의 줄에 걸쳐서 두 정점의 번호와 가중치가 입력된다. (자기 간선, 멀티 간선이 있을 수 있다.)  출력 대학까지 가는 데 드는 최소 비용을 출력한다. 만약 갈 수 없다면 “-1”을 출력.  ---------------------------- 입력 예  7 11 1 2 47 1 3 69 2 4 57 2 5 124 3 4 37 3 5 59 3 6 86 4 6 27 4 7 94 5 7 21 6 7 40  출력 예 149    이 문제는 그래프 상의 최단경로를 구하는 매우 유명한 문제이다.  이 문제를 해결하는 알고리즘은 여러가지가 알려져 있지만, 어려운 알고리즘을 모르더라도 전체탐색법을 통하여 해결할 수 있다.   이 문제는 그래프 구조이므로 비선형탐색법으로 해를 구할 수 있다.  먼저 출발정점에서 깊이우선탐색을 이용하여 출발점으로부터 도착점까지 가능한 모든 경로에 대해서 구해본다.   하나의 경로를 구할 때마다 해를 갱신하면서 최종적으로 가장 적합한 해를 출력한다.  주어진 예를 통하여 전체탐색하는 과정을 간단하게 살펴보자.            Warning:  중간에 몇개의 과정이 생략되었음에 유의      따라서 위의 경우 전체탐색법으로 탐색한 결과 최소 이동거리는 149가 됨을 알 수 있다.  위의 과정과 같은 방법으로 코딩한 결과는 다음과 같다.   #include&lt;stdio.h&gt; int n, m, G[11][11], sol = 0x7fffffff, chk[11]; void solve(int V, int W) {     if(V==n){ // 도착 여부를 확인하여 현재 정점이 도착점이라면         if(W&lt;sol) sol=W; // 더 좋은 해가 있으면 해를 갱신             return; // 백트랙     }     for(int i=1; i&lt;=n; i++)         if(!chk[i] &amp;&amp; G[V][i]) {             chk[i]=1; // 다음 정점으로 진행할 때 다음 방문할 정점을 체크             solve(i, W+G[V][i]); // 다음 정점으로 진행             chk[i]=0; // 백트랙해서 돌아오면 체크를 해제         } }  int main(void) {     scanf(\"%d %d\", &amp;n, &amp;m);     for(int i=0; i&lt;m; i++) {         int s,e,w;         scanf(\"%d %d %d\", &amp;s, &amp;e, &amp;w);         G[s][e]=G[e][s]=w;     }     solve(1, 0);     printf(\"%d\\n\", sol==0x7fffffff ? ‐1:sol);     return 0; }   이 문제의 경우 정점과 간선의 수가 많지 않으므로 인접행렬로도 충분히 처리가 가능하기 때문에 인접행렬로 처리한다.  solve(a, b)는 현재 a정점까지 방문한 상태로 이동거리가 b라고 정의하고 있으며, chk배 열이 현재까지 방문한 정점들의 정보를 가지고 있다.  다음 정점으로 진행할 때 chk[i]=1 같이 chk배열에 다음 방문할 정점을 체크하고 만약 백트랙해서 돌아온다면, chk[i]=0 같이 체크를 해제하며 전체탐색을 진행한다.   if(V==n) 부분에서 도착 여부를 확인하여 현재 정점이 도착점이라면, 지금까지의 이동 거리와 현재 까지 구한 해를 비교하여 더 좋은 해가 있으면 해를 갱신한다. 이와 같이 작성할 경우 도시의 수가 n개라고 할 때 O(n!)의 계산이 필요하다.   다른 포스트에서 탐색배제를 이용하여 계산복잡도를 향상해본다.   References      문제해결을 위한 창의적 알고리즘  ","categories": ["Algorithm"],
        "tags": ["DFS","BFS","Data structure","programming","Brute force"],
        "url": "http://localhost:4000/algorithm/%EC%A0%84%EC%B2%B4%ED%83%90%EC%83%89%EB%B2%95/",
        "teaser":"http://localhost:4000/assets/images/creativealgorithm25.png"},{
        "title": "탐색공간의 배제(Exclusion of Search Space)",
        "excerpt":"Notice: 이 글은 전체탐색법의 후행 내용으로서, 먼저 제 블로그의 전체탐색법을 보시고 이 포스트를 보시는 것을 추천드립니다!   탐색공간의 배제   전체탐색법은 대부분의 경우 해를 구할 수 있는 알고리즘이다. 하지만 실행시간이 너무 길어 제한 시간 내에 문제를 해결할 수 없는 경우가 많다. 탐색공간의 배제는 전체탐색 알고리즘을 구현하는 데 있어서 더 이상 탐색하지 않더라도 해를 구하는 데 문제가 없는 부분을 판단하여 이 부분에 대해서 탐색을 하지 않으므로 탐색의 효율을 높이고자 하는 방법이다.   탐색공간의 배제는 전체탐색에서 불필요한 탐색공간을 탐색하지 않음으로써 알고리즘의 효율을 향상시킨다. 이와 같이 탐색공간을 배제하는 방법은 다양하며 가장 기본 전략은 전체탐색설계와 같이 탐색으로 시작하여 모든 공간을 탐색하는 것이 아니라 일정한 조건을 두어 탐색영역을 배제하는 것이다.   배제되는 탐색공간의 크기에 따라 알고리즘의 성능의 향상 폭이 달라진다. 하지만 잘못 설계를 하여, 해가 있는 상태를 배제하면 해를 구할 수 없는 경우가 발생한다. 따라서 탐색 영역을 배제할 때는 엄밀한 수학적 접근이 필요하다. 이 설계방법은 탐색영역을 배제하는 방법에 따라서 수학적 배제, 경험적 배제, 구조적 배제로 나눌 수 있다.   각 방법에 대해서 자세히 알아보자.   수학적 배제를 이용한 설계   탐색 공간 중 배제할 영역을 수학적 증명으로 결정하는 방법으로는 이분탐색 알고리즘 이 있다. 이는 일종의 수학적 배제를 이용하여 탐색공간을 줄여나가는 알고리즘 설계방법 이라고 할 수 있다.   오름차순으로 정렬된 상태의 이분탐색에서 현재 탐색한 값이 목표하는 값보다 작다면, 현재 탐색 위치의 왼쪽 영역에는 해가 존재할 가능성이 없다. 이는 수학적으로 쉽게 증명 할 수 있다.   따라서 왼쪽 영역에 대해서는 탐색할 필요가 없음을 알 수 있다. 그러므로 다음 탐색영역은 이를 배제하고 오른쪽 영역만 탐색하는 방법이다. 이와 같이 수학적으로 탐색할 필요가 없음이 증명된 공간들을 배제해 나가며 탐색하는 것과 같은 접근법이 수학적 배제를 이 용한 방법이라고 할 수 있다.   수학적 배제로 알고리즘을 설계할 경우, 공간을 배제할 원리를 수학적으로 증명한 후, 이 방법을 반복적으로 해를 찾을 때까지 적용해 나가며 해를 찾는다. 탐색공간에서 선택 배제된 부분은 수학적으로 탐색할 필요가 없으므로, 일반적으로 탐색법이긴 하지만 백트랙 없이 선형으로 진행되는 경우가 많다.   수학적으로 공간을 배제해 나가는 이 방법은 일종의 탐욕법(greedy)이라고 할 수 있으며, 엄밀하게 수학적으로 증명을 하기 때문에 수학적 탐욕법(mathematical greedy)라고 할 수 있다.   하지만 수학적 증명 없이, 직관적으로 현재 상태만으로 잘못된 판단을 하게 되면 올바른 해를 구할 수 없는 가능성을 가지는 단순 탐욕법이 될 수 있으므로 주의해야 한다. 하지만 단순 탐욕법의 경우에도 다양한 응용법이 있으므로 다음에 다루도록 한다.   다음 예는 루트 정점에서 출발하여 각 정점의 값을 누적하며 마지막 정점까지의 합을 최대화하는 최적화문제이다. 이 문제의 목적은 값을 최대화 하는 것이므로 다음 [영역배제의 규칙]을 적용하여 탐색 영역을 배제해 나가보자.   영역배제의 규칙: 현재 상태에서 다음으로 탐색할 수 있는 정점들 중 더 높은 점수가 있는 정점으로 탐색한다.  (즉, 더 작은 점수가 있는 정점의 영역을 배제한다.)   이 규칙은 수학적으로 설득력이 있어 보인다. 왜냐하면 값을 최대화하기 위해서는 작은 값보다는 큰 값이 이득이 되기 때문이다. 하지만 엄밀한 수학적 증명은 하지 않았다. 이 방법으로 탐색을 진행하는 과정은 다음과 같다.      처음 출발점이 루트이므로 루트에 적힌 3점을 획득하여 현재 점수는 3점이다.  다음으로 이동할 수 있는 정점들은 왼쪽 아래로 연결된 8점이 기록된 정점과 오른쪽 아래로 연결된 2점이 기록된 정점의 2가지이다. 이 상태에서 [영역배제의 규칙]을 적용하여 값이 더 큰 8점이 기록된 정점을 선택하고 2점이 기록된 정점을 배제하고 진행한다.      이 규칙을 적용하여 마지막까지 탐색한 결과는 위 그림에서 구한 해는 3-8-4-5를 선택하게 되며 이 때 얻은 점수는 3+8+4+5 이 된다. 과연 20점 이상을 획득할 수 있는 경로는 존재하지 않을까? 다음 그림을 보자.      위 결과를 보면 알 수 있듯이 3+2+9+8=22의 경로가 존재하며 앞 에서 영역을 배제했던 규칙이 잘못됐음을 알 수 있다. 수학적 배제는 엄밀한 수학적 접근 없이, 단순히 직관적으로 배제의 규칙을 결정하면 최적해를 구할 수 있음을 보장할 수 없다. 하지만 구현이 간단하며, 일반적으로 최적해와의 차이가 크지 않은 해를 구할 수 있다는 장점을 이용하여 다른 설계법에 응용할 수 있으므로 나중에 다시 살펴보기로 하자.   주어진 문제들을 통하여 수학적 배제 방법으로 알고리즘을 설계해보자.   약수의 합   한 정수 n을 입력받아서 n의 모든 약수의 합을 구하는 프로그램을 작성하시오.    예를 들어 10의 약수는 1, 2, 5, 10이므로 이 값들의 합인 18이 10의 약수의 합이 된다.    입력   첫 번째 줄에 정수 n이 입력된다. (단, 1 &lt;= n &lt;= 10,000,000,000(100억))    출력   n의 약수의 합을 출력한다. ------------------- 입력 예 10  출력 예 18   이 문제는 전체탐색법 - 약수의 합과 동일한 문제이다. 차이점은 앞의 문제가 입력값의 정의역이 100,000이었던 것에 반해,이 문제에서는 입력값이 100억으로 커졌다는 것이다.   앞의 문제에서 작성했던 풀이는 다음과 같다.   #include &lt;stdio.h&gt; int n; int solve() {     int ans=0;     for(int i=1; i&lt;=n; i++ )         if(n%i==0)             ans+=i;     return ans; }  int main() {     scanf(\"%d\", &amp;n);     printf(\"%d\\n\", solve()); }   이 소스코드는 1부터 n까지의 모든 원소들을 탐색하여, 탐색 대상인 수 i가 n의 약수 라면 취하는 방식으로 진행된다.  따라서 계산량은 O(n)이다.   이번 문제는 n의 최댓값이 100억이므로 이 방법으로는 너무 많은 시간이 걸린다. 따라서 탐색영역을 배제해야 할 필요가 있다.   먼저 간단한 수학적인 원리들을 생각해보자. 먼저 다음 정리를 이용하자.   모든 자연수 n에 대하여 1과 n은 항상 n의 약수이다.  이 원리를 이용하면 위 소스코드의 8행의 탐색범위를 줄여서 다음과 같이 표현할 수 있다.   for(int i=2; i&lt;n; i++)    if(n%i==0)     ans+=i;   원래 소스코드보다 탐색공간이 줄어들긴 했으나 효율을 높이기에는 너무 미미하기 때문에 효율향상을 느낄 수 없다. 하지만 위 아이디어를 조금 응용하면 탐색공간을 많이 줄일 수 있다.   위 아이디어를 응용하기 위해서 다음 원리를 적용할 수 있다.   모든 자연수 n에 대하여, 2이상 n미만의 자연수들중 가장 큰 n의 약수는 n/2를 넘지 않는다.  이 원리를 적용하면 다음과 같이 탐색영역을 줄일 수 있다.   for(int i=2; i&lt;n/2; i++)    if(n%i==0)     ans+=i;   이 알고리즘은 탐색영역이 처음의 소스코드의 반이하로 줄어든 것이다. 따라서 실행시간 은 2배 이상 빨라질 것을 예상할 수 있다.   수학적인 아이디어로 탐색 영역을 반 정도 줄였지만 아직도 매우 큰 입력 값을 처리하기에는 시간이 너무 오래 걸린다. 탐색 공간을 더 배제할 수 있는 아이디어를 생각해보자.   임의의 자연수 n의 약수들 중 두 약수의 곱은 n되는 약수 a와 약수 b는 반드시 존재한 다. 단, n이 완전제곱수일 경우에는 약수 a와 약수 b가 같을 수 있다. 자연수 10의 약수를 통해서 알아보자. 자연수 10의 약수의 개수는 4개이며 다음과 같다.   { 1, 2, 5, 10}   위 집합을 살펴보면 아래와 같은 관계를 찾을 수 있다.        |--| { 1, 2, 5, 10}   |_________|     10의 약수 관계   위 그림에서 알 수 있듯이 1과 10의 곱은 10이고 2와 5의 곱은 10이다. 약수의 개수를 $c$개라고 하고, $d_i$를 $n$의 약수 중 $i$번째 약수라 하면 다음과 같은 식이 성립한다.   Expression: $ n = d_k * d_{c-k+1}$   즉, $k$번째 원소와 $c-k+1$번째 원소의 곱은 항상 $n$이다. 이 원리를 적용하면 10의 약수 를 구할 때, 1과 2만 탐색하면 5와 10을 알 수 있으므로 모든 약수를 구할 수 있다.   단, $n$이 완전제곱수 일 경우에는 약수의 개수가 홀수이므로 $d_k$번째 원소와 $d_{c-k+1}$번째 원소가 같을 경우가 한 건 존재한다. 완전제곱수인 16의 약수를 살펴보자.        |-----| { 1, 2, 4, 8, 16}   |____________|      16의 약수 관계   위 그림에서 알 수 있듯이 완전제곱수인 경우에는 $\\lceil{c\\over2}\\rceil$번째 원소는 짝이 없다.  따라서$d_{\\lceil{c\\over2}\\rceil} * d_{\\lceil{c\\over2}\\rceil} = n$이 된다. 즉 4와 4를 곱하여 16을 만들 수 있다.   이 원리를 적용하면 최악의 경우 2부터 $\\sqrt{n}$까지만 탐색하면 모든 약수를 알 수 있다.   즉 100의 모든 약수를 구하려면 2부터 10까지만 조사해 보면 된다.   {2, 3, 4, 5, 6, 7, 8, 9, 10}   이 수들 중 10의 약수인 것만 찾아보면 다음과 같다.  {2, 4, 5, 10}  위 약수들을 이용하여 짝을 찾아서 정리하면 다음과 같다  {2, 4, 5, 10, 20, 25, 50}   여기에 1과 100은 당연히 100의 약수이므로 문제의 해는 다음과 같다.   1 + 2 + 4 + 5 + 10 + 20 + 25 + 50 + 100 = 217   탐색영역을 [2, $\\sqrt{n}$]로 설정할 때 일반적으로 다음과 같이 프로그램을 작성한다.   // include &lt;math.h&gt; for( i = 1 ; i &lt;= sqrt(n) ; i++ ) // 또는 for(i=1;i*i&lt;=n; i++)   이와 같이 간단한 수학적인 아이디어를 활용하면 효율적인 소스코드를 작성할 수 있으 므로 항상 이런 아이디어를 활용할 수 있도록 익혀두자.   이처럼 탐욕적인 방법을 이용하면 큰 범위의 수도 컴퓨터 없이 쉽게 계산할 수 있다. 그런데 이 방법을 프로그래밍으로 표현하기 위해서 주의할 점이 있다.   입력값 n이 100억 이기 때문에 자료형 int로는 이 값을 처리할 수 없다. 따라서 64bit형 정수인 long long int형을 활용해야 된다. 이 방법을 알고리즘으로 표현하면 다음과 같다.   #include &lt;stdio.h&gt; long long int n; long long int solve() {     long long int i, ans = 0;     for(i=1; i*i&lt;n; i++)       if(n%i==0)         ans+=(i+n/i);      if(i*i==n)        ans += i;     return ans; } int main() {   scanf(\"%lld\", &amp;n);   printf(\"%lld\\n\", solve());   return 0; }   소수 구하기   한 정수 n을 입력받는다. n번째로 큰 소수를 구하여 출력한다. 예를 들어 n이 5라면 자연수들 중 소수는 2, 3, 5, 7, 11, 13, ...이므로 구하고자 하는 5번째 소수는 11 이 된다.  ----------------------------------- 입력 첫 번째 줄에 정수 n이 입력된다.   ( 단, 1 &lt;= n &lt;= 100,000 ) 출력 n 이하의 소수들의 합을 구하여 출력한다.  입력 예         출력 예 5 11          77 389  일반적으로 소수를 구하는 방법은 약수가 2개라는 성질을 이용하는 경우가 많다. 이 성질을 이용하여 임의의 정수 $k$가 소수인지 판단하는 알고리즘을 다음과 같이 만들 수 있다.   bool isPrime(int k) {   int cnt=0;   for(int i=1; i&lt;=k; i++)     if(k%i==0) cnt++;   return cnt==2; }  이 방법은 계산량이 O($n$)이므로 효율이 좋지 않다. 결국 $k$번째 소수를 구하는 알고리즘은 O($nk$)정도의 계산량이 요구되므로 원하는 시간 내에 답을 구하지 못할 가능성이 크다.  효율을 높이기 위해서는 탐색공간의 배제가 필요하다. 어떤 아이디어로 탐색공간을 줄 일 수 있을까?   먼저 위 함수는 소수인지 판단하는 함수이며, 소수가 아니라면 약수가 몇 개이건 합성수인 것은 변함이 없으므로, 약수가 2개를 초과한다면 더 이상 탐색할 필요가 없다. 따라서 다음과 같이 isPrime 함수를 수정하여 탐색공간을 줄일 수 있다.   bool isPrime(int k) {   int cnt=0;   for(int i=1; i&lt;=k; i++) {     if(k%i == 0) cnt++;     if(cnt&gt;2) break;   }   return cnt==2; }   이와 같이 처리하면 대부분의 합성수는 매우 빠른 시간 내에 소수가 아님을 판정할 수 있다. 그리고 위 알고리즘을 다음과 같이 표현해도 된다. 각자 코딩스타일에 맞추어 원하는 방법을 익힐 수 있도록 한다.  bool isPrime(int k) {   int cnt=0;   for(int i=1; i&lt;=k &amp;&amp; cnt&lt;=2; i++) {     if(k%i == 0) cnt++;   }   return cnt==2; }  이번에 소스코드는 3행의 반복문의 반복조건을 바꾸어 처리하고 있다. 이렇게 하여 합성수를 빠르게 검사할 수 있지만 결국은 $k$번째 소수를 찾는 것이 목적이므로 소수를 검사할 때는 여전히 많은 시간이 걸린다.   소수를 보다 빠르게 검사할 수 있는 방법은 무엇일까?   다음 명제를 생각해보자.   임의의 자연수 $n$이 소수라면 $n$의 약수는 1과 n만 존재한다.   위 명제를 조금 변경하면 다음과 같은 원리를 생각할 수 있다.   임의의 자연수 $n$이 소수라면 구간 [2, $n-1$]에서 약수는 존재하지 않는다.   따라서 소수 판정 알고리즘을 다음과 같이 줄일 수 있다.   bool isPrime(int k) {   int cnt=0;   for(int i=2; i&lt;k; i++) {     if(k%i == 0) false;   }   return true; }   이 방법도 합성수는 매우 빠르게 판정할 수 있지만 소수 판정은 시간이 많이 걸리는 단점이 있다.   하지만 이 방법으로부터 소수를 매우 빠르게 판정할 수 있는 방법을 만들 수 있다.   주어진 범위에서 약수가 없어야 하므로, 약수의 존재성만 파악하면 된다. 약수의 존재성을 파악하기 위해서 모든 범위를 검사할 필요는 없다. 앞서 약수 문제에서 다루었던 것과 같이 $n$의 약수를 구하기 위해서 탐색을 $\\sqrt{n}$까지만 탐색하면 된다. 소수판정 에서도 이 원리를 그대로 적용할 수 있다. 이 원리를 적용하여 소수 판정 알고리즘을 완성 하면 다음과 같다.   bool isPrime(int k) {   int cnt=0;   for(int i=2; i*i&lt;=k; i++)     if(k%i == 0) return false;   return true; }   이 알고리즘은 매우 빠른 시간에 소수를 판정할 수 있다. O($\\sqrt{n}$)으로 처리할 수 있다. 이 방법보다 더 빠른 방법이 있다. “에라토스테네스의 체”라는 방법을 이용하 면 더 빠른 시간에 $k$번째 소수를 구할 수 있다. “에라토스테네스의 체”는 다음과 같은 단계를 거쳐 소수를 구한다.   준비. 2부터 n까지 차례로 숫자를 쓰고, 2부터 탐색을 시작한다. 1단계. 현재 탐색 중인 수가 지워지지 않았으면 그 수는 소수이다. 2단계. 1단계에서 그 수가 소수이면 그 수의 배수를 모두 지운다. 3단계. 만약 아직 탐색이 끝나지 않았으면 다음 수를 탐색할 준비를 하고 1단계로 간다. 4단계. 지워지지 않은 모든 수는 소수, 지워진 수는 합성수이다.   이 “에라토스테네스의 체”를 이용해도 빠른 시간에 $k$번째 소수를 구할 수 있다.   다음 포스트를 참고하면 좋다. - 에라토스테네스의 체   경험적 배제를 이용한 설계   경험적 배제는 전체탐색법을 기본으로 한 알고리즘 설계 방법이다. 처음 시작은 전체탐색과 마찬가지로 해가 될 수 있는 모든 공간을 탐색해 나간다. 차이점은 특정 조건을 두고, 이 조건을 기준으로 다음 상태를 계속 탐색할지의 여부를 결정 한다.   여기서의 특정 조건이란, 더 이상 탐색하더라도 해를 구할 수 없음을 판단할 수 있는 조건을 말한다. 이 조건의 설정은 알고리즘이 시작될 때는 정할 수 없고, 탐색을 진행하는 중 에 조건을 설정하고, 탐색한 영역이 넓어질수록 상황에 따라 조건이 갱신된다. 따라서 탐색 한 정보, 즉 경험한 정보를 이용해서 배제할 조건을 정하기 때문에 경험적 배제라고 한다.   경험적 배제는 일반적으로 가지치기(branch &amp; bound)라고 한다. 이는 마치 탐색구조를 나무로 비유하고, 탐색하지 않는 분기에 대해서 자르는 것이 마치 나무를 관리할 때 가치 를 쳐내는 것과 유사하여 붙여진 이름이다.   다음과 같은 탐색구조가 가지는 문제가 있다.      위 구조에서 각 번호는 탐색할 순서이다. 만약 2번에서 3번으로 진행하려고 할 때, 3번 정점이 알고리즘에서 설정한 조건을 만족한다면 3번 정점 이하의 모든 정점들을 더 이상 탐색할 필요가 없으며, 바로 9번으로 진행할 수 있다.      위 그림은 더 이상 필요 없음을 판단한 영역을 배제하고 탐색한 결과를 나타낸다. 이는 결과적으로 11회 탐색해야 할 문제를 6회의 탐색으로 동일한 결과를 얻을 수 있기 때문에 알고리즘의 효율을 향상시킬 수 있다.   일반적으로 더 이상 탐색할 정점이 없어서 되돌아오는 것을 백트랙 or 백트래킹(Backtracking)이라고 한다. 하지만 위의 예와 같이 3번 정점에서 되돌아 온 흐름은 백트랙과는 다르다.  이렇듯 어떤 조건에 의해서 더 탐색할 공간이 있음에도 불구하고 돌아오는 흐름을 바운딩(bounding) 혹은 커팅(cutting)라고 한다.   바운딩은 우리가 공을 벽에 던지면 튕겨 나오는 상태를 말한다. 마치 3번 정점이 벽과 같이서 흐름이 튕기는 것처럼 느껴지기 때문에 바운딩이라는 용어를 쓴다. 이 용어를 이해하면 branch &amp; bound라는 이름의 의미를 알 수 있다.   경험적 배제 기법의 핵심은 더 이상 탐색할 필요가 없는 지점을 판단하는 기준을 정하는 것이다. 이 판단의 근거는 일반적으로 탐색 중에 얻을 수 있는 정보를 활용하는 경우가 대부분이다. 앞에서 다루었던 전체탐색법의 예제들 중 분기한정으로 효율을 향상시킬 수 있는 예제를 통하여 조건을 설정하는 방법을 익혀보자.   연구활동 가는 길      *위의 그래프를 참고하여 문제를 풀어보자*  정올이는 GSHS에서 연구활동 교수님을 뵈러 A대학교를 가려고 한다. 출발점과 도착점을 포함하여 경유하는 지역 n개, 한 지역에서 다른 지역으로 가는 방법이 총 m 개이며  GSHS는 지역 1이고 A대학교는 지역 n이라고 할 때 대학까지 최소 비용을 구하시오.  단, n은 10 이하, m은 30 이하, 그리고 한 지역에서 다른 지역으로  가는 데에 필요한 비용은 모두 200 이하 양의 정수이며 한 지역에서 다른 지역으로 가는 어떠한 방법이 존재하면  같은 방법과 비용을 통해 역방향으로 갈 수 있다.  위의 그래프는 예를 보여준다. (단, 정점a-&gt;정점b로의 간선이 여러 개 있을 수 있으 며, 자기 자신으로 가는 정점을 가질 수도 있다.)  최소 비용이 드는 경로 : 1→3→5→7, 최소 비용 : 69+59+21=149  입력 첫 번째 줄에는 정점의 수 n과 간선의 수 m이 공백으로 구분되어 입력된다. 다음 줄부터 m개의 줄에 걸쳐서 두 정점의 번호와 가중치가 입력된다. (자기 간선, 멀티 간선이 있을 수 있다.)  출력 대학까지 가는 데 드는 최소 비용을 출력한다. 만약 갈 수 없다면 “-1”을 출력.  ---------------------------- 입력 예  7 11 1 2 47 1 3 69 2 4 57 2 5 124 3 4 37 3 5 59 3 6 86 4 6 27 4 7 94 5 7 21 6 7 40  출력 예 149    이 문제는 앞에서 전체탐색법으로 이미 해결했던 문제이다. 하지만 여기서 탐색을 배제 할 조건을 설정하여 탐색영역을 줄여보자. 먼저 탐색배제 조건을 설정해야 한다. 이 문제에서는 전체의 최소 이동거리를 구하는 것이므로 탐색 중 임의의 한 경로를 찾았을 때마다 새로운 거리를 구할 수 있으므로 탐색 중 다음과 같은 배제 조건을 설정할 수 있다.   현재 탐색한 거리 &gt; 지금까지 구한최소 경로의 거리  위 조건을 만족할 경우, 더 이상 탐색하지 않더라도 해를 구하는 데 전혀 문제가 없음을 알 수 있다. 이 조건을 적용하여 탐색하는 과정의 일부를 살펴보자.      위와 같은 단계를 거치면서 진행하게 되면 해는 점점 더 좋아지고 커팅의 효율은 더 높아진다.  위의 방법으로 작성한 소스코드는 다음과 같다.   #include &lt;stdio.h&gt; int n, m, G[11][11], sol=0x7fffffff, chk[11]; void solve(int V, int W) {   if(W&gt;sol) return;   if(V==n) {     if(W&lt;ol) sol=W;     return;   }   for(int i=1; i&lt;=n; i++)     if(!chk[i] &amp;&amp; G[V][i]) {       chk[i]=1;       solve(i, W+G[V][i]);       chk[i] = 0;       }    } int main(void) {   scanf(\"%d %d\", &amp;n, &amp;m);    for(int i=0; i&lt;m; i++) {     int s,e,w;     scanf(\"%d %d %d\", &amp;s, &amp;e, &amp;w);      G[s][e]=G[e][s]=w;   }   solve(1, 0);   printf(\"%d\\n\", sol==0x7fffffff ? ‐1:sol);   return 0; }   성능 검증을 하기 위하여 counter이라는 변수를 이용하여 해를 구하기까지 몇 개의 상태를 탐색하는지 카운팅하는 프로그램을 작성하고, 3번의 임의의 입력데이터를 이용하여 테스트를 해 보자.   검증하는 프로그램과 검증 데이터 셋은 다음과 같다.   #include &lt;stdio.h&gt; int n, m, G[11][11], sol=0x7fffffff, chk[11]; int counter; // 추가 void solve(int V, int W) {   if(W&gt;sol) return;   counter++;  // 추가   if(V==n) {     if(W&lt;ol) sol=W;     return;   }   for(int i=1; i&lt;=n; i++)     if(!chk[i] &amp;&amp; G[V][i]) {       chk[i]=1;       solve(i, W+G[V][i]);       chk[i] = 0;       }    } int main(void) {   scanf(\"%d %d\", &amp;n, &amp;m);    for(int i=0; i&lt;m; i++) {     int s,e,w;     scanf(\"%d %d %d\", &amp;s, &amp;e, &amp;w);      G[s][e]=G[e][s]=w;   }   solve(1, 0);      printf(\"%d\\n\", sol==0x7fffffff ? ‐1:sol);   printf(\"[탐색한 정점 수 %d개]\\n\", counter);    return 0; }   다음은 테스트 한 입력데이터 3개이다.   입력 1  5 7 1 2 2 1 3 10 1 4 7 2 5 4 2 3 6 4 5 3 3 5 4  입력 2 5 8 1 2 2 1 3 1 1 4 3  2 5 2 2 3 1 4 5 3 3 5 2  1 5 14  입력 3 7 11 1 2 47 1 3 69 2 4 57 2 5 124 3 4 37 3 5 59 3 6 86 4 6 27 4 7 94  5 7 21  6 7 40    위 3개의 데이터에 대한 결과이다.      다음은 배제된 공간의 비율을 보여준다.      위 표에서 알 수 있듯이 탐색한 정점의 수가 많이 줄어든 것을 알 수 있다. 대략적으로 원래 방법보다는 2배 이상 빨라졌음을 알 수 있다. 이는 데이터의 특성에 따라 달라질 수 있으니 참고하기 바란다.   이와 같은 알고리즘의 효율은 처음에 구한 해가 얼마나 질이 좋은 해인가에 따라 결정된다. 그렇다면 초반에 질이 좋은 해를 어떻게 구할 수 있을까? 앞에서 다룬 내용 중에 단순 탐욕법이라는 것이 있었다. 이는 현재 상태에서 수학적인 검증 없이 가장 유리한 상태만을 탐색하는 방법이다. 이 방법이 최적해를 구할 수는 없지만 비교적 질이 좋은 해를 구할 수 있다는 사실을 다루었다.   따라서 단순 탐욕법을 이용하여 처음에 하나의 해를 구한다. 일반적으로 이 해가 품질이 좋을 확률이 높으므로 이 해를 처음해로 탐색배제 조건의 기준이 된다. 그리고 위 알고리즘을 실행하면 평균적인 효율이 향상될 가능성이 크다.   단순 탐욕법으로 처음 해를 구하는 소스코드를 추가한 알고리즘은 다음과 같다.   #include &lt;stdio.h&gt; int n, m, G[1001][1001], sol, chk[1001], greedy_chk[1001];  void greedy_ans(int V) {   int W=0, t;   greedy_chk[V]=1;    while(V!=n) {     int min=0x7fffffff;     for(int i=1; i&lt;=n; i++)       if(!greedy_chk[i] &amp;&amp; G[V][i] &amp;&amp; G[V][i]&lt;min) {         greedy_chk[i]=1;         min=G[V][i];         t=i;       }     sol+=G[V][t];     V=t;   } }  void solve(int V, int W) {   if(W&gt;sol) return; // bounding (cutting)   if(V==n) {     if(W&lt;sol) sol=W;     return;   }   for(int i=1; i&lt;=n; i++)     if(!chk[i] &amp;&amp; G[V][i]) {       chk[i]=1;       solve(i, W+G[V][i]);       chk[i]=0;     }  }  int main(void) {   scanf(\"%d %d\", &amp;n, &amp;m);   for(int i=0; i&lt;m; i++) {     int s,e,w;     scanf(\"%d %d %d\", &amp;s, &amp;e, &amp;w);     G[s][e]=G[e][s]=w;   }   greedy_ans(1);   solve(1, 0);   printf(\"%d\\n\", sol==0x7fffffff ? ‐1:sol);   return 0; }   위 알고리즘에서 greedy_ans 함수가 처음 해를 단순 탐욕법으로 구하고 있는 과정을 나타낸다. 단순 탐욕법으로 구한 해는 정답이 아닐 가능성이 크지만, 해의 품질이 좋기 때문에 커팅의 조건으로 적합하다. 단순 탐욕법은 이와 같이 다양한 응용이 가능하다.   마지막으로 전체의 효율을 비교한 결과는 다음과 같다.      다음은 배제된 공간의 비율을 보여준다.      이와 같이 원래 알고리즘 보다 4배 이상 효율이 향상되었음을 알 수 있다. 이와 같이 탐색을 배제하는 방법은 정해진 것이 없고, 여기에서 소개한 방법은 가장 기본적인 배제 방법이다.   여기서 소개한 방법 이외에도 다양한 조건을 설정할 수 있으므로 공간을 배제할 방법을 스스로 설정하여 조건을 추가하면 효율이 좋아질 수 있으므로, 항상 창의적인 사고력을 기를 수 있도록 연습하자.  References      문제해결을 위한 창의적 알고리즘  ","categories": ["Algorithm"],
        "tags": ["Backtracking","Greedy","Data structure","Programming","Brute force"],
        "url": "http://localhost:4000/algorithm/%ED%83%90%EC%83%89%EA%B3%B5%EA%B0%84%EC%9D%98-%EB%B0%B0%EC%A0%9C/",
        "teaser":"http://localhost:4000/assets/images/creativealgorithm33.png"},{
        "title": "유니온 파인드(Union Find, Disjoint Set)",
        "excerpt":"Union-Find  컴퓨터 과학에서 서로소 찾기 집합 혹은 병합 찾기 집합이라 불리며 중복되지 않은 부분집합들의 원소 정보를 조작하고 저장하는 자료구조이다.   부분집합(Subset)에서 특정 원소 하나를 A, 또 다른 원소 하나를 B라 하면, 이 A나 B가 어느 부분집합에 속하는지, 또 A와 B가 각각 속한 부분집합 다르다면 이 두 부분집합을 하나의 집합으로 합쳐, 원소들이 겹치지 않는(Non-overlapping) 하나의 부분집합을 구성하는 것에 목적이 있다.   Representation  유니온 파인드 자료구조는 트리로 표현이 될 수 있습니다. 처음 N개의 원소 각각은 서로 다른 1개의 트리이자 부분집합이며 자기 자신이 최상위 루트이다. 각각의 부분집합을 구별할 땐 그 부분집합의 루트를 이용한다. 서로 다른 두개의 부분집합을 합칠 땐 하나의 부분집합의 루트를 다른 하나의 부분집합의 루트로 가리키게 한다.   Union-Find represented as a tree:      우리는 이를  “1 Dimention Array”로 표현이 가능하다.  index i\t  =  1, 2, 3, 4, 5, 6, 7  parent[i] = [2, 2, 2, 5, 5, 6, 7]  parent[1] = 2 -&gt; 원소 1은 원소 2를 부모로 한다.  parent[6] = 6 -&gt; 원소 6은 6 즉, 자기 자신을 부모로 한다.   Operations   다음은 유니온 파인드 자료구조를 위한 연산들이다.   Make set (Initialization)  유니온 파인드 자료구조를 위한 새로운 집합을 생성한다.  노드 각각이 자기 자신을 가리키도록 설정한다. (처음에는 자기 자신이 트리의 최상위 노드)   public void makeSet() {    for (int i = 0; i &lt; n; i++)      parent[i] = i; }   Make set operation:      배열의 상태는 아래와 같다.   index i   =  1, 2, 3, 4, 5, 6, 7 parent[i] = [1, 2, 3, 4, 5, 6, 7]   Find  우리는 두 원소가 서로 다른 부분집합에 속해있으면 두 부분집합을 Union 할 수 있다.  두 원소가 서로 같은 부분집합에 포함되어 있는지 아닌지 확인하기 위해 두 원소의 루트를 확인해야 한다.  Find 연산은 해당 원소가 속해있는 부분집합의 루트를 반환한다.      원소 x의 부모가 자기 자신이라면 그 부분집합의 루트이므로 x를 반환한다.   아니라면 재귀 호출로 x의 부모를 따라간다.   루트를 찾을 때까지 재귀 호출이 진행되다가 루트를 찾으면 원소 x의 루트를 반환한다.   int find(x) { // Recursive function     if (parent[x] == x)    // 원소 x의 부모가 자기자신이면 그 부분집합의 루트이므로        return x;        // x를 반환합니다.     else           return find(parent[x]); // 아니라면 x의 부모를 다시 재귀호출하여 루트를 찾습니다. }   Find(1) returns 2:      다음은 현재 배열의 상태이다.   index i   =  1, 2, 3, 4, 5, 6, 7 parent[i] = [2, 2, 2, 5, 5, 6, 7]   원소 1이 속한 부분집합의 루트를 알고 싶다면 Find(1)을 수행한다.  parent[1] != 1  두 값이 같지 않다.  그럼 parent[1]을 매개변수로 다시 Find(parent[1])을 재귀 호출한다.// 이는 부모를 따라가는 것이다.  parent[2] == 2 두 값이 같다! 2를 반환한다.   1의 루트는 2 임을 알 수 있다.   5를 보면.  find(5)를 수행하면  parent[5] == 5  두 값이 같다.  5의 부모는 5 자기 자신의 값이 되고, 이 말은 자기 자신이 루트란 말이므로 5를 반환한다.   Union  두 원소가 속한 부분집합이 다르면 두 부분집합을 하나의 부분집합으로 합칠 수 있다.  이를 수행하는 연산이 Union이다.      두 원소(x, y)가 속한 부분집합이 서로 같다면 return 한다.   같지 않다면 두 부분집합을 합친다.   Make set operation:      처음에 이렇게 7개의 서로 다른 부분집합이 있다. (자기 자신이 트리의 루트)   Union:      union(2,1), union(4,3), union(6,5)를 수행하면 위 그림처럼 트리가 구성된다.  2의 루트는 2이고 1의 루트도 1 자기 자신이다.  둘의 값이 다르므로 서로 다른 부분집합이고, 2는 1을 가리킴으로써 부분집합을 합친다.  union(4,3), union(6,5)도 마찬가지이다.   다음은 위 트리의 배열 상태이다.   index i   =  1, 2, 3, 4, 5, 6, 7 parent[i] = [1, 1, 3, 3, 5, 5, 7]   union(2, 4)를 하면 아래 그림처럼 된다.   Union(2, 4):      void union(int x, int y) {     xRoot = find(x) // find로 x의 루트를     yRoot = find(y)      if(xRoot == yRoot) // 두 원소가 속한 부분집합이 같으므로 리턴합니다.       return;     parent[x_root] = y_root; // 두 부분집합을 합칩니다. x의 루트를 y의 루트로 가리키게 합니다. }   2가 속한 부분집합의 루트(find(2))는 1이고, 4가 속한 부분집합의 루트(find(4))는 3이므로, 이 둘의 값이 다르고 1이 3을 가리킴으로써(parent [1] = 3) 같은 부분집합으로 합쳐준다.   아래는 위 트리의 배열 상태이다.   index i   =  1, 2, 3, 4, 5, 6, 7 parent[i] = [3, 1, 3, 3, 5, 5, 7]   Path compression   부분집합을 합치는 연산(유니온)을 수행하면서 아래 그림과 같이 편향적인 트리로 구성될 수 있다.  이때 노드의 개수가 n개일 때 find(n)을 수행하면 시간 복잡도는 $O(n)$가 된다.  아래 그림에서 5번 원소는 자기 부모를 타고 가다가 끝에는 루트 1을 만나게 된다. 링크를 4번 타고 가야 루트를 찾을 수 있다.  4번 원소도 링크를 3번 타고 가야 루트를 찾을 수 있다.   편향 트리:      우리는 여기서 한 가지 개선을 할 수 있다.   5번에서 1번 까지(5 - 4 - 3- 2 - 1)의 경로에 있는 모든 원소는 전부 루트를 1로 갖는다. 그렇다면 5번도 1을, 4번도 1을.. 2번도 1을 가리켜도 이 부분집합을 구성하는 원소는 변함이 없을 것이다. 이렇게 되면 아래 그림처럼 5번에서 2번까지 1번을 루트로서 바로 가리키게 되고 find(n) 연산 수행 시 시간 복잡도는 상수 시간 O(1)이 된다.   이것을 Path compression(경로 압축)이라 한다.   Union-Find with path compression:      find(5) 연산 수행 시 5에서 루트 1로 가는 경로에 있는 모든 원소를 재귀 호출이나 For loop을 이용해서 1을 루트로 바로 가리키게 구현할 수 있다.      x가 x의 부모와 같다면(자기 자신이 루트)라면 x를 반환한다.   다르다면 x의 부모는 x의 부모의 재귀 리턴 값이 된다.   재귀가 진행되면서 루트를 만나게 되면(매개변수로 들어온 값이 자기 자신 = 루트) x를 반환한다.   int find(x){      if (parent[x] != x)         parent[x] = find(parent[x]);      return x; }   Union by Rank   트리의 깊이 또는 높이는 유니온 파인드 연산 실행시간에 영향을 주는데 트리를 합칠 때 높이가 작은 트리를 높이가 큰 트리의 루트에 붙이면 높이가 높아지지 않는다. 이렇게 유니온 바이 랭크(union by rank)는 높이가 작은 트리를 큰 트리의 루트에 붙이는 방법이다.   ※ 단, 높이가 같은 트리를 합칠 땐 높이가 +1 높아진다.   우리는 여기서 랭크라는 표현을 쓰는데, 트리의 높이는 위에서 살펴본 path compresstion에 의해서 줄어들 수 있고 업데이트 되지 않기 때문이다. 그래서 랭크라는 표현을 쓴다.      어떤 원소 u가 한 트리의 루트이고 랭크 $r$을 가진다고 하면 유니온 바이 랭크 연산 하에 그 트리의 노드 수는 최소 $2^r$이 되고, 랭크 $r$로 같은 두 트리를 Union by rank 하면 랭크는 1 높아지게 되고 노드의 수는 $2^r + 2^r = 2^(r+1)$가 된다. 노드의 수는 2배가 되고 랭크는 1 높아지므로 연산 수행 시간이 $O(logn)$으로 보장이 된다.      원소마다 랭크 정보를 유지하기 위해서 Make set의 for loop에 rank [i] = 0을 추가해 준다.   for (i=1; i&lt;=n; i++){     parent[i] = i;     rank[i] = 0; // 처음에는 랭크가 전부 0 }  아래는 union by rank 코드이다.      두 원소의 루트를 구해서 서로 같다면 합치지 않고 유니온 연산을 종료한다.   그렇지 않다면, x의 루트랭크가 y의 루트랭크보다 크거나 같다면 y의 루트를 x의 루트 아래로 붙인다. (else 서로 스왑해서 수행)   두 트리의 랭크가 서로 같다면 랭크+1을 해준다. (두 트리의 랭크가 같으니 합치면 랭크가 +1 된다.)   void union(int x, int y)      xRoot = find(x);      yRoot = find(y);      if xRoot == yRroot          return        if (rank[xRoot] &gt;= rank[yRoot])          parent[yRoot] = xRoot;      else          parent[xRoot] = yRoot;        if (rank[xRoot] == rank[yRoot])          rank[yRoot] = rank[xRroot] + 1   Application   유니온 파인드는 무향 그래프에서의 사이클 존재 유무를 판별할 때 사용될 수 있다. (단, 셀프 루프는 없어야 한다.)   또한, 크루스칼 알고리즘에서 최소 스패닝 트리를 찾는데에 자료구조로서 사용된다.   최소 스패닝 트리는 노드의 수가 n개 일 때 n-1개의 최소 비용의 간선으로 이루어진 트리로서, 그래프에서 최소비용의 간선을 선택하면서 만들어지는 트리에 사이클이 형성되지 않아야 하기에 사이클 형성 유무 판별에 유니온 파인드가 사용된다.   Link: 크루스칼 알고리즘 글 보러가기.   Union by Lank with Path Compression   class unionFind{     private int parent[];     private int rank[];     private int n;       unionFind(int cnt) {         this.n = cnt;         parent = new int[n];         rank = new int[n];     }       public void makeSet() {         for (int i = 0; i &lt; n; i++) {             parent[i] = i;             rank[i] = 0;         }     }       public int find(int x) {         if (parent[x] == x)             return x;         else             return parent[x] = find(parent[x]); // * 경로 압축     }       public void union(int root1, int root2) {         root1 = find(root1);         root2 = find(root2);           if (root1 == root2) // 루트가 같다면 수행하지 않는다.             return;           if (rank[root1] &gt;= rank[root2]) { // 루트1의 랭크가 루트2의 랭크보다 크다면             parent[root2] = parent[root1]; //루트2가 루트1의 밑으로 합친다         } else { // 위의 if문 과 반대             parent[root1] = parent[root2];         }         if (rank[root1] == rank[root2])             rank[root1]+=1;     } }   백준 온라인 저지에 있는 유니온 파인드 문제 1717번 집합의 표현 코드이다.   BOJ - 1717번  import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.StringTokenizer;  public class Main {     public static void main(String[] args) throws IOException {         BufferedReader br = new BufferedReader(new InputStreamReader(System.in));         StringTokenizer st = new StringTokenizer(br.readLine());         StringBuilder sb = new StringBuilder();         int n = Integer.parseInt(st.nextToken());         int m = Integer.parseInt(st.nextToken());         unionFind h = new unionFind(n+1);         h.makeSet();         for (int i = 0; i &lt; m; i++) {             st = new StringTokenizer(br.readLine());             int operation = Integer.parseInt(st.nextToken());             int a = Integer.parseInt(st.nextToken());             int b = Integer.parseInt(st.nextToken());             if(operation == 0)                 h.union(a ,b);             else                 sb = h.find(a) == h.find(b) ?                  sb.append(\"YES\").append(\"\\n\") : sb.append(\"NO\").append(\"\\n\");         }         System.out.println(sb.toString());     } }  class unionFind {     private int parent[];     private int rank[];     private int n;      unionFind(int cnt) {         this.n = cnt;         parent = new int[n];         rank = new int[n];     }      public void makeSet() {         for (int i = 0; i &lt; n; i++) {             parent[i] = i;             rank[i] = 0;         }     }      public int find(int x) {         if (parent[x] == x)             return x;         else             return parent[x] = find(parent[x]); // * 경로 압축     }      public void union(int root1, int root2) {         root1 = find(root1);         root2 = find(root2);          if (root1 == root2) // 루트가 같다면 수행하지 않는다.             return;          if (rank[root1] &gt;= rank[root2]) { // 루트1의 랭크가 루트2의 랭크보다 크다면             parent[root2] = parent[root1]; //루트2가 루트1의 밑으로 합친다         } else { // 위의 if문 과 반대             parent[root1] = parent[root2];         }         if (rank[root1] == rank[root2])             rank[root1]+=1;     } }   References      Union Find - Wikipedia   Union Find - Algocoding  ","categories": ["Data Structure"],
        "tags": ["programming","Data Structure"],
        "url": "http://localhost:4000/data%20structure/unionfind/",
        "teaser":"http://localhost:4000/assets/images/withoutunionbylank.png"}]
