I"<h1 id="선형구조의-탐색">선형구조의 탐색</h1>

<p>선형구조란 자료의 순서를 유일하게 결정할 수 있는 형태의 구조를 말한다. $i$번째 자료 를 탐색한 다음, $i+1$번째로 탐색해야할 자료가 유일한 형태를 의미한다. 2차원, 3차원 구조라도 순서가 일정하게 정해져 있으면 이는 선형이라고 할 수 있다.</p>

<p>선형구조는 주로 배열과 리스트의 형태로 저장된다. 일반적으로 1차원 배열에 자료를 저장하는 1차원 선형구조와 2차원 이상의 배열에 자료가 저장이 되어있는 다차원 선형구조로 나눌 수 있다.</p>

<p>선형구조의 탐색은 선형구조로 저장된 자료들 중에서 원하는 것을 찾는 작업을 말한다. 선형구조를 탐색하는 방법은 기본적으로 순차탐색과 이분탐색이 있고, 이들을 적절히 응용한 탐색법도 만들어 사용할 수 있다. 이 단원에서는 순차탐색과 이분탐색을 익히고 이를 통하여 간단한 문제를 해결하는 실습을 한다.</p>

<h2 id="순차탐색">순차탐색</h2>

<p>순차탐색은 자료의 특성에 관계없이 사용할 수 있는 일반적인 방법으로 전체탐색기법의 한 방법이다. 첫 번째 원소로부터 시작하여 한 원소씩 차례로 다음 원소를 탐색해 나가는 방법으로 자료가 $n$개 있을 때의 계산량은 $O(n)$이다.</p>

<p>탐색 순서를 그림으로 나타내면 다음과 같다.</p>

<p><img src="/assets/images/creativealgorithm42.png" alt="Alt text" width="500px" height="300px" /></p>

<p>다음은 선형탐색을 구현한 소스코드이다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">LinearSearch</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">linearSearch</span><span class="o">(</span><span class="kt">int</span> <span class="no">S</span><span class="o">[],</span> <span class="kt">int</span> <span class="n">k</span><span class="o">){</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="no">S</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="no">S</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="n">k</span><span class="o">)</span>
                <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="no">S</span><span class="o">[]</span> <span class="o">=</span> <span class="o">{</span><span class="mi">5</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">8</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">4</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">linearSearch</span><span class="o">(</span><span class="no">S</span><span class="o">,</span> <span class="n">k</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="이분탐색">이분탐색</h2>

<p>이분탐색은 배열에서 중간 원소를 선택하여 찾는 값과 비교하고 중간 원소의 값이 찾는 값보다 작다면 중간 원소를 기준으로 오른쪽을 탐색, 중간 원소의 값이 찾는 값보다 크다면 중간 원소를 기준으로 왼쪽을 탐색하는 기법이다. 이 알고리즘은 오름차순이나 내림차순으로 정렬된 선형구조에서 원하는 원소를 찾는 것으로 계산량은 $O(log_2n)$이다.</p>

<p><img src="/assets/images/creativealgorithm43.png" alt="Alt text" width="500px" height="300px" /></p>

<p class="notice--info">이분탐색의 탐색순서(원은 처음 접근하는 원소이고, 사각형은 찾은 곳의 값이 찾으려는 값보다 작으면 찾는 위치, 둥근 사각형은 그 값의 반대조건일 경우에 탐색하는 위치이다. 조건의 결과에 따라 왼쪽 또는 오른쪽 중 하나를 탐색하게 된다.)</p>

<p>다음은 이분탐색을 구현한 C++ 소스코드이다.<br />
$S$에 $n$개의 원소를 입력받고, 그 중에 $k$가 있는지를 찾는 알고리즘이다.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 이분탐색 - 반복</span>
<span class="cp">#include &lt;stdio.h&gt;
</span><span class="kt">int</span> <span class="n">S</span><span class="p">[</span><span class="mi">100</span><span class="p">],</span> <span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">find</span><span class="p">(</span><span class="kt">int</span> <span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">while</span><span class="p">(</span><span class="n">s</span><span class="o">&lt;=</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// s가 e보다 작거나 같을 때 까지</span>
    <span class="kt">int</span> <span class="n">m</span><span class="o">=</span><span class="p">(</span><span class="n">s</span><span class="o">+</span><span class="n">e</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span> <span class="c1">// 중간 원소</span>
    <span class="k">if</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">==</span><span class="n">k</span><span class="p">)</span> <span class="k">return</span> <span class="n">m</span><span class="p">;</span> <span class="c1">// 찾았다</span>

    <span class="c1">// 탐색한 원소가 찾고자 하는 원소 보다 크다</span>
    <span class="c1">//탐색한 원소의 왼쪽 배열 탐색</span>
    <span class="k">if</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">&gt;</span><span class="n">k</span><span class="p">)</span> <span class="n">e</span><span class="o">=</span><span class="n">m</span><span class="err">‐</span><span class="mi">1</span><span class="p">;</span> 
    <span class="c1">// 탐색한 원소가 찾고자 하는 원소 보다 작다</span>
    <span class="c1">//탐색한 원소의 오른쪽 배열 탐색</span>
    <span class="k">else</span> <span class="n">s</span><span class="o">=</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="err">‐</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// 원하는 원소를 찾지 못했다.</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">scanf</span><span class="p">(</span><span class="s">"%d%d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">k</span><span class="p">);</span>
  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span>
    <span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span> 
  <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">find</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="err">‐</span><span class="mi">1</span><span class="p">));</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<hr />
<p>다음은 재귀로 이분탐색을 구현한 java 소스코드이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1">// 이분탐색 - 재귀</span>
<span class="kn">import</span> <span class="nn">java.io.BufferedReader</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.InputStreamReader</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.StringTokenizer</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">BinarySearchRecur</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="no">S</span><span class="o">[]</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">100</span><span class="o">];</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="n">k</span><span class="o">;</span> <span class="c1">// 배열 크기, 찾고자 하는 원소</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">find</span><span class="o">(</span><span class="kt">int</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">e</span><span class="o">){</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">s</span> <span class="o">&gt;</span> <span class="n">e</span><span class="o">)</span> <span class="c1">// 원하는 원소를 찾지 못했다</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="o">(</span><span class="n">s</span><span class="o">+</span><span class="n">e</span><span class="o">)/</span><span class="mi">2</span><span class="o">;</span> <span class="c1">// 중간 원소</span>
        <span class="k">if</span> <span class="o">(</span><span class="no">S</span><span class="o">[</span><span class="n">m</span><span class="o">]</span> <span class="o">==</span> <span class="n">k</span><span class="o">)</span> <span class="c1">// 찾았다</span>
            <span class="k">return</span> <span class="n">m</span><span class="o">;</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="no">S</span><span class="o">[</span><span class="n">m</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">k</span><span class="o">)</span> <span class="c1">// 탐색한 원소가 찾고자 하는 원소 보다 작다</span>
            <span class="k">return</span> <span class="nf">find</span><span class="o">(</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">e</span><span class="o">);</span> <span class="c1">//탐색한 원소의 오른쪽 배열 탐색</span>
        <span class="k">else</span>               <span class="c1">// 탐색한 원소가 찾고자 하는 원소 보다 크다</span>
            <span class="k">return</span> <span class="nf">find</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span> <span class="c1">//탐색한 원소의 왼쪽 배열 탐색</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
        <span class="nc">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span> <span class="c1">// n, k</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
        <span class="n">k</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
        <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span> <span class="c1">// S array</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="no">S</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="no">S</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">find</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">));</span> <span class="c1">// index 반환</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="cm">/* 
Test Case
-----------
input
5 19
3 4 2 19 4

output
3
-----------
input
5 10
3 4 2 19 4

output
-1

*/</span>
</code></pre></div></div>
<hr />

<p><strong>기본적인 탐색방법을 익힐 수 있는 다음 문제들을 해결해보자.</strong></p>

<h3 id="최댓값">최댓값</h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>9개의 서로 다른 자연수가 주어질 때, 이들 중 최댓값을 찾고 
그 값이 몇 번째 수 인지를 구하는 프로그램을 작성하시오.

예를 들어, 서로 다른 9개의 자연수가 각각
3, 29, 38, 12, 57, 74, 40, 85, 61 라면, 

이 중 최댓값은 85이고, 이 값은 8번째 수이다.

----------------------------------------

입력
첫째 줄부터 아홉째 줄까지 한 줄에 하나의 자연수가 주어진다. 주어지는 자연수 는 100보다 작다.

출력
첫째 줄에 최댓값을 출력하고, 둘째 줄에 최댓값이 몇 번째 수인지를 출력한다.

입력 예      출력 예
3          85
29         8
38
12
57
74 
40 
85 
61
</code></pre></div></div>

<p>이 문제는 자료를 1차원 배열에 저장한 후 반복문을 이용하여 전체탐색법을 구현하면 쉽게 구할 수 있다. 전체탐색을 하더라도 탐색해야할 자료의 수가 9개뿐이므로 충분히 빠른 시간 내에 해를 구할 수 있는 기본적인 문제이다.</p>

<p>따라서 반복문을 구현하는 연습을 할 수 있는 문제로 이 문제를 해결하는 방법이 다른 문제들을 해결하는 도구로 많이 활용될 수 있으므로 꼭 익혀둘 수 있도록 한다.</p>

<p>일단 먼저 문제해결 아이디어를 생각하자. 최종적으로 출력할 해를 변수 ans로 두고, 최댓값의 인덱스를 저장할 변수를 index로 설정한다.</p>

<p>먼저 모든 자료를 탐색하기 전에 ans를 모든 원소들 보다 작은 값으로 설정한다. 이 문제에서는 100 이하의 자연수가 데이터의 정의역이므로, 0으로 설정하면 된다. 다음 으로 첫 번째 자료부터 마지막 자료까지 하나씩 검사해가며 현재까지 ans보다 더 큰 값이 나타나면 ans를 갱신하고, index값도 갱신한다.</p>

<p>마지막 자료까지 탐색을 마치면, ans와 index를 출력하면 된다. 이 과정을 입출력 예를 통해서 알아보자.</p>

<p><img src="/assets/images/creativealgorithm44.png" alt="Alt text" width="700px" height="300px" /></p>

<p><img src="/assets/images/creativealgorithm45.png" alt="Alt text" width="700px" height="800px" /></p>

<p><img src="/assets/images/creativealgorithm46.png" alt="Alt text" width="700px" height="300px" /></p>

<p>이와 같이 배열을 선형으로 전체탐색을 하면서 최댓값을 구할 수 있다. 이 방법은 가장 기본적인 방법 중 하나로 다른 알고리즘에 많이 응용되는 방법이다.</p>

<p>이를 프로그램으로 구현하면 다음과 같다.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt; 
#define MAXN 9
</span><span class="kt">int</span> <span class="n">ans</span><span class="p">,</span> <span class="n">A</span><span class="p">[</span><span class="n">MAXN</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>

<span class="kt">void</span> <span class="nf">solve</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="n">A</span><span class="o">+</span><span class="n">i</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">ans</span><span class="p">]</span><span class="o">&lt;</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="n">ans</span><span class="o">=</span><span class="n">i</span><span class="p">;</span> 
  <span class="p">}</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">solve</span><span class="p">();</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">A</span><span class="p">[</span><span class="n">ans</span><span class="p">],</span> <span class="n">ans</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>ans, index를 하나의 변수 ans로 처리하고 있다. 그리고 9행에서 입력 받을 때 “&amp;A[i]” 대신 “A+i”를 활용하고 있다. 이러한 코딩 스타일도 자주 활용되는 방법으로 배열과 포인터를 이해하면 위와 같이 사용할 수 있음을 알 수 있다. 이와 같을 때에는 특수문자로 인한 오타의 확률도 줄일 수 있으므로 다양한 방법을 익힐 수 있도록 하자.</p>

<h3 id="3의-배수-게임">3의 배수 게임</h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>3의 배수 게임을 하던 정올이는 3의 배수 게임에서 잦은 실수로 
계속해서 벌칙을 받게 되었다.
3의 배수 게임의 왕이 되기 위한 마스터 프로그램을 작성해 보자.

** 3의 배수 게임이란?

여러 사람이 순서를 정해 순서대로 수를 부르는 게임이다.
만약 3의 배수를 불러야 하는 상황이라면, 그 수 대신 "박수" 를 친다.

----------------------------------------------

입력
첫 째 줄에 하나의 정수 n이 입력된다(n은 10미만의 자연수이다.).
출력
1부터 그 수까지 순서대로 공백을 두고 수를 출력하는데, 
3 또는 6 또는 9인 경우 그 수 대신 영문 대문자 X 를 출력한다.

입력 예      출력 예
7          1 2 X 4 5 X 7
</code></pre></div></div>

<h2 id="비선형-구조">비선형 구조</h2>

<p>비선형 구조의 탐색을 다루기 전에 그래프와 트리에 대해서 간단히 알아보자.<br />
트리와 그래프를 이루는 기본 요소를 정점(vertex)과 간선(edge)이라고 한다.</p>

<p><img src="/assets/images/creativealgorithm1.png" alt="Alt text" width="500px" height="300px" /></p>

<p>원은 정점, 선분은 간선을 나타내며, a-b는 보통간선, a-&gt;b는 방향간선, b-d는 가중치가 15인 양방향통행 간선, d-&gt;e는 가중치가 7인 일방통행 간선(방향간선)을 나타낸다.<br />
정점은 점 또는 원으로 표현하며, 일반적으로 상태나 위치를 표현한다. 간선은 정점들을 연결하는 선으로 표현하며, 정점들 간의 관계를 표현한다.</p>

<h3 id="경로path와-회로cycle">경로(path)와 회로(cycle)</h3>

<p>그래프에서 임의의 정점 s에서 임의의 정점 t로 이동할 때, s에서 t로 이동하는데 사용한 정점들을 연결하고 있는 간선들의 순서로 된 집합을 경로라고 한다. 회로는 그래프에서 임 의의 정점 s에서 같은 정점 s로의 경로들을 말한다.</p>

<p><img src="/assets/images/creativealgorithm2.png" alt="Alt text" width="550px" height="300px" /></p>

<h3 id="자기간선loop과-다중간선multi-edge">자기간선(loop)과 다중간선(multi edge)</h3>

<p>임의의 정점에서 자기 자신으로 연결하고 있는 간선을 자기간선, 임의의 정점에서 다른 정점으로 연결된 간선의 수가 2개 이상일 경우를 다중간선이라고 한다.</p>

<p><img src="/assets/images/creativealgorithm3.png" alt="Alt text" width="550px" height="300px" /></p>

<h3 id="그래프의-차수degree">그래프의 차수(degree)</h3>
<p>그래프의 임의의 한 정점에서 다른 정점으로 연결된 간선의 수를 차수라고 한다.</p>

<p><img src="/assets/images/creativealgorithm4.png" alt="Alt text" width="550px" height="300px" /></p>

<h2 id="그래프의-구현">그래프의 구현</h2>

<p>그래프를 구현하는 방법은 인접행렬(adjacency matrix)과 인접리스트(adjacency list)로 크게 나눌 수 있다.</p>

<p class="notice--info">tip: 프로그래밍 대회에서 그래프는 보통 정점의 수, 간선의 수, 각 간선들이 연결하고 있는 정점 2개로 이루어진 정보가 주어진다.</p>

<p>다음과 같은 그래프가 주어질 때, 이를 표현하는 2가지 방법을 알아본다.</p>

<p><img src="/assets/images/creativealgorithm5.png" alt="Alt text" width="550px" height="300px" /></p>

<p><strong>위 그래프의 입력 형식과 입력 데이터의 예</strong></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>입력 형식:
첫 번째 줄에 정점의 수 n과 간선의 수 m 이 공백으로 구분되어 입력된다.
두 번째 줄부터 m개의 줄에 걸쳐서 간선으로 연결된 두 정점의 번호와 가중치가  
공백으로 구분되어 입력된다.

입력 데이터:
7 11
1 2 47 
1 3 69 
2 4 57 
2 5 124 
3 4 37 
3 5 59 
3 6 86 
4 6 27 
4 7 94 
5 7 21 
6 7 40
</code></pre></div></div>

<h3 id="인접행렬의-구현">인접행렬의 구현</h3>

<p>입력예시를 인접행렬로 받기 위해서는 2차원 배열을 이용한다.<br />
먼저 최대 정점의 수에 맞추어 2차원 배열을 선언하고 각 배열의 칸에 연결된 정보를 저장한다.<br />
앞 그래프를 2차원 행렬을 이용하여 다음과 같이 저장한다.</p>

<p><img src="/assets/images/creativealgorithm6.png" alt="Alt text" width="650px" height="500px" /></p>

<p>2차원 행렬을 이용하여 저장하는 소스코드는 다음과 같다. 단 최대 정점의 수는 100개 로 가정한다.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">C</span> <span class="n">language</span>
<span class="cp">#include &lt;stdio.h&gt; 
</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">G</span><span class="p">[</span><span class="mi">101</span><span class="p">][</span><span class="mi">101</span><span class="p">];</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">scanf</span><span class="p">(</span><span class="s">"%d %d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">n</span><span class="p">,</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">w</span><span class="p">;</span>
        <span class="n">scanf</span><span class="p">(</span><span class="s">"%d %d %d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">w</span><span class="p">);</span>
        <span class="n">G</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="n">b</span><span class="p">]</span><span class="o">=</span><span class="n">G</span><span class="p">[</span><span class="n">b</span><span class="p">][</span><span class="n">a</span><span class="p">]</span><span class="o">=</span><span class="n">w</span><span class="p">;</span>
    <span class="p">}</span> 
<span class="p">}</span>
</code></pre></div></div>

<h3 id="인접리스트의-구현">인접리스트의 구현</h3>

<p>인접행렬로 표현할 때에는 연결되지 않았던 부분까지 모두 표현이 된다. 즉, 각 칸에 0 이라고 기록된 부분은 연결이 되지 않은 부분을 의미한다. 사실 일반적인 그래프에서 행렬 상에서 0이라고 표현되는 부분이 많을 가능성이 크다.</p>

<p>알고리즘을 구현할 때에도 이 0이라고 표시된 부분까지 모두 조사를 해야 하므로 효율 이 떨어지는 경우가 많다. 이러한 단점을 극복하기 위하여 제안된 방법이 인접리스트이고 이 방법은 인접행렬에서 0으로 표시된 부분은 저장하지 않으므로 효율을 높이고 있다.</p>

<p><img src="/assets/images/creativealgorithm7.png" alt="Alt text" width="650px" height="300px" /></p>

<p><img src="/assets/images/creativealgorithm8.png" alt="Alt text" width="650px" height="300px" /></p>

<p>위의 입력 예시를 인접리스트로 구현하기 위해서는 [그림-10], [그림-11]과 같이 연결리스트로 구현할 수 있지만 STL에서 제공하는 C++의 std::vector()를 이용하면 보다 더 간단하게 구현할 수 있다. 위의 입력예시를 인접리스트로 구현하면 다음과 같은 그림이 된다.</p>

<p><img src="/assets/images/creativealgorithm9.png" alt="Alt text" width="650px" height="300px" /></p>

<p>C++의 std::vector()를 이용한다면 위와 같이 인접행렬로 구현하는 것보다 공간을 더 적게 사용한다. 따라서 전체탐색법을 구현할 때, 당연히 탐색시간도 줄일 수 있다. 계산량으로 표현하자면, 인접행렬로 모든 정점을 탐색하는데 O($n^2$)의 시간이 드는데 반해, 인접리스트로 표현하면 O(n+m)의 시간이 든다.</p>

<p class="notice--info">여러 가지 장점으로 인해 인접리스트를 이용한 방법을 활용하는 경우가 많으므로 반드시 익혀둘 수 있도록 하자.</p>

<h2 id="비선형-구조의-탐색">비선형 구조의 탐색</h2>

<h3 id="깊이우선탐색dfs">깊이우선탐색(dfs)</h3>

<p>그래프 중 회로(cycle)가 없는 그래프를 트리라고 한다. 다음 그림은 트리를 나타낸다. 이 트리의 가장 위에 있는 정점에서 출발하여 모든 정점들을 깊이우선으로 탐색하며, 탐색 하는 순서를 알아보자.</p>

<p><img src="/assets/images/creativealgorithm10.png" alt="Alt text" width="650px" height="300px" /></p>

<p>출발 정점을 트리의 가장 위에 있는 정점으로 하고, 한 정점에서 이동 가능한 정점이 여 러 개 있을 경우 왼쪽의 정점부터 방문한다고 가정하면, 단계별 탐색 과정은 다음과 같다.</p>

<p><img src="/assets/images/creativealgorithm11.png" alt="Alt text" width="650px" height="300px" /></p>

<p>깊이우선탐색과정에서 3단계 이후 더 이상 진행할 수 있는 정점이 없다. 그 이유는 간선 으로 연결된 정점들 중 아직 방문하지 않은 정점을 방문하기 때문이다.</p>

<p>이처럼 더 이상 진행할 수 없을 때는 다시 이전 정점으로 되돌아가는 과정이 필요하다. 일반적으로 이 과정을 백트랙(backtrack)이라고 한다. 백트랙은 비선형 구조의 탐색에서 매 우 중요하다. 백트랙은 스택(stack)이나 재귀함수(recursion)를 이용하면 쉽게 구현할 수 있다.</p>

<p><img src="/assets/images/creativealgorithm12.png" alt="Alt text" width="650px" height="300px" /></p>

<p>4, 5, 6단계는 연속으로 백트랙이 발생한다. 이는 더 이상 진행할 수 없는 정점까지 도달 했다는 것을 의미한다. 계속 해서 다음 단계로 진행하는 과정은 다음과 같다.</p>

<p><img src="/assets/images/creativealgorithm13.png" alt="Alt text" width="650px" height="300px" /></p>

<p>위 단계에서 마지막 정점을 방문하면 깊이우선탐색이 완료된다.</p>

<p><img src="/assets/images/creativealgorithm14.png" alt="Alt text" width="650px" height="300px" /></p>

<p>깊이우선탐색을 정리하여 설명하면 먼저 시작 정점에서 간선을 하나 선택하여 진행할 수 있을 때까지 진행하고 더 이상 진행할 수 없다면 백트랙하여 다시 다른 정점으로 진행 하여 더 이상 진행할 정점이 없을 때까지 이 과정을 반복하는 탐색법으로, 간선으로 연결 된 모든 정점을 방문할 수 있는 탐색법이다.</p>

<p>깊이우선탐색의 알고리즘은 다음과 같다. 이 탐색법은 백트래킹(backtracking)이라는 알 고리즘 설계 기법의 중심이 되며 백트래킹 기법은 모든 문제를 해결할 수 있는 가장 기본 적인 방법이므로 꼭 익혀둘 필요가 있다.</p>

<p>깊이우선탐색</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="n">visited</span><span class="p">[</span><span class="mi">101</span><span class="p">];</span> <span class="c1">//방문했는지 체크해 두는 배열</span>
<span class="kt">void</span> <span class="nf">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="p">){</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">G</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span> <span class="c1">// 정점 k와 연결된 모든 정점 방문</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">G</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">to</span><span class="p">]){</span> <span class="c1">// 만약 아직 방문하지 않았으면</span>
            <span class="n">visited</span><span class="p">[</span><span class="n">G</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">to</span><span class="p">]</span><span class="o">=</span><span class="nb">true</span><span class="p">;</span> <span class="c1">// 방문했다고 체크하고</span>
            <span class="c1">// 깊이우선탐색 진행</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">i</span><span class="p">]);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span><span class="p">;</span> <span class="c1">//더 이상 갈 길이 없으면 backtrack</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이 방법은 그래프를 인접리스트에 저장했을 경우에 활용할 수 있다. 전체를 탐색하는데 있어서 반복문의 실행횟수는 모두 m 번이 된다. 일반적으로 인접행렬 보다 속도가 더 빠르기 때문에 자주 활용된다.</p>

<hr />

<h3 id="너비우선탐색bfs">너비우선탐색(bfs)</h3>

<p>너비우선탐색은 깊이우선탐색과는 달리 현재 정점에서 깊이가 1인 정점을 모두 탐색한 뒤 깊이를 늘려가는 방식이다. 위에서 다룬 ‘10개의 정점과 9개의 간선을 가진 트리’를 통해서 너비우선탐색을 살펴보자.</p>

<p><img src="/assets/images/creativealgorithm15.png" alt="Alt text" width="650px" height="300px" /></p>

<p>먼저 1단계부터 4단계까지를 살펴보면 1에서 출발하여 깊이가 1인 세 정점을 모 두 순차적으로 방문한다. 계속해서 너비우선탐색의 결과를 살펴보면 다음과 같다.</p>

<p><img src="/assets/images/creativealgorithm16.png" alt="Alt text" width="650px" height="300px" /></p>

<p><img src="/assets/images/creativealgorithm17.png" alt="Alt text" width="650px" height="300px" /></p>

<p>너비우선탐색은 백트랙을 하지 않는다. 대신에 현재 정점에서 깊이가 1인 정점을 모두 방문해야 하므로 큐(queue)라는 선입선출(FIFO) 자료구조를 활용하여 현재 정점에서 깊이가 1 더 깊은 모든 정점을 순차적으로 큐에 저장하여 탐색에 활용한다.<br />
따라서 STL에서 제 공하는 std::queue()를 활용하는 방법을 익힐 필요가 있다.</p>

<p>너비우선탐색 알고리즘은 다음과 같다.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;queue&gt;
</span><span class="kt">bool</span> <span class="n">visited</span><span class="p">[</span><span class="mi">101</span><span class="p">];</span>
<span class="kt">void</span> <span class="nf">bfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="p">){</span>
    <span class="n">std</span><span class="o">::</span><span class="n">queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">Q</span><span class="p">;</span>
    <span class="n">Q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="n">visited</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">Q</span><span class="p">.</span><span class="n">empty</span><span class="p">()){</span>
        <span class="kt">int</span> <span class="n">current</span><span class="o">=</span><span class="n">Q</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
        <span class="n">Q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">G</span><span class="p">[</span><span class="n">current</span><span class="p">].</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">G</span><span class="p">[</span><span class="n">current</span><span class="p">][</span><span class="n">i</span><span class="p">]])</span> <span class="p">{</span>
                <span class="n">visited</span><span class="p">[</span><span class="n">G</span><span class="p">[</span><span class="n">current</span><span class="p">][</span><span class="n">i</span><span class="p">]]</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
                <span class="n">Q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">current</span><span class="p">][</span><span class="n">i</span><span class="p">]);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이 방법은 그래프를 인접리스트에 저장했을 경우에 활용할 수 있으며, 전체를 탐색하는 데 있어서 반복문의 실행횟수는 모두 m번이 된다. 따라서 일반적으로 속도가 인접행렬 보다 더 빠르기 때문에 자주 활용된다.</p>

<h3 id="references">References</h3>

<ul>
  <li>문제해결을 위한 창의적 알고리즘</li>
</ul>
:ET