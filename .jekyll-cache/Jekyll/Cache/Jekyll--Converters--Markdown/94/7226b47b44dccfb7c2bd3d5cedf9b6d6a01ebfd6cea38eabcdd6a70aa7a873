I"-<h1 id="삽입-정렬insertion-sort">삽입 정렬(Insertion sort)</h1>

<p>삽입 정렬은 <strong>안정 정렬이자 제자리 정렬</strong> 알고리즘이다.</p>

<p>비교적 심플한 정렬 알고리즘으로서 일상 생활에서도 번호에 따라 카드를 정렬할 때 대부분 이 방법을 사용하곤 한다.
이 알고리즘에서는 각 원소를 정렬된 부분 배열(Sorted partial array)의 적절한 위치에 삽입한다.</p>

<p>삽입 정렬의 시간복잡도는 최악 기준 $O(n^2)$이므로 큰 리스트에는 비효율적이며, 유사한 시간복잡도를 갖는 선택 정렬이나 버블소트 보다는 성능이 좋지만, $O(nlogn)$의 시간복잡도를 같는 퀵 소트나 머지소트 같은 소팅 알고리즘 보다는 덜 효율적이다.</p>

<p>그러나, 삽입 정렬은 원소의 숫자가 적은 배열이나 리스트(원소의 개수가 10-20개 이하)에서는 일반적으로 퀵 소트나 머지소트 보다 효율적이여서, 실무에서는 다른 $O(nlongn)$의 시간복잡도를 갖는 소팅 알고리즘과 함께 정렬에 사용되어지고 있다. (ex. Tim sort)</p>

<p><strong>안정 정렬과 제자리 정렬 이란?</strong></p>

<p class="notice--warning"><strong>안정 정렬:</strong> 정렬이 끝나면 <strong>같은 키값</strong>을 가진 원소들의 <strong>상대적인 순서</strong>가 변하지 않는 것을 의미.<br />
안정 정렬 알고리즘으로는 <strong>삽입 정렬, 머지소트, 카운팅 소트</strong> 등이 있다.</p>
<p class="notice--primary"><strong>제자리 정렬:</strong> 원소들의 개수에 비해서 충분히 무시할 만한 저장 공간만을 더 사용하는 정렬 알고리즘들을 의미.<br />
예를 들어 <strong>삽입 정렬</strong>은 이미 주어진 원소들을 옮긴 뒤 적절한 위치에 원소를 삽입하는 연산을 반복하는데, 이 과정에서 원소들을 담는 공간 외에 추가로 사용될 수 있는 공간은 옮겨지는 <strong>원소가 저장되는 공간과 루프 변수</strong> 정도에 불과하다.</p>

<p><strong>다음은 삽입 정렬의 몇 가지 장점이다.</strong></p>

<ul>
  <li>다른 정렬 알고리즘에 비해 코드가 간단하고 구현이 쉽다. - Simple to implement</li>
  <li>최악 기준 $O(n^2)$의 시간복잡도를 가지는 소팅 알고리즘(선택 정렬, 버블 소트)에 비해 비교적 효율적이다.</li>
  <li>작은 데이터 셋에서 매우 효율적이다. - Efficient in small data set</li>
  <li>적응적이다. 대체로 이미 정렬이 되어있는 데이터 셋에서 효율적이다. - Adaptive</li>
  <li>같은 키값을 가진 원소들의 상대적인 순서를 바꾸지 않는다. - Stable</li>
  <li>O(1)의 상수적인 추가 메모리 공간만이 필요하다. - In-place</li>
  <li>실시간으로 원소를 하나씩 입력받으면서 정렬할 수 있다. - Online</li>
</ul>

<h2 id="알고리즘">알고리즘</h2>

<p><strong>다음은 삽입 정렬의 알고리즘이다. (오름차순, 원소 개수 2개 이상 기준)</strong></p>

<ol>
  <li>먼저, 정렬될 리스트에서 두번째 원소를 선택한다.</li>
  <li>1번에서 선택한 원소를 기준으로 리스트의 앞의 원소들과 비교하여 기준에 따라 자기 자리를 찾아간다. - 1 pass</li>
  <li>이를 매번 3…n-1번째 원소까지 선택하여 2번을 반복한다.</li>
</ol>

<p>이처럼, n개의 원소를 가진 리스트는 삽입 정렬로 n-1번의 패스를 거쳐 정렬이 된다.</p>

<hr />

<p>삽입 정렬에서는 <strong>매 반복(1 pass or each repetition)마다</strong> 하나의 원소를 취해 부분 정렬된 정렬된 리스트에 그 원소가 속할 위치를 찾고 그 위치에 삽입을 한다. 이것을 n번째 원소까지 반복한다.</p>

<p>다음 그림은 매번의 반복마다 원소 $x$가 자리를 찾아 삽입되는 것을 보여준다.</p>

<p>아래 그림은 원소 $x$가 정렬이 수행되기 전이다.<br />
원소 $x$는 아직 정렬되지 않은 데이터 셋에 있다.</p>

<p><img src="/assets/images/Insertionsort-before.png" alt="alt" width="300px" height="100px" /></p>

<p>정렬이 수행되고 나서는 아래 그림처럼 된다.<br />
원소 $x$는 $&lt;=x$ 보다는 오른쪽 $&gt;x$ 보다는 왼쪽에 있어, 부분 정렬 결과에 속하게 된다.</p>

<p><img src="/assets/images/Insertionsort-after.png" alt="alt" width="300px" height="100px" /></p>

<hr />

<p>다음은 삽입 정렬의 <strong>애니메이션</strong>이다.</p>

<p><img src="/assets/images/Insertion-sort-example.gif" alt="alt" width="450px" height="300px" class="align-center" /></p>

<h2 id="예제">예제</h2>

<p>다음 예제를 보고 알고리즘을 이해해 보자.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>다음과 같은 리스트가 있다고 하자.  

List = [64 25 12 22 11] - index: 0...4

List = [정렬 완료 | 미정렬]

1 pass: 1번 인덱스 위치의 원소를 선택하여 
        앞의 원소들과 비교하여 적절한 위치에 삽입한다.

List = [25 64 | 12 22 64]

2 pass: 2번 인덱스 위치의 원소를 선택하여
        앞의 원소들과 비교하여 적절한 위치에 삽입한다.

List = [11 12 25 | 22 64]

3 pass: 3번 인덱스 위치의 원소를 선택하여
        앞의 원소들과 비교하여 적절한 위치에 삽입한다.

List = [11 12 22 | 25 64]

4 pass: List[3...4]를 순회하여 최소값인 25을 찾고  
이를 3번째 인덱스 위치의 25와 스왑한다.

List = [11 12 22 25 | 64]

n-1번의 pass로 리스트의 정렬이 완료되었다.
</code></pre></div></div>

<h2 id="구현">구현</h2>

<p>다음은 삽입 정렬의 의사 코드이다.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">i</span> <span class="err">←</span> <span class="mi">1</span>
<span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="n">j</span> <span class="err">←</span> <span class="n">i</span>
    <span class="k">while</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="n">and</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        <span class="n">swap</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="n">and</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">j</span> <span class="err">←</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">end</span> <span class="k">while</span>
    <span class="n">i</span> <span class="err">←</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
<span class="n">end</span> <span class="k">while</span>
</code></pre></div></div>
<hr />
<p>다음은 선택 정렬을 자바로 구현한 코드이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">selectionSort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">indexMin</span><span class="o">,</span> <span class="n">temp</span><span class="o">;</span>

    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">list</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="c1">// Lowest position</span>
        <span class="n">indexMin</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">list</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">list</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">list</span><span class="o">[</span><span class="n">indexMin</span><span class="o">])</span> <span class="o">{</span>
                <span class="n">indexMin</span> <span class="o">=</span> <span class="n">j</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">// Swap</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">list</span><span class="o">[</span><span class="n">indexMin</span><span class="o">];</span>
        <span class="n">list</span><span class="o">[</span><span class="n">indexMin</span><span class="o">]</span> <span class="o">=</span> <span class="n">list</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="n">list</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="시간복잡도--공간복잡도">시간복잡도 &amp; 공간복잡도</h2>

<p><strong>시간복잡도 분석</strong></p>

<p>$n$ $(n-1…1)$개의 원소를 매 패스마다 스캔하여 적절한 위치와 스왑한다.<br />
n개의 원소가 있다면 $n-1$의 패스를 가진다.</p>

<script type="math/tex; mode=display">(n - 1) + (n - 2) +...+ 1 = \sum_{i=1}^{n-1} i</script>

<p>등차수열에 의해,</p>

<script type="math/tex; mode=display">\sum _{i=1}^{n-1}i={\frac {(n-1)+1}{2}}(n-1)={\frac {1}{2}}n(n-1)={\frac {1}{2}}(n^{2}-n)</script>

<p>비교의 측면에서 볼 때, 복잡도는 $O(n^2)$이다.</p>

<p>교환은 매 패스마다 한 번씩 일어난다. 즉, $n-1$번 복잡도는 $O(n)$<br />
(마지막 원소는 이미 정렬되어 있다.)</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>**Selection sort**

Class	            정렬 알고리즘

Data structure	    배열

Worst-case          О(n^2) 비교
performance         О(n) 교환

Best-case           О(n^2) 비교
performance         О(n) 교환

Average             О(n^2) 비교
performance         О(n) 교환

Worst-case          O(1) 추가 공간
space complexity	
</code></pre></div></div>

<h2 id="references">References</h2>

<p><a href="https://en.wikipedia.org/wiki/Selection_sort">Selection sort</a><br />
<a href="https://medium.com/@notestomyself">Selection sort - GIF</a></p>
:ET