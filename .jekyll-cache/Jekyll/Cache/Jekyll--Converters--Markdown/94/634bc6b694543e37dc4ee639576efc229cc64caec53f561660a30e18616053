I".<h1 id="탐색공간의-배제">탐색공간의 배제</h1>

<p>전체탐색법은 대부분의 경우 해를 구할 수 있는 알고리즘이다. 하지만 실행시간이 너무 길어 제한 시간 내에 문제를 해결할 수 없는 경우가 많다. 탐색공간의 배제는 전체탐색 알고리즘을 구현하는 데 있어서 더 이상 탐색하지 않더라도 해를 구하는 데 문제가 없는 부분을 판단하여 이 부분에 대해서 탐색을 하지 않으므로 탐색의 효율을 높이 고자 하는 방법이다.</p>

<p>탐색공간의 배제는 전체탐색에서 불필요한 탐색공간을 탐색하지 않음으로써 알고리즘의 효율을 향상시킨다. 이와 같이 탐색공간을 배제하는 방법은 다양하며 가장 기본 전략은 전체탐색설계와 같이 탐색으로 시작하여 모든 공간을 탐색하는 것이 아니라 일정한 조건을 두어 탐색영역을 배제하는 것이다.</p>

<p>배제되는 탐색공간의 크기에 따라 알고리즘의 성능의 향상 폭이 달라진다. 하지만 잘못 설계를 하여, 해가 있는 상태를 배제하면 해를 구할 수 없는 경우가 발생한다. 따라서 탐색 영역을 배제할 때는 엄밀한 수학적 접근이 필요하다.
이 설계방법은 탐색영역을 배제하는 방법에 따라서 수학적 배제, 경험적 배제, 구조적 배제로 나눌 수 있다.</p>

<p>각 방법에 대해서 자세히 알아보자.</p>

<h2 id="수학적-배제를-이용한-설계">수학적 배제를 이용한 설계</h2>

<p>탐색 공간 중 배제할 영역을 수학적 증명으로 결정하는 방법으로는 이분탐색 알고리즘 이 있다. 이는 일종의 수학적 배제를 이용하여 탐색공간을 줄여나가는 알고리즘 설계방법 이라고 할 수 있다.</p>

<p>오름차순으로 정렬된 상태의 이분탐색에서 현재 탐색한 값이 목표하는 값보다 작다면, 현재 탐색 위치의 왼쪽 영역에는 해가 존재할 가능성이 없다. 이는 수학적으로 쉽게 증명 할 수 있다.</p>

<p>따라서 왼쪽 영역에 대해서는 탐색할 필요가 없음을 알 수 있다. 그러므로 다음 탐색영역은 이를 배제하고 오른쪽 영역만 탐색하는 방법이다. 이와 같이 수학적으로 탐색할 필요가 없음이 증명된 공간들을 배제해 나가며 탐색하는 것과 같은 접근법이 수학적 배제를 이 용한 방법이라고 할 수 있다.</p>

<p>수학적 배제로 알고리즘을 설계할 경우, 공간을 배제할 원리를 수학적으로 증명한 후, 이 방법을 반복적으로 해를 찾을 때까지 적용해 나가며 해를 찾는다. 탐색공간에서 선택 배제된 부분은 수학적으로 탐색할 필요가 없으므로, 일반적으로 탐색법이긴 하지만 백트랙 없이 선형으로 진행되는 경우가 많다.</p>

<p>수학적으로 공간을 배제해 나가는 이 방법은 일종의 탐욕법(greedy)이라고 할 수 있으며, 엄밀하게 수학적으로 증명을 하기 때문에 수학적 탐욕법(mathematical greedy)라고 할 수 있다.</p>

<p>하지만 수학적 증명 없이, 직관적으로 현재 상태만으로 잘못된 판단을 하게 되면 올바른 해를 구할 수 없는 가능성을 가지는 단순 탐욕법이 될 수 있으므로 주의해야 한다. 하지만 단순 탐욕법의 경우에도 다양한 응용법이 있으므로 다음에 다루도록 한다.</p>

<p>다음 예는 루트 정점에서 출발하여 각 정점의 값을 누적하며 마지막 정점까지의 합을 최대화하는 최적화문제이다. 이 문제의 목적은 값을 최대화 하는 것이므로 다음 [영역배제의 규칙]을 적용하여 탐색 영역을 배제해 나가보자.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[영역배제의 규칙]
현재 상태에서 다음으로 탐색할 수 있는 정점들 중 더 높은 점수가 있는 정점으로 탐색한다.
(즉, 더 작은 점수가 있는 정점의 영역을 배제한다.)
</code></pre></div></div>

<p>이 규칙은 수학적으로 설득력이 있어 보인다. 왜냐하면 값을 최대화하기 위해서는 작은 값보다는 큰 값이 이득이 되기 때문이다. 하지만 엄밀한 수학적 증명은 하지 않았다. 이 방법으로 탐색을 진행하는 과정은 다음과 같다.</p>

<p>처음 출발점이 루트이므로 루트에 적힌 3점을 획득하여 현재 점수는 3점이다.<br />
다음으로 이동할 수 있는 정점들은 왼쪽 아래로 연결된 8점이 기록된 정점과 오른쪽 아래로 연결된 2점이 기록된 정점의 2가지이다. 이 상태에서 [영역배제의 규칙]을 적용하여 값이 더 큰 8점이 기록된 정점을 선택하고 2점이 기록된 정점을 배제하고 진행한다.</p>

<p>이 규칙을 적용하여 마지막까지 탐색한 결과는 위 그림에서 구한 해는 3-8-4-5를 선택하게 되며 이 때 얻은 점수는 3+8+4+5 이 된다. 과연 20점 이상을 획득할 수 있는 경로는 존재하지 않을까? 다음 그림을 보자.</p>

<p>위 결과를 보면 알 수 있듯이 3+2+9+8=22의 경로가 존재하며 앞 에서 영역을 배제했던 규칙이 잘못됐음을 알 수 있다.
수학적 배제는 엄밀한 수학적 접근 없이, 단순히 직관적으로 배제의 규칙을 결정하면 최적해를 구할 수 있음을 보장할 수 없다. 하지만 구현이 간단하며, 일반적으로 최적해와의 차이가 크지 않은 해를 구할 수 있다는 장점을 이용하여 다른 설계법에 응용할 수 있으므로 나중에 다시 살펴보기로 하자.</p>

<p>주어진 문제들을 통하여 수학적 배제 방법으로 알고리즘을 설계해보자.</p>

<h3 id="약수의-합">약수의 합</h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>한 정수 n을 입력받아서 n의 모든 약수의 합을 구하는 프로그램을 작성하시오.  

예를 들어 10의 약수는 1, 2, 5, 10이므로 이 값들의 합인 18이 10의 약수의 합이 된다.  

입력  
첫 번째 줄에 정수 n이 입력된다. (단, 1 &lt;= n &lt;= 10,000,000,000(100억))  

출력  
n의 약수의 합을 출력한다.
-------------------
입력 예
10

출력 예
18
</code></pre></div></div>

<p>이 문제는 <a href="http://localhost:4000/algorithm/전체탐색법/">전체탐색법</a>에서 다루었던 약수의 합 문제와 동일한 문제이다. 차이점은 앞의 문제가 입력값의 정의역이 100,000이었던 것에 반해,이 문제에서는 입력값이 100억으로 커졌다는 것이다.</p>

<p>앞의 문제에서 작성했던 풀이는 다음과 같다.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
</span><span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">solve</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">ans</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span>
        <span class="k">if</span><span class="p">(</span><span class="n">n</span><span class="o">%</span><span class="n">i</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">ans</span><span class="o">+=</span><span class="n">i</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">solve</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이 소스코드는 1부터 n까지의 모든 원소들을 탐색하여, 탐색 대상인 수 i가 n의 약수 라면 취하는 방식으로 진행된다.<br />
따라서 계산량은 O(n)이다.</p>

<p>이번 문제는 n의 최댓값이 100억이므로 이 방법으로는 너무 많은 시간이 걸린다. 따라서 탐색영역을 배제해야 할 필요가 있다.</p>

<p>먼저 간단한 수학적인 원리들을 생각해보자. 먼저 다음 정리를 이용하자.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>모든 자연수 n에 대하여 1과 n은 항상 n의 약수이다.
</code></pre></div></div>
<p>이 원리를 이용하면 위 소스코드의 8행의 탐색범위를 줄여서 다음과 같이 표현할 수 있다.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> 
  <span class="k">if</span><span class="p">(</span><span class="n">n</span><span class="o">%</span><span class="n">i</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">ans</span><span class="o">+=</span><span class="n">i</span><span class="p">;</span>
</code></pre></div></div>

<p>원래 소스코드보다 탐색공간이 줄어들긴 했으나 효율을 높이기에는 너무 미미하기 때문에 효율향상을 느낄 수 없다. 하지만 위 아이디어를 조금 응용하면 탐색공간을 많이 줄일 수 있다.</p>

<p>위 아이디어를 응용하기 위해서 다음 원리를 적용할 수 있다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>모든 자연수 n에 대하여,
2이상 n미만의 자연수들중 가장 큰 n의 약수는 n/2를 넘지 않는다.
</code></pre></div></div>
<p>이 원리를 적용하면 다음과 같이 탐색영역을 줄일 수 있다.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> 
  <span class="k">if</span><span class="p">(</span><span class="n">n</span><span class="o">%</span><span class="n">i</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">ans</span><span class="o">+=</span><span class="n">i</span><span class="p">;</span>
</code></pre></div></div>

<p>이 알고리즘은 탐색영역이 처음의 소스코드의 반이하로 줄어든 것이다. 따라서 실행시간 은 2배 이상 빨라질 것을 예상할 수 있다.</p>
<h3 id="references">References</h3>

<ul>
  <li>문제해결을 위한 창의적 알고리즘</li>
</ul>
:ET