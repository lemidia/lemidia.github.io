I"<h1 id="bubble버블-정렬">Bubble(버블 정렬)</h1>

<p>비교 기반 정렬 알고리즘이다.</p>

<p>다른 O(nlongn)의 성능을 내는 정렬 알고리즘에 비해 성능이 좋지 않으므로 실무에서는 교육용 목적으로 사용 되어진다.</p>

<p class="notice--info">더 효율적인 정렬 알고리즘인 팀소트(Timsort)가 머지소트(Merge sort)는 인기있는 프로그래밍 언어(java, python)의 내장 정렬 라이브러리로 사용되고 있다.</p>
<hr />

<h2 id="algorithm">Algorithm</h2>

<p>밑의 애니메이션을 먼저 보시고 알고리즘을 읽으시면 이해가 빠를 수 있습니다.</p>

<ol>
  <li>처음 원소를 시작으로 n번째 원소까지 차례대로 옆 원소와 오른쪽으로 비교하며 스왑을 진행한다.</li>
  <li>n번째 원소와 비교가 끝이나면 n번째 원소는 정렬이 완료된 것이다.</li>
  <li>처음 원소부터 n-1번째 원소까지 1번과 같이 수행한다.</li>
  <li>n-1번째 원소와 비교가 끝이나면 n-1번째 원소는 정렬이 완료된 것이다.</li>
  <li>이를 반복하여 n-2..n-3..2번째 원소까지 정렬이 완료되면 정렬이 완료된 것이다.</li>
</ol>

<p><img src="/assets/images/bubblesort1.gif" alt="Alt text" width="400px&quot;, height=&quot;500px" /></p>

<h2 id="analysis">Analysis</h2>

<p>버블소트는 최악과 평균 시간복잡도가 $O(n^2)$인 정렬 알고리즘이다.</p>

<p>최악과 평균 시간복잡도가 $O(nlog_{2}n)$인 실용적인 정렬 알고리즘 보다 성능이 좋지않고<br />
시간복잡도가 $O(n^2)$인 삽입정렬도 버블소트보다는 빠르게 동작하기 때문에 버블소트는 다소 실용적인 정렬 알고리즘이 아니다.</p>

<p>다른 정렬들과 비교해(삽입정렬을 제외한) 버블소트의 최대 장점은 배열이 정렬되어 있는 것을 탐지해낼 수 있는 능력이다.</p>

<p>리스트가 정렬이 완료되어 있을 때의 버블정렬은 O(n)이다.</p>

<h2 id="step-by-step-example">Step-by-step example</h2>

<p>배열 “5 1 4 2 8” 있다고 하자.<br />
처음 원소부터 끝 원소까지 오름차순으로 버블소트를 이용하여 정렬하려고 한다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>첫번째 패스 

( 5 1 4 2 8 ) → ( 1 5 4 2 8 )  
첫번째 원소와 두번째 원소를 비교한다, 5 &gt; 1 이므로 스왑한다. 
( 1 5 4 2 8 ) → ( 1 4 5 2 8 )  
두번째 원소와 세번째 원소를 비교한다, 5 &gt; 4 이므로 스왑한다. 
( 1 4 5 2 8 ) → ( 1 4 2 5 8 )  
세번째 원소와 네번째 원소를 비교한다, 5 &gt; 2 이므로 스왑한다. 
( 1 4 2 5 8 ) → ( 1 4 2 5 8 )  
네번째 원소와 다섯번째 원소를 비교한다, 5 &lt; 8 이므로 그대로 둔다.

첫번째 패스가 끝났다.

두번째 패스

( 1 4 2 5 8 ) → ( 1 4 2 5 8 )  
첫번째 원소와 두번째 원소를 비교한다, 1 &lt; 4 이므로 그대로 둔다.
( 1 4 2 5 8 ) → ( 1 2 4 5 8 )  
두번째 원소와 세번째 원소를 비교한다, 4 &gt; 2 이므로 스왑한다. 
( 1 2 4 5 8 ) → ( 1 2 4 5 8 )  
세번째 원소와 네번째 원소를 비교한다, 4 &lt; 5 이므로 그대로 둔다.
( 1 2 4 5 8 ) → ( 1 2 4 5 8 )  
첫번째 원소와 두번째 원소를 비교한다, 5 &lt; 8 이므로 그대로 둔다.

두번째 패스가 끝났다.

이제, 배열은 이미 오름차순으로 정렬이 완료되었다.
그러나, 알고리즘은 정렬이 완료되었는지 아직 모른다. 
정렬이 완료되었는지 알기 위해선 하나의 패스를 더 거쳐야 한다. 
(불리언 변수 하나를 두어 이를 알 수 있는데, 밑의 구현에서 알아본다.)

세번째 패스

( 1 2 4 5 8 ) → ( 1 2 4 5 8 )  
( 1 2 4 5 8 ) → ( 1 2 4 5 8 )  
( 1 2 4 5 8 ) → ( 1 2 4 5 8 )  
( 1 2 4 5 8 ) → ( 1 2 4 5 8 )  

세번째 패스가 끝났다.

스왑된 원소가 없으므로 알고리즘은 더 이상 패스를 수행하지 않는다.

알고리즘을 종료한다.
</code></pre></div></div>

<h2 id="implementation">Implementation</h2>

<p>위의 알고리즘을 의사코드로 구현해보자.</p>

<p>버블소트 의사코드 구현(index: 0 base)</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">procedure</span> <span class="nf">bubbleSort</span><span class="o">(</span><span class="no">A</span> <span class="o">:</span> <span class="n">list</span> <span class="n">of</span> <span class="n">sortable</span> <span class="n">items</span><span class="o">)</span>
    <span class="n">n</span> <span class="o">:=</span> <span class="n">length</span><span class="o">(</span><span class="no">A</span><span class="o">)</span> <span class="c1">// 배열 길이, 원소 개수</span>
    <span class="n">repeat</span> <span class="c1">// 반복한다.</span>
        <span class="n">swapped</span> <span class="o">=</span> <span class="kc">false</span> <span class="c1">// 스왑이 되었는지 여부</span>
        <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="mi">1</span> <span class="n">to</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="n">inclusive</span> <span class="k">do</span> <span class="c1">// [1 ~ n-1]까지</span>
            <span class="cm">/* 만약 두 원소가 순서에 어긋나면 */</span>
            <span class="k">if</span> <span class="no">A</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">&gt;</span> <span class="no">A</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="n">then</span>
                <span class="cm">/* 스왑하고, 스왑되었다는 것을 체크한다. */</span>
                <span class="n">swap</span><span class="o">(</span><span class="no">A</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">],</span> <span class="no">A</span><span class="o">[</span><span class="n">i</span><span class="o">])</span>
                <span class="n">swapped</span> <span class="o">:=</span> <span class="kc">true</span> 
            <span class="n">end</span> <span class="k">if</span>
        <span class="n">end</span> <span class="k">for</span>
    <span class="c1">// 스왑이 안되었을때 까지, 즉, swapped가 true면 repeat로 간다.</span>
    <span class="n">until</span> <span class="n">not</span> <span class="n">swapped</span>
<span class="n">end</span> <span class="n">procedure</span>
</code></pre></div></div>

<p>버블소트 최적화</p>

<p>n번째 패스가 끝이나면 n번째로 큰 원소는 이미 정렬이 완료되어 그자리에 위치가 변하지 않기에, 내부 루프는 매 패스마다, 0번째 원소부터 n번째 까지 원소를 비교할 필요가 없다.</p>

<p>한번의 패스가 끝이나면 n을 n-1로, 즉 1씩 줄여 쓸때없는 연산을 피할 수 있다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>procedure bubbleSort(A : list of sortable items)
    n := length(A)
    repeat
        swapped := false
        for i := 1 to n - 1 inclusive do
            if A[i - 1] &gt; A[i] then
                swap(A[i - 1], A[i])
                swapped = true
            end if
        end for
        n := n - 1
    until not swapped
end procedure
</code></pre></div></div>

<h2 id="시간복잡도">시간복잡도</h2>
<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>최악 시간복잡도	$O(n^2)$
최선 시간복잡도	$O(n)$
평균 시간복잡도	$O(n^2)$
</code></pre></div></div>

<h2 id="references">References</h2>

<p>[Bubble Sort - wikipedia]</p>
:ET