I"¿<h1 id="spfa">SPFA</h1>

<p>The Shortest Path Faster Algorithm (SPFA)ëŠ” Bellmanâ€“Ford algorithmë¥¼ ê°œì„ í•œ ì•Œê³ ë¦¬ì¦˜ ìœ¼ë¡œì„œ, ë°©í–¥ ê°€ì¤‘ì¹˜ ê·¸ë˜í”„ì—ì„œ ë‹¨ì¼ ì¶œë°œ ì •ì  ìµœë‹¨ê±°ë¦¬ë¥¼ ê³„ì‚°í•œë‹¤. ì´ SPFAëŠ” ë¬´ì‘ìœ„ í¬ì†Œ ê·¸ë˜í”„ì—ì„œ ì˜ ë™ì‘í•œë‹¤ê³  ì•Œë ¤ì ¸ ìˆê³ , ìŒìˆ˜ ê°€ì¤‘ì¹˜ ê°„ì„ ì„ ê°€ì§„ ê·¸ë˜í”„ì—ì„œë„ ì í•©í•˜ë‹¤. ê·¸ëŸ¬ë‚˜ ìµœì•… ì‹œê°„ë³µì¡ë„ëŠ” Bellmanâ€“Ford algorithmê³¼ ê°™ê¸° ë•Œë¬¸ì—, ìŒìˆ˜ ê°€ì¤‘ì¹˜ ê°„ì„ ì´ ì—†ëŠ” Dijkstraâ€™s algorithmì´ ë” ì í•©í•˜ë‹¤ê³  ë³¼ ìˆ˜ ìˆë‹¤.</p>

<p>[1] However, the worst-case complexity of SPFA is the same as that of Bellmanâ€“Ford, so for graphs with nonnegative edge weights Dijkstraâ€™s algorithm is preferred. The SPFA algorithm was first published by Edward F. Moore in 1959, as a generalization of breadth first search;[2] the same algorithm was rediscovered in 1994 by Fanding Duan.[3]</p>

<h2 id="algorithm">Algorithm</h2>

<p>Given a weighted directed graph {\displaystyle G=(V,E)}{\displaystyle G=(V,E)} and a source vertex {\displaystyle s}s, the SPFA algorithm finds the shortest path from {\displaystyle s}s, to each vertex {\displaystyle v}v, in the graph. The length of the shortest path from {\displaystyle s}s, to {\displaystyle v}v is stored in {\displaystyle d(v)}{\displaystyle d(v)} for each vertex {\displaystyle v}v.</p>

<p>The basic idea of SPFA is the same as Bellmanâ€“Ford algorithm in that each vertex is used as a candidate to relax its adjacent vertices. The improvement over the latter is that instead of trying all vertices blindly, SPFA maintains a queue of candidate vertices and adds a vertex to the queue only if that vertex is relaxed. This process repeats until no more vertex can be relaxed.</p>

<p>Below is the pseudo-code of the algorithm.[4] Here {\displaystyle Q}Q is a first-in, first-out queue of candidate vertices, and {\displaystyle w(u,v)}{\displaystyle w(u,v)} is the edge weight of {\displaystyle (u,v)}(u,v).</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="mi">0</span> <span class="n">procedure</span> <span class="n">Shortest</span><span class="o">-</span><span class="n">Path</span><span class="o">-</span><span class="n">Faster</span><span class="o">-</span><span class="n">Algorithm</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
 <span class="mi">1</span>    <span class="k">for</span> <span class="n">each</span> <span class="n">vertex</span> <span class="n">v</span> <span class="err">â‰ </span> <span class="n">s</span> <span class="n">in</span> <span class="n">V</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
 <span class="mi">2</span>        <span class="n">d</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">:=</span> <span class="err">âˆ</span>
 <span class="mi">3</span>    <span class="n">d</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">:=</span> <span class="mi">0</span>
 <span class="mi">4</span>    <span class="n">offer</span> <span class="n">s</span> <span class="n">into</span> <span class="n">Q</span>
 <span class="mi">5</span>    <span class="k">while</span> <span class="n">Q</span> <span class="n">is</span> <span class="n">not</span> <span class="n">empty</span>
 <span class="mi">6</span>        <span class="n">u</span> <span class="o">:=</span> <span class="n">poll</span> <span class="n">Q</span>
 <span class="mi">7</span>        <span class="k">for</span> <span class="n">each</span> <span class="n">edge</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="n">in</span> <span class="n">E</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
 <span class="mi">8</span>            <span class="k">if</span> <span class="n">d</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">+</span> <span class="n">w</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">d</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="n">then</span>
 <span class="mi">9</span>                <span class="n">d</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">:=</span> <span class="n">d</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">+</span> <span class="n">w</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
<span class="mi">10</span>                <span class="k">if</span> <span class="n">v</span> <span class="n">is</span> <span class="n">not</span> <span class="n">in</span> <span class="n">Q</span> <span class="n">then</span>
<span class="mi">11</span>                    <span class="n">offer</span> <span class="n">v</span> <span class="n">into</span> <span class="n">Q</span>
</code></pre></div></div>

<p>The basic idea of SPFA is the same as Bellmanâ€“Ford algorithm in that each vertex is used as a candidate to relax its adjacent vertices. The improvement over the latter is that instead of trying all vertices blindly, SPFA maintains a queue of candidate vertices and adds a vertex to the queue only if that vertex is relaxed. This process repeats until no more vertex can be relaxed.</p>

<p><img src="/assets/images/SPFA-0.png" alt="Alt text" width="400px" height="300px" class="align-center" /></p>

<p>The performance of the algorithm is strongly determined by the order in which candidate vertices are used to relax other vertices. In fact, if {\displaystyle Q}Q is a priority queue, then the algorith</p>

<p><img src="/assets/images/SPFA-1.png" alt="Alt text" width="400px" height="300px" class="align-center" /></p>

<p>(and does not have to be in the queue anymore). However, the relaxation by {\displaystyle x}x might cause some other vertices to become capable of causing rel</p>

<p><img src="/assets/images/SPFA-2.png" alt="Alt text" width="400px" height="300px" class="align-center" /></p>

<p>axation. If there exists some {\displaystyle dist[x]&gt;dist[w]+wt(w,x)}{\displaystyle dist[x]&gt;dist[w]+wt(w,x)} such that before the current loop iteration, then {\displaystyle w}w is already in the queue. If this condition</p>

<p><img src="/assets/images/SPFA-3.png" alt="Alt text" width="400px" height="300px" class="align-center" /></p>

<p><img src="/assets/images/SPFA-4.png" alt="Alt text" width="400px" height="300px" class="align-center" /></p>

<p><img src="/assets/images/SPFA-5.png" alt="Alt text" width="400px" height="300px" class="align-center" /></p>

<p><img src="/assets/images/SPFA-6.png" alt="Alt text" width="400px" height="300px" class="align-center" /></p>

<p><img src="/assets/images/SPFA-7.png" alt="Alt text" width="400px" height="300px" class="align-center" /></p>

<p><img src="/assets/images/SPFA-8.png" alt="Alt text" width="400px" height="300px" class="align-center" /></p>

<p><img src="/assets/images/SPFA-9.png" alt="Alt text" width="400px" height="300px" class="align-center" /></p>

<p><img src="/assets/images/SPFA-10.png" alt="Alt text" width="400px" height="300px" class="align-center" /></p>

<p><img src="/assets/images/SPFA-11.png" alt="Alt text" width="400px" height="300px" class="align-center" /></p>

:ET