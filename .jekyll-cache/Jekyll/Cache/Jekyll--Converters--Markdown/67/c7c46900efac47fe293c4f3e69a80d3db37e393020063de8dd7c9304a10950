I"<h1 id="bubble버블-정렬">Bubble(버블 정렬)</h1>

<p>비교 기반 정렬 알고리즘이다.</p>

<p>다른 O(nlongn)의 성능을 내는 정렬 알고리즘에 비해 성능이 좋지 않으므로 실무에서는 교육용 목적으로 사용 되어진다.</p>

<p class="notice--info">더 효율적인 정렬 알고리즘인 팀소트(Timsort)가 머지소트(Merge sort)는 인기있는 프로그래밍 언어(java, python)의 내장 정렬 라이브러리로 사용되고 있다.</p>
<hr />

<h2 id="algorithm">Algorithm</h2>

<p>밑의 애니메이션을 먼저 보시고 알고리즘을 읽으시면 이해가 빠를 수 있습니다.</p>

<ol>
  <li>처음 원소를 시작으로 n번째 원소까지 차례대로 옆 원소와 오른쪽으로 비교하며 스왑을 진행한다.</li>
  <li>n번째 원소와 비교가 끝이나면 n번째 원소는 정렬이 완료된 것이다.</li>
  <li>처음 원소부터 n-1번째 원소까지 1번과 같이 수행한다.</li>
  <li>n-1번째 원소와 비교가 끝이나면 n-1번째 원소는 정렬이 완료된 것이다.</li>
  <li>이를 반복하여 n-2..n-3..2번째 원소까지 정렬이 완료되면 정렬이 완료된 것이다.</li>
</ol>

<p><img src="/assets/images/bubblesort1.gif" alt="Alt text" width="400px&quot;, height=&quot;500px" /></p>

<h2 id="analysis">Analysis</h2>

<p>버블소트는 최악과 평균 시간복잡도가 $O(n^2)$인 정렬 알고리즘이다.</p>

<p>최악과 평균 시간복잡도가 $O(nlog_{2}n)$인 실용적인 정렬 알고리즘 보다 성능이 좋지않고<br />
시간복잡도가 $O(n^2)$인 삽입정렬도 버블소트보다는 빠르게 동작하기 때문에 버블소트는 다소 실용적인 정렬 알고리즘이 아니다.</p>

<p>다른 정렬들과 비교해(삽입정렬을 제외한) 버블소트의 최대 장점은 배열이 정렬되어 있는 것을 탐지해낼 수 있는 능력이다.</p>

<p>리스트가 정렬이 완료되어 있을 때의 버블정렬은 O(n)이다.</p>

<h2 id="step-by-step-example">Step-by-step example</h2>

<p>배열 “5 1 4 2 8” 있다고 하자.<br />
처음 원소부터 끝 원소까지 오름차순으로 버블소트를 이용하여 정렬하려고 한다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>첫번째 패스 

( 5 1 4 2 8 ) → ( 1 5 4 2 8 )  
첫번째 원소와 두번째 원소를 비교한다, 5 &gt; 1 이므로 스왑한다. 
( 1 5 4 2 8 ) → ( 1 4 5 2 8 )  
두번째 원소와 세번째 원소를 비교한다, 5 &gt; 4 이므로 스왑한다. 
( 1 4 5 2 8 ) → ( 1 4 2 5 8 )  
세번째 원소와 네번째 원소를 비교한다, 5 &gt; 2 이므로 스왑한다. 
( 1 4 2 5 8 ) → ( 1 4 2 5 8 )  
네번째 원소와 다섯번째 원소를 비교한다, 5 &lt; 8 이므로 그대로 둔다.

첫번째 패스가 끝났다.


두번째 패스

( 1 4 2 5 8 ) → ( 1 4 2 5 8 )  
첫번째 원소와 두번째 원소를 비교한다, 1 &lt; 4 이므로 그대로 둔다.
( 1 4 2 5 8 ) → ( 1 2 4 5 8 )  
두번째 원소와 세번째 원소를 비교한다, 4 &gt; 2 이므로 스왑한다. 
( 1 2 4 5 8 ) → ( 1 2 4 5 8 )  
세번째 원소와 네번째 원소를 비교한다, 4 &lt; 5 이므로 그대로 둔다.
( 1 2 4 5 8 ) → ( 1 2 4 5 8 )  
첫번째 원소와 두번째 원소를 비교한다, 5 &lt; 8 이므로 그대로 둔다.

두번째 패스가 끝났다.

이제, 배열은 이미 오름차순으로 정렬이 완료되었다.
그러나, 알고리즘은 정렬이 완료되었는지 아직 모른다. 
정렬이 완료되었는지 알기 위해선 하나의 패스를 더 거쳐야 한다. 

세번째 패스

( 1 2 4 5 8 ) → ( 1 2 4 5 8 )  
( 1 2 4 5 8 ) → ( 1 2 4 5 8 )  
( 1 2 4 5 8 ) → ( 1 2 4 5 8 )  
( 1 2 4 5 8 ) → ( 1 2 4 5 8 )  

세번째 패스가 끝났다.

알고리즘을 종료한다.
</code></pre></div></div>

<h2 id="implementation">Implementation</h2>

<p>위의 알고리즘을 의사코드로 구현해보자.</p>

<p>버블소트 의사코드 구현(index: 0 base)</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>procedure bubbleSort(A : list of sortable items)
    n := length(A) // 배열 길이, 원소 개수
    repeat // 반복한다.
        swapped = false // 스왑이 되었는지 여부
        for i := 1 to n - 1 inclusive do // [1 ~ n-1]까지
            /* 만약 두 원소가 순서에 어긋나면 */
            if A[i - 1] &gt; A[i] then
                /* 스왑하고, 스왑되었다는 것을 체크한다. */
                swap(A[i - 1], A[i])
                swapped := true 
            end if
        end for
    until not swapped // 스왑이 안되었을때 까지
end procedure
</code></pre></div></div>

<p>Optimizing bubble sort</p>

<p>The bubble sort algorithm can be easily optimized by observing that the n-th pass finds the n-th largest element and puts it into its final place. So, the inner loop can avoid looking at the last n − 1 items when running for the n-th time:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>procedure bubbleSort(A : list of sortable items)
    n := length(A)
    repeat
        swapped := false
        for i := 1 to n - 1 inclusive do
            if A[i - 1] &gt; A[i] then
                swap(A[i - 1], A[i])
                swapped = true
            end if
        end for
        n := n - 1
    until not swapped
end procedure
</code></pre></div></div>

<h2 id="시간복잡도">시간복잡도</h2>
<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>최악 시간복잡도	$O(n^2)$
최선 시간복잡도	$O(n)$
평균 시간복잡도	$O(n^2)$
</code></pre></div></div>

<h2 id="references">References</h2>

<p>[Bubble Sort - wikipedia]</p>
:ET