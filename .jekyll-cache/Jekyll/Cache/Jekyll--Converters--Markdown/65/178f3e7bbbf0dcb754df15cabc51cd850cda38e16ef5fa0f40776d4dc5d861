I"I<h1 id="위상정렬topological-sorting">위상정렬(Topological sorting)</h1>

<p>컴퓨터 과학에서 <strong>위상정렬(Topological sorting)</strong>은 방향 그래프에서 정점들의 <strong>선형적인 순서</strong>를 말하는데, 여기서 정점들의 선형적 순서란 정점 u로 부터 정점 v로 가는 간선에 대해 순서상 정점 u가 정점 v보다 앞에 있다는 것을 뜻한다. 예를 들어, 방향 그래프에서 정점들은 수행될 작업들을 뜻할 수 있고, 간선은 어떤 작업이 다른 작업보다 먼저 수행되어야 한다는 제약을 나타낼 수 있다. 즉, 위상정렬의 결과는 작업들이 수행되는 일련의 순서를 의미한다. <strong>위상정렬은 사이클이 형성되지 않은 그래프</strong>에서 가능하다. 즉, 사이클이 없는 방향 그래프에서 적용이 가능한데, 이런 그래프를 DAG(Directed acyclic graph)라고 한다. 어떤 DAG에 대해서도 위상정렬을 적용하면 적어도 하나의 위상순서를 가지게 되고 경우에 따라 여러개의 위상순서를 가지리 수 있다. 위상정렬 알고리즘은 DAG에서 위상순서를 구하는데 선형시간이 걸린다고 알려져 있다.</p>

<h2 id="example">Example</h2>

<p>위상정렬은 현실적인 예로는 제약에 따른 작업들의 스케줄링 순서라고 이해하면 된다. 작업들은 정점으로 나타내어지고 정점에서 다른 정점으로의 간선이 있는데, 이는, x, y 두 정점을 끝 점으로 하고 x-&gt;y로의 방향 간선 E(x,y)이 있을 때 작업 y가 수행되기 위해서는 x가 사전에 먼저 수행 완료되어야 한다는 것을 뜻한다. 작업 y의 제약은 x인 것이다. 이처럼 제약이 있는 해당 작업들에 대해서 위상정렬은 작업들의 수행순서를 나타낸다.</p>

<p>밑 그림에서 5번 정점과 11번 정점을 보자. 정점은 작업으로 생각하고 간선은 제약 또는 작업 흐름으로 보면 위상정렬에서는 5번 작업이 완료되고 11번 작업이 수행된다는 것이다. 즉, 11번 작업이 수행되기 위해선 5번 작업이 사전에 완료가 되어야 한다는 것을 말한다. 다른 작업들도 마찬가지로, 9번 정점이 수행되기 위해서는 11번과 8번 작업이 사전에 완료가 되어야 한다.</p>

<p><img src="/assets/images/topological-sort0.png" alt="alt" width="300px" height="200px" class="align-center" /></p>

<p class="notice--warning"><strong>위상순서:</strong> DAG의 모든 간선 <code class="highlighter-rouge">u-&gt;v</code>에 대해서, 정점 u는 v보다 순서상에서 먼저 나와야 한다.</p>

<p>다음은 위 그림에서의 위상정렬 순서인데 기준에 따라 여러가지가 있을 수 있다.</p>

<ul>
  <li><code class="highlighter-rouge">5-&gt;7-&gt;3-&gt;11-&gt;8-&gt;2-&gt;9-&gt;10</code> (왼쪽에서 오른쪽, 밑에서 아래로)</li>
  <li><code class="highlighter-rouge">3-&gt;5-&gt;7-&gt;8-&gt;11-&gt;2-&gt;9-&gt;10</code> (현재 작업 가능한 작업들의 번호가 작은순서)</li>
  <li><code class="highlighter-rouge">3-&gt;7-&gt;8-&gt;5-&gt;11-&gt;10-&gt;2-&gt;9</code> (현재 작업 가능한 작업들의 무작위 선택)</li>
</ul>

<h2 id="알고리즘">알고리즘</h2>

<p>DAG에서의 위상정렬을 구하는 두 가지 알고리즘을 살펴보자.</p>

<h3 id="kahns-algorithm">Kahn’s algorithm</h3>

<p>위상정렬을 구하는 이 알고리즘은 Kahn (1962)에 의해 처음 소개 되었다.</p>

<p>Kahn’s algorithm은 해당 그래프에서의 진입간선(Incoming edge)을 가지고 있지 않은 정점들로 부터 시작해서 그 정점들의 진출간선(Outgoing edge)을 삭제 또는 그 정점과 연결된 정점의 진입간선((Incoming edge)을 삭제 하면서 동작한다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>S ← Set of all nodes with no incoming edge
L ← Empty list that will contain the sorted elements

while S is non-empty do
    remove a node n from S
    add n to tail of L
    for each node m with an edge e from n to m do
        remove edge e from the graph
        if m has no other incoming edges then
            insert m into S

if graph has edges then
    return error   (graph has at least one cycle)
else 
    return L   (a topologically sorted order)
</code></pre></div></div>

<ol>
  <li>진입간선이 없는 없는 정점들을 시작 리스트 S에 넣는다.</li>
  <li>S가 빈 공간이 아닐 때 까지 다음을 반복한다.</li>
  <li>S의 앞에서 부터 정점 n을 하나 취해서 위상정렬 리스트 L의 끝에 추가한다.</li>
  <li>정점 n과 m을 양 끝점으로 하는 간선 e와 정점 m에 대해서
    <ol>
      <li>간선 e를 삭제한다. (정점 m의 진입간선 삭제와 같은 의미이다.)</li>
      <li>정점 m의 진입간선의 개수가 0개라면, S에 m을 추가한다.</li>
    </ol>
  </li>
  <li>그래프에 간선이 남아있으면 적어도 하나의 사이클이 있다는 의미이므로 error를 리턴한다. 그렇지 않으면 위상정렬 순서를 리턴한다.</li>
</ol>

<p>위상정렬을 적용한 그래프가 DAG이라면 이 알고리즘은 위상정렬 순서 L을 리턴할 것이고, 그래프에 사이클이 하나라도 있다면 위상정렬은 불가능 하므로</p>

<hr />

<p>삽입 정렬에서는 <strong>매 반복(1 pass or each repetition)마다</strong> 하나의 원소를 취해 부분 정렬된 정렬된 리스트에 그 원소가 속할 위치를 찾고 그 위치에 삽입을 한다. 이것을 n번째 원소까지 반복한다.</p>

<p>다음 그림은 매번의 반복마다 원소 $x$가 자리를 찾아 삽입되는 것을 보여준다.</p>

<p>아래 그림은 원소 $x$가 정렬이 수행되기 전이다.<br />
원소 $x$는 아직 정렬되지 않은 데이터 셋에 있다.</p>

<p><img src="/assets/images/Insertionsort-before.png" alt="alt" width="300px" height="100px" /></p>

<p>정렬이 수행되고 나서는 아래 그림처럼 된다.<br />
원소 $x$는 $&lt;=x$ 보다는 오른쪽 $&gt;x$ 보다는 왼쪽에 있어, 부분 정렬 결과에 속하게 된다.</p>

<p><img src="/assets/images/Insertionsort-after.png" alt="alt" width="300px" height="100px" /></p>

<hr />

<p>다음은 삽입 정렬의 <strong>애니메이션</strong>이다.</p>

<p><img src="/assets/images/Insertion-sort-example.gif" alt="alt" width="450px" height="300px" class="align-center" /></p>

<h2 id="예제">예제</h2>

<p>다음 예제를 보고 알고리즘을 이해해 보자.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>다음과 같은 리스트가 있다고 하자.  

List = [64 25 12 22 11] - index: 0...4

List = [정렬 완료 | 미정렬]

1 pass: 1번 인덱스 위치의 원소를 선택하여 
        앞의 원소들과 비교하여 적절한 위치에 삽입한다.

List = [25 64 | 12 22 11]

2 pass: 2번 인덱스 위치의 원소를 선택하여
        앞의 원소들과 비교하여 적절한 위치에 삽입한다.

List = [12 25 64 | 22 11]

3 pass: 3번 인덱스 위치의 원소를 선택하여
        앞의 원소들과 비교하여 적절한 위치에 삽입한다.

List = [12 22 25 64 | 11]

4 pass: 4번 인덱스 위치의 원소를 선택하여 
        앞의 원소들과 비교하여 적절한 위치에 삽입한다.

List = [11 12 22 25 64 | ]

n-1번의 pass로 리스트의 정렬이 완료되었다.

List = [11 12 22 25 64]
</code></pre></div></div>

<h2 id="구현">구현</h2>

<p>다음은 삽입 정렬의 의사 코드이다.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">i</span> <span class="err">←</span> <span class="mi">1</span>
<span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="n">j</span> <span class="err">←</span> <span class="n">i</span>
    <span class="k">while</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="n">and</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        <span class="n">swap</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="n">and</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">j</span> <span class="err">←</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">end</span> <span class="k">while</span>
    <span class="n">i</span> <span class="err">←</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
<span class="n">end</span> <span class="k">while</span>
</code></pre></div></div>
<hr />
<p>다음은 선택 정렬을 C++로 구현한 코드이다.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include&lt;iostream&gt;  
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>  
<span class="kt">int</span> <span class="nf">main</span> <span class="p">()</span>  
<span class="p">{</span>  
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span><span class="n">temp</span><span class="p">;</span>  
    <span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">101</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">44</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">78</span><span class="p">,</span> <span class="mi">34</span><span class="p">,</span> <span class="mi">23</span><span class="p">};</span>   
    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"</span><span class="se">\n</span><span class="s">printing sorted elements...</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>  
    <span class="k">for</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">k</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span>   
    <span class="p">{</span>  
        <span class="n">temp</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>  
        <span class="n">j</span><span class="o">=</span> <span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>  
        <span class="k">while</span><span class="p">(</span><span class="n">j</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">temp</span> <span class="o">&lt;=</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>  
        <span class="p">{</span>  
            <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>   
            <span class="n">j</span> <span class="o">=</span> <span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>  
        <span class="p">}</span>  
        <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>  
    <span class="p">}</span>  
    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>  
    <span class="p">{</span>  
        <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>  
    <span class="p">}</span>  
<span class="p">}</span>  

<span class="cm">/*
Output:
Printing sorted elements . . . 
7
9
10
12
23
23
34
44
78 
101 
*/</span>
</code></pre></div></div>

<p>다음은 선택 정렬을 java로 구현한 코드이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">InsertionSort</span> <span class="o">{</span>  
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>  
        <span class="kt">int</span><span class="o">[]</span> <span class="n">a</span> <span class="o">=</span> <span class="o">{</span><span class="mi">10</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">101</span><span class="o">,</span> <span class="mi">23</span><span class="o">,</span> <span class="mi">44</span><span class="o">,</span> <span class="mi">12</span><span class="o">,</span> <span class="mi">78</span><span class="o">,</span> <span class="mi">34</span><span class="o">,</span> <span class="mi">23</span><span class="o">};</span>  
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">k</span><span class="o">&lt;</span><span class="mi">10</span><span class="o">;</span> <span class="n">k</span><span class="o">++)</span>   
        <span class="o">{</span>  
            <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">k</span><span class="o">];</span>  
            <span class="kt">int</span> <span class="n">j</span><span class="o">=</span> <span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span>  
            <span class="k">while</span><span class="o">(</span><span class="n">j</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">temp</span> <span class="o">&lt;=</span> <span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">])</span>  
            <span class="o">{</span>  
                <span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>   
                <span class="n">j</span> <span class="o">=</span> <span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span>  
            <span class="o">}</span>  
            <span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>  
        <span class="o">}</span>  
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"printing sorted elements ..."</span><span class="o">);</span>  
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">10</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span>  
        <span class="o">{</span>  
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>  
        <span class="o">}</span>  
    <span class="o">}</span>
<span class="o">}</span> 

<span class="cm">/*
Output:
Printing sorted elements . . . 
7
9
10
12
23
23
34
44
78 
101 
*/</span>
</code></pre></div></div>

<h2 id="시간복잡도--공간복잡도">시간복잡도 &amp; 공간복잡도</h2>

<p><strong>시간복잡도 분석</strong></p>

<p>최악 기준 $1$…$n-1$개의 원소를 매 패스마다 비교한다. 
n개의 원소가 있다면 $n-1$의 패스를 가진다.</p>

<script type="math/tex; mode=display">1 + 2 +...+ (n-1) = {\frac {1}{2}}n(n-1)={\frac {1}{2}}(n^{2}-n)</script>

<p>비교의 측면에서 볼 때, 복잡도는 $O(n^2)$이다.</p>

<p>교환(Swap)도 위와 동일하다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>**Insertion sort**

Class	            정렬 알고리즘

Data structure	    배열

Worst-case          О(n^2) 비교
performance         О(n^2) 교환

Best-case           О(n^2) 비교
performance         О(n^2) 교환

Average             О(n^2) 비교
performance         О(n^2) 교환

Worst-case          O(n) 총 공간
space complexity    O(1) 추가 공간
</code></pre></div></div>

<h2 id="references">References</h2>

<p><a href="https://en.wikipedia.org/wiki/Insertion_sort">Insertion sort - wikipedia</a><br />
<a href="https://www.javatpoint.com/insertion-sort">Insertion sort - javatpoint</a></p>
:ET