I"©a<h1 id="ìœ„ìƒì •ë ¬topological-sorting">ìœ„ìƒì •ë ¬(Topological sorting)</h1>

<p>ì»´í“¨í„° ê³¼í•™ì—ì„œ <strong>ìœ„ìƒì •ë ¬(Topological sorting)</strong>ì€ ë°©í–¥ ê·¸ë˜í”„ì—ì„œ ì •ì ë“¤ì˜ <strong>ì„ í˜•ì ì¸ ìˆœì„œ</strong>ë¥¼ ë§í•˜ëŠ”ë°, ì—¬ê¸°ì„œ ì •ì ë“¤ì˜ ì„ í˜•ì  ìˆœì„œë€ ì •ì  uë¡œ ë¶€í„° ì •ì  vë¡œ ê°€ëŠ” ê°„ì„ ì— ëŒ€í•´ ìˆœì„œìƒ ì •ì  uê°€ ì •ì  vë³´ë‹¤ ì•ì— ìˆë‹¤ëŠ” ê²ƒì„ ëœ»í•œë‹¤. ì˜ˆë¥¼ ë“¤ì–´, ë°©í–¥ ê·¸ë˜í”„ì—ì„œ ì •ì ë“¤ì€ ìˆ˜í–‰ë  ì‘ì—…ë“¤ì„ ëœ»í•  ìˆ˜ ìˆê³ , ê°„ì„ ì€ ì–´ë–¤ ì‘ì—…ì´ ë‹¤ë¥¸ ì‘ì—…ë³´ë‹¤ ë¨¼ì € ìˆ˜í–‰ë˜ì–´ì•¼ í•œë‹¤ëŠ” ì œì•½ì„ ë‚˜íƒ€ë‚¼ ìˆ˜ ìˆë‹¤. ì¦‰, ìœ„ìƒì •ë ¬ì˜ ê²°ê³¼ëŠ” ì‘ì—…ë“¤ì´ ìˆ˜í–‰ë˜ëŠ” ì¼ë ¨ì˜ ìˆœì„œë¥¼ ì˜ë¯¸í•œë‹¤. <strong>ìœ„ìƒì •ë ¬ì€ ì‚¬ì´í´ì´ í˜•ì„±ë˜ì§€ ì•Šì€ ê·¸ë˜í”„</strong>ì—ì„œ ê°€ëŠ¥í•˜ë‹¤. ì¦‰, ì‚¬ì´í´ì´ ì—†ëŠ” ë°©í–¥ ê·¸ë˜í”„ì—ì„œ ì ìš©ì´ ê°€ëŠ¥í•œë°, ì´ëŸ° ê·¸ë˜í”„ë¥¼ DAG(Directed acyclic graph)ë¼ê³  í•œë‹¤. ì–´ë–¤ DAGì— ëŒ€í•´ì„œë„ ìœ„ìƒì •ë ¬ì„ ì ìš©í•˜ë©´ ì ì–´ë„ í•˜ë‚˜ì˜ ìœ„ìƒìˆœì„œë¥¼ ê°€ì§€ê²Œ ë˜ê³  ê²½ìš°ì— ë”°ë¼ ì—¬ëŸ¬ê°œì˜ ìœ„ìƒìˆœì„œë¥¼ ê°€ì§€ë¦¬ ìˆ˜ ìˆë‹¤. ìœ„ìƒì •ë ¬ ì•Œê³ ë¦¬ì¦˜ì€ DAGì—ì„œ ìœ„ìƒìˆœì„œë¥¼ êµ¬í•˜ëŠ”ë° ì„ í˜•ì‹œê°„ì´ ê±¸ë¦°ë‹¤ê³  ì•Œë ¤ì ¸ ìˆë‹¤.</p>

<h2 id="example">Example</h2>

<p>ìœ„ìƒì •ë ¬ì€ í˜„ì‹¤ì ì¸ ì˜ˆë¡œëŠ” ì œì•½ì— ë”°ë¥¸ ì‘ì—…ë“¤ì˜ ìŠ¤ì¼€ì¤„ë§ ìˆœì„œë¼ê³  ì´í•´í•˜ë©´ ëœë‹¤. ì‘ì—…ë“¤ì€ ì •ì ìœ¼ë¡œ ë‚˜íƒ€ë‚´ì–´ì§€ê³  ì •ì ì—ì„œ ë‹¤ë¥¸ ì •ì ìœ¼ë¡œì˜ ê°„ì„ ì´ ìˆëŠ”ë°, ì´ëŠ”, x, y ë‘ ì •ì ì„ ë ì ìœ¼ë¡œ í•˜ê³  x-&gt;yë¡œì˜ ë°©í–¥ ê°„ì„  E(x,y)ì´ ìˆì„ ë•Œ ì‘ì—… yê°€ ìˆ˜í–‰ë˜ê¸° ìœ„í•´ì„œëŠ” xê°€ ì‚¬ì „ì— ë¨¼ì € ìˆ˜í–‰ ì™„ë£Œë˜ì–´ì•¼ í•œë‹¤ëŠ” ê²ƒì„ ëœ»í•œë‹¤. ì‘ì—… yì˜ ì œì•½ì€ xì¸ ê²ƒì´ë‹¤. ì´ì²˜ëŸ¼ ì œì•½ì´ ìˆëŠ” í•´ë‹¹ ì‘ì—…ë“¤ì— ëŒ€í•´ì„œ ìœ„ìƒì •ë ¬ì€ ì‘ì—…ë“¤ì˜ ìˆ˜í–‰ìˆœì„œë¥¼ ë‚˜íƒ€ë‚¸ë‹¤.</p>

<p>ë°‘ ê·¸ë¦¼ì—ì„œ 5ë²ˆ ì •ì ê³¼ 11ë²ˆ ì •ì ì„ ë³´ì. ì •ì ì€ ì‘ì—…ìœ¼ë¡œ ìƒê°í•˜ê³  ê°„ì„ ì€ ì œì•½ ë˜ëŠ” ì‘ì—… íë¦„ìœ¼ë¡œ ë³´ë©´ ìœ„ìƒì •ë ¬ì—ì„œëŠ” 5ë²ˆ ì‘ì—…ì´ ì™„ë£Œë˜ê³  11ë²ˆ ì‘ì—…ì´ ìˆ˜í–‰ëœë‹¤ëŠ” ê²ƒì´ë‹¤. ì¦‰, 11ë²ˆ ì‘ì—…ì´ ìˆ˜í–‰ë˜ê¸° ìœ„í•´ì„  5ë²ˆ ì‘ì—…ì´ ì‚¬ì „ì— ì™„ë£Œê°€ ë˜ì–´ì•¼ í•œë‹¤ëŠ” ê²ƒì„ ë§í•œë‹¤. ë‹¤ë¥¸ ì‘ì—…ë“¤ë„ ë§ˆì°¬ê°€ì§€ë¡œ, 9ë²ˆ ì •ì ì´ ìˆ˜í–‰ë˜ê¸° ìœ„í•´ì„œëŠ” 11ë²ˆê³¼ 8ë²ˆ ì‘ì—…ì´ ì‚¬ì „ì— ì™„ë£Œê°€ ë˜ì–´ì•¼ í•œë‹¤.</p>

<p><img src="/assets/images/topological-sort0.png" alt="alt" width="300px" height="200px" class="align-center" /></p>

<p class="notice--warning"><strong>ìœ„ìƒìˆœì„œ:</strong> DAGì˜ ëª¨ë“  ê°„ì„  <code class="highlighter-rouge">u-&gt;v</code>ì— ëŒ€í•´ì„œ, ì •ì  uëŠ” vë³´ë‹¤ ìˆœì„œìƒì—ì„œ ë¨¼ì € ë‚˜ì™€ì•¼ í•œë‹¤.</p>

<p>ë‹¤ìŒì€ ìœ„ ê·¸ë¦¼ì—ì„œì˜ ìœ„ìƒì •ë ¬ ìˆœì„œì¸ë° ê¸°ì¤€ì— ë”°ë¼ ì—¬ëŸ¬ê°€ì§€ê°€ ìˆì„ ìˆ˜ ìˆë‹¤.</p>

<ul>
  <li><code class="highlighter-rouge">5-&gt;7-&gt;3-&gt;11-&gt;8-&gt;2-&gt;9-&gt;10</code> (ì™¼ìª½ì—ì„œ ì˜¤ë¥¸ìª½, ë°‘ì—ì„œ ì•„ë˜ë¡œ)</li>
  <li><code class="highlighter-rouge">3-&gt;5-&gt;7-&gt;8-&gt;11-&gt;2-&gt;9-&gt;10</code> (í˜„ì¬ ì‘ì—… ê°€ëŠ¥í•œ ì‘ì—…ë“¤ì˜ ë²ˆí˜¸ê°€ ì‘ì€ìˆœì„œ)</li>
  <li><code class="highlighter-rouge">3-&gt;7-&gt;8-&gt;5-&gt;11-&gt;10-&gt;2-&gt;9</code> (í˜„ì¬ ì‘ì—… ê°€ëŠ¥í•œ ì‘ì—…ë“¤ì˜ ë¬´ì‘ìœ„ ì„ íƒ)</li>
</ul>

<h2 id="algorithm">Algorithm</h2>

<p>DAGì—ì„œì˜ ìœ„ìƒì •ë ¬ì„ êµ¬í•˜ëŠ” ë‘ ê°€ì§€ ì•Œê³ ë¦¬ì¦˜ì„ ì‚´í´ë³´ì.<br />
ì´ ë‘ ì•Œê³ ë¦¬ì¦˜ì€ ëª¨ë‘ $O(V+E)$ì˜ ì„ í˜•ì‹œê°„ì— ë™ì‘í•œë‹¤. VëŠ” ì •ì ì˜ ê°œìˆ˜, EëŠ” ê°„ì„ ì˜ ê°œìˆ˜ì´ë‹¤.</p>

<h3 id="kahns-algorithm">Kahnâ€™s algorithm</h3>

<p>ìœ„ìƒì •ë ¬ì„ êµ¬í•˜ëŠ” ì´ ì•Œê³ ë¦¬ì¦˜ì€ Kahn (1962)ì— ì˜í•´ ì²˜ìŒ ì†Œê°œ ë˜ì—ˆë‹¤.</p>

<p>Kahnâ€™s algorithmì€ í•´ë‹¹ ê·¸ë˜í”„ì—ì„œì˜ ì§„ì…ê°„ì„ (Incoming edge)ì„ ê°€ì§€ê³  ìˆì§€ ì•Šì€ ì •ì ë“¤ë¡œ ë¶€í„° ì‹œì‘í•´ì„œ ê·¸ ì •ì ë“¤ì˜ ì§„ì¶œê°„ì„ (Outgoing edge)ì„ ì‚­ì œ ë˜ëŠ” ê·¸ ì •ì ê³¼ ì—°ê²°ëœ ì •ì ì˜ ì§„ì…ê°„ì„ ((Incoming edge)ì„ ì‚­ì œ í•˜ë©´ì„œ ë™ì‘í•œë‹¤.</p>

<p>ë‹¤ìŒì€ Kahnâ€™s algorithmì˜ ìœ„ìƒì •ë ¬ ì˜ì‚¬ì½”ë“œì´ë‹¤.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>S â† Set of all nodes with no incoming edge
L â† Empty list that will contain the sorted elements

while S is non-empty do
    remove a node n from S
    add n to tail of L
    for each node m with an edge e from n to m do
        remove edge e from the graph
        if m has no other incoming edges then
            insert m into S

if graph has edges then
    return error   (graph has at least one cycle)
else 
    return L   (a topologically sorted order)
</code></pre></div></div>

<ol>
  <li>ì§„ì…ê°„ì„ ì´ ì—†ëŠ” ì—†ëŠ” ì •ì ë“¤ì„ ì‹œì‘ ë¦¬ìŠ¤íŠ¸ Sì— ë„£ëŠ”ë‹¤.</li>
  <li>Sê°€ ë¹ˆ ê³µê°„ì´ ì•„ë‹ ë•Œ ê¹Œì§€ ë‹¤ìŒì„ ë°˜ë³µí•œë‹¤.</li>
  <li>Sì˜ ì•ì—ì„œ ë¶€í„° ì •ì  nì„ í•˜ë‚˜ ì·¨í•´ì„œ ìœ„ìƒì •ë ¬ ë¦¬ìŠ¤íŠ¸ Lì˜ ëì— ì¶”ê°€í•œë‹¤.</li>
  <li>ì •ì  nê³¼ mì„ ì–‘ ëì ìœ¼ë¡œ í•˜ëŠ” ê°„ì„  eì™€ ì •ì  mì— ëŒ€í•´ì„œ
    <ol>
      <li>ê°„ì„  eë¥¼ ì‚­ì œí•œë‹¤. (ì •ì  mì˜ ì§„ì…ê°„ì„  ì‚­ì œì™€ ê°™ì€ ì˜ë¯¸ì´ë‹¤.)</li>
      <li>ì •ì  mì˜ ì§„ì…ê°„ì„ ì˜ ê°œìˆ˜ê°€ 0ê°œë¼ë©´, Sì— mì„ ì¶”ê°€í•œë‹¤.</li>
    </ol>
  </li>
  <li>ê·¸ë˜í”„ì— ê°„ì„ ì´ ë‚¨ì•„ìˆìœ¼ë©´ ì ì–´ë„ í•˜ë‚˜ì˜ ì‚¬ì´í´ì´ ìˆë‹¤ëŠ” ì˜ë¯¸ì´ë¯€ë¡œ errorë¥¼ ë¦¬í„´í•œë‹¤. ê·¸ë ‡ì§€ ì•Šìœ¼ë©´ ìœ„ìƒì •ë ¬ ìˆœì„œë¥¼ ë¦¬í„´í•œë‹¤.</li>
</ol>

<hr />

<p>ìœ„ìƒì •ë ¬ì„ ì ìš©í•  ê·¸ë˜í”„ê°€ DAGì´ë¼ë©´ ì´ ì•Œê³ ë¦¬ì¦˜ì€ ìœ„ìƒì •ë ¬ ìˆœì„œ Lì„ ë¦¬í„´í•  ê²ƒì´ê³ , ê·¸ë˜í”„ì— ì‚¬ì´í´ì´ í•˜ë‚˜ë¼ë„ ìˆë‹¤ë©´ ìœ„ìƒì •ë ¬ì€ ë¶ˆê°€ëŠ¥í•˜ë‹¤.</p>

<p>ì§‘í•© Sì—ì„œ nì´ ì‚­ì œë˜ëŠ” ìˆœì„œì— ë”°ë¼ ìœ„ìƒì •ë ¬ì˜ ê²°ê³¼ëŠ” ë‹¬ë¼ì§€ê¸° ë•Œë¬¸ì—, í•œ ê·¸ë˜í”„ì—ì„œ ìœ„ìƒì •ë ¬ì€ íŠ¹ì •í•˜ì§€ ì•Šê³  ì—¬ëŸ¬ê°œê°€ ì¡´ì¬í•  ìˆ˜ ìˆë‹¤. SëŠ” íì™€ ìŠ¤íƒ ê°™ì€ ì •ì ë“¤ì„ ë‹´ì„ ìˆ˜ ìˆëŠ” ì§‘í•©ì´ ë  ìˆ˜ ìˆë‹¤.</p>

<p>êµ¬í˜„ì— ìˆì–´ì„œ ê°„ì„ ì„ ì‚­ì œí•˜ëŠ” ë°©ë²•ê³¼ ì •ì  mì˜ ì§„ì…ê°„ì„  ê°œìˆ˜ë¥¼ ì¶”ì í•˜ëŠ” ë°©ë²•ì€ ê° ì •ì ë§ˆë‹¤ ì§„ì…ê°„ì„ ì˜ ê°œìˆ˜ë¥¼ ê°€ì§€ê³  ìˆëŠ” ë°°ì—´ì„ ë‘ ìœ¼ë¡œì¨ ì‰½ê²Œ êµ¬í˜„ì´ ê°€ëŠ¥í•˜ë‹¤.</p>

<ul>
  <li>indegree[m]ì€ mì˜ ì§„ì…ê°„ì„  ê°œìˆ˜ë¥¼ ì˜ë¯¸í•œë‹¤.</li>
  <li>indegree[m] = indegree[m] - 1 ì„ í•¨ìœ¼ë¡œì¨ mì˜ ì§„ì…ê°„ì„ ì„ í•˜ë‚˜ ì‚­ì œí•  ìˆ˜ ìˆë‹¤.</li>
  <li>indegree[m] == 0 ì´ë©´ mì˜ ì§„ì…ê°„ì„ ì€ ì—†ìœ¼ë¯€ë¡œ mì„ Sì— ì¶”ê°€í•œë‹¤.</li>
</ul>

<h3 id="depth-first-search">Depth-first search</h3>

<p>ìœ„ìƒì •ë ¬ì„ êµ¬í•˜ëŠ” ë‹¤ë¥¸ ë°©ë²•ì€ ê¹Šì´ìš°ì„ íƒìƒ‰(Depth-first search)ì— ê¸°ë°˜í•œ ê²ƒì´ë‹¤.</p>

<p>ì´ ë°©ë²•ì€ ê·¸ë˜í”„ì˜ ê¸°ì¤€ì— ë”°ë¼ ë˜ëŠ” ì„ì˜ì˜ ìˆœì„œë¡œ ë…¸ë“œë“¤ì„ íƒìƒ‰í•´ ë‚˜ê°€ë‹¤ê°€ ì´ë¯¸ ë°©ë¬¸ì´ ì™„ë£Œëœ ì •ì  ë˜ëŠ” ë” ì´ìƒ íƒìƒ‰í•  ì •ì ì„ ê°€ì§€ì§€ ì•Šì€ ì •ì ì— ëŒ€í•´ì„œ ìœ„ìƒì •ë ¬ ë¦¬ìŠ¤íŠ¸ì— ë…¸ë“œë¥¼ ì¶”ê°€í•˜ëŠ” ë°©ë²•ì´ë‹¤.</p>

<p>ë‹¤ìŒì€ Depth-first searchì— ê¸°ë°˜í•œ ìœ„ìƒì •ë ¬ì˜ ì˜ì‚¬ì½”ë“œì´ë‹¤.</p>

<ul>
  <li><code class="highlighter-rouge">permanent mark</code>: ë” ì´ìƒ ë°©ë¬¸í•  ì •ì ì´ ì—†ì–´ DFS íƒìƒ‰ì´ ëë‚œ ì •ì ì˜ í‘œì‹œë¥¼ ëœ»í•œë‹¤.</li>
  <li><code class="highlighter-rouge">temporary mark</code>: DFS íƒìƒ‰ì´ ì§„í–‰ ì¤‘ì¸ ì •ì ì˜ í‘œì‹œë¥¼ ëœ»í•œë‹¤.</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>L â† Empty list that will contain the sorted nodes
while exists nodes without a permanent mark do
    select an unmarked node n
    visit(n)

function visit(node n)
    if n has a permanent mark then
        return
    if n has a temporary mark then
        stop   (not a DAG)

    mark n with a temporary mark

    for each node m with an edge from n to m do
        visit(m)

    remove temporary mark from n
    mark n with a permanent mark
    add n to head of L
</code></pre></div></div>

<p>DAGì—ì„œ ë°©ë¬¸ì™„ë£Œ ë˜ì§€ ì•Šì€ ì •ì ë“¤ì´ ìˆëŠ” ë™ì•ˆ, ì •ì ì„ í•˜ë‚˜ ì„ íƒí•´ íƒìƒ‰ì„ ì§„í–‰í•œë‹¤.</p>

<p>function visit(node n):</p>
<ol>
  <li>ì •ì  nì´ ë°©ë¬¸ì™„ë£Œ ì •ì ì´ë©´ ë°±íŠ¸ë™ í•œë‹¤.</li>
  <li>ì •ì  nì´ í˜„ì¬ ë°©ë¬¸ ì¤‘ì¸ ì •ì ì´ë©´ ì—­ ê°„ì„ (Back edge)ì´ ìˆë‹¤ëŠ” ê²ƒì´ë¯€ë¡œ ì‚¬ì´í´ì´ ìˆë‹¤ëŠ” ë§ì´ëœë‹¤. ì•Œê³ ë¦¬ì¦˜ì„ ì¢…ë£Œí•œë‹¤.</li>
  <li>ìœ„ 1, 2ë²ˆ ì¡°ê±´ì´ ì•„ë‹ˆë¼ë©´, ì •ì  nì„ ì§„í–‰ ì¤‘ì¸ ì •ì ìœ¼ë¡œ í‘œì‹œí•œë‹¤.</li>
  <li>ì •ì  nê³¼ mì„ ì–‘ ëì ìœ¼ë¡œ í•˜ëŠ” ê°„ì„ ì˜ ì •ì  mì— ëŒ€í•´ì„œ<br />
 ì •ì  mì„ ì¬ê·€ì ìœ¼ë¡œ íƒìƒ‰í•œë‹¤. (1ë²ˆìœ¼ë¡œ ê°„ë‹¤.)</li>
  <li>ì •ì  nì„ ë°©ë¬¸ì™„ë£Œ í‘œì‹œí•˜ê³  Lì˜ ë§¨ ì²˜ìŒì— ì¶”ê°€í•œë‹¤.</li>
</ol>

<p>DFS í•¨ìˆ˜ì—ì„œ <code class="highlighter-rouge">temporary mark</code>ê²€ì‚¬ë¥¼ í•˜ê³  ìˆëŠ”ë°, DFS íƒìƒ‰ì— ìˆì–´ì„œ ë°©ë¬¸ë˜ì–´ ì§€ê³  ìˆëŠ” ì •ì ì´ ë°©ë¬¸ì™„ë£Œ ë˜ì§€ ëª»í•œ ì±„ ë‹¤ë¥¸ ì •ì ì— ì˜í•´ì„œ ë°©ë¬¸ì´ ë˜ë©´, ì—­ ê°„ì„ (Back edge)ì´ ìˆë‹¤ëŠ” ì˜ë¯¸ê°€ ëœë‹¤. ì´ëŠ” ì‚¬ì´í´ì´ ìˆë‹¤ëŠ” ê²ƒê³¼ ê°™ì€ ì˜ë¯¸ì´ë‹¤.</p>

<h2 id="implementation">Implementation</h2>

<p>ë‹¤ìŒì˜ êµ¬í˜„ë“¤ì€ ë°‘ì˜ ê·¸ë˜í”„ë¥¼ ì˜ˆì œë¡œ ì‚¬ìš©í•˜ì˜€ë‹¤.</p>

<p><img src="/assets/images/topological-sort1.png" alt="alt" width="300px" height="200px" class="align-center" /></p>

<p>ë‹¤ìŒì€ Kahnâ€™s algorithmì„ êµ¬í˜„í•œ java ì½”ë“œì´ë‹¤.</p>

<p>ì •ì ë“¤ì„ ë‹´ì„ ì§‘í•© Së¡œëŠ” ìŠ¤íƒì„ ì‚¬ìš©í•˜ì˜€ë‹¤.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="c1">// data structure to store graph edges</span>
<span class="kd">class</span> <span class="nc">Edge</span>
<span class="o">{</span>
	<span class="kt">int</span> <span class="n">source</span><span class="o">,</span> <span class="n">dest</span><span class="o">;</span>

	<span class="kd">public</span> <span class="nf">Edge</span><span class="o">(</span><span class="kt">int</span> <span class="n">source</span><span class="o">,</span> <span class="kt">int</span> <span class="n">dest</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">this</span><span class="o">.</span><span class="na">source</span> <span class="o">=</span> <span class="n">source</span><span class="o">;</span>
		<span class="k">this</span><span class="o">.</span><span class="na">dest</span> <span class="o">=</span> <span class="n">dest</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">};</span>

<span class="c1">// class to represent a graph object</span>
<span class="kd">class</span> <span class="nc">Graph</span>
<span class="o">{</span>
	<span class="c1">// A List of Lists to represent an adjacency list</span>
	<span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">adjList</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

	<span class="c1">// stores indegree of a vertex</span>
	<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">indegree</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

	<span class="c1">// Constructor</span>
	<span class="nc">Graph</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Edge</span><span class="o">&gt;</span> <span class="n">edges</span><span class="o">,</span> <span class="kt">int</span> <span class="no">N</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">adjList</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;(</span><span class="no">N</span><span class="o">);</span>
		<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
			<span class="n">adjList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;());</span>
		<span class="o">}</span>

		<span class="c1">// initialize indegree of each vertex by 0</span>
		<span class="n">indegree</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;(</span><span class="nc">Collections</span><span class="o">.</span><span class="na">nCopies</span><span class="o">(</span><span class="no">N</span><span class="o">,</span> <span class="mi">0</span><span class="o">));</span>

		<span class="c1">// add edges to the undirected graph</span>
		<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">edges</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span>
		<span class="o">{</span>
			<span class="kt">int</span> <span class="n">src</span> <span class="o">=</span> <span class="n">edges</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">).</span><span class="na">source</span><span class="o">;</span>
			<span class="kt">int</span> <span class="n">dest</span> <span class="o">=</span> <span class="n">edges</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">).</span><span class="na">dest</span><span class="o">;</span>

			<span class="c1">// add an edge from source to destination</span>
			<span class="n">adjList</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">src</span><span class="o">).</span><span class="na">add</span><span class="o">(</span><span class="n">dest</span><span class="o">);</span>

			<span class="c1">// increment in-degree of destination vertex by 1</span>
			<span class="n">indegree</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">dest</span><span class="o">,</span> <span class="n">indegree</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">dest</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
		<span class="o">}</span>
	<span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">TopologicalSort</span>
<span class="o">{</span>
	<span class="c1">// performs Topological Sort on a given DAG</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="nf">doTopologicalSort</span><span class="o">(</span><span class="nc">Graph</span> <span class="n">graph</span><span class="o">,</span> <span class="kt">int</span> <span class="no">N</span><span class="o">)</span>
	<span class="o">{</span>
		<span class="c1">// list to store the sorted elements</span>
		<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="no">L</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

		<span class="c1">// get indegree information of the graph</span>
		<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">indegree</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="na">indegree</span><span class="o">;</span>

		<span class="c1">// Set of all nodes with no incoming edges</span>
		<span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="no">S</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Stack</span><span class="o">&lt;&gt;();</span>
		<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">indegree</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
				<span class="no">S</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
			<span class="o">}</span>
		<span class="o">}</span>

		<span class="k">while</span> <span class="o">(!</span><span class="no">S</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span>
		<span class="o">{</span>
			<span class="c1">// remove a node n from S</span>
			<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="no">S</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>

			<span class="c1">// add n to tail of L</span>
			<span class="no">L</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>

			<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">m</span> <span class="o">:</span> <span class="n">graph</span><span class="o">.</span><span class="na">adjList</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">n</span><span class="o">))</span>
			<span class="o">{</span>
				<span class="c1">// remove edge from n to m from the graph</span>
				<span class="n">indegree</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">m</span><span class="o">,</span> <span class="n">indegree</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">m</span><span class="o">)</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>

				<span class="c1">// if m has no other incoming edges then</span>
				<span class="c1">// insert m into S</span>
				<span class="k">if</span> <span class="o">(</span><span class="n">indegree</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">m</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
					<span class="no">S</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">m</span><span class="o">);</span>
				<span class="o">}</span>
			<span class="o">}</span>
		<span class="o">}</span>

		<span class="c1">// if graph has edges then graph has at least one cycle</span>
		<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">indegree</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
				<span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
			<span class="o">}</span>
		<span class="o">}</span>

		<span class="k">return</span> <span class="no">L</span><span class="o">;</span>
	<span class="o">}</span>

	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span>
	<span class="o">{</span>
		<span class="c1">// List of graph edges as per above diagram</span>
		<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Edge</span><span class="o">&gt;</span> <span class="n">edges</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span>
							<span class="k">new</span> <span class="nf">Edge</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">6</span><span class="o">),</span> <span class="k">new</span> <span class="nc">Edge</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">),</span> <span class="k">new</span> <span class="nc">Edge</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">),</span>
							<span class="k">new</span> <span class="nf">Edge</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">6</span><span class="o">),</span> <span class="k">new</span> <span class="nc">Edge</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">0</span><span class="o">),</span> <span class="k">new</span> <span class="nc">Edge</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">),</span>
							<span class="k">new</span> <span class="nf">Edge</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">1</span><span class="o">),</span> <span class="k">new</span> <span class="nc">Edge</span><span class="o">(</span><span class="mi">7</span><span class="o">,</span> <span class="mi">0</span><span class="o">),</span> <span class="k">new</span> <span class="nc">Edge</span><span class="o">(</span><span class="mi">7</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>
						<span class="o">);</span>

		<span class="c1">// Set number of vertices in the graph</span>
		<span class="kd">final</span> <span class="kt">int</span> <span class="no">N</span> <span class="o">=</span> <span class="mi">8</span><span class="o">;</span>

		<span class="c1">// create a graph from edges</span>
		<span class="nc">Graph</span> <span class="n">graph</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Graph</span><span class="o">(</span><span class="n">edges</span><span class="o">,</span> <span class="no">N</span><span class="o">);</span>

		<span class="c1">// Perform Topological Sort</span>
		<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="no">L</span> <span class="o">=</span> <span class="n">doTopologicalSort</span><span class="o">(</span><span class="n">graph</span><span class="o">,</span> <span class="no">N</span><span class="o">);</span>

		<span class="k">if</span> <span class="o">(</span><span class="no">L</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
			<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="no">L</span><span class="o">);</span>  <span class="c1">// print topological order</span>
		<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
			<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Graph has at least one cycle. "</span> <span class="o">+</span>
							  <span class="s">"Topological sorting is not possible"</span><span class="o">);</span>
		<span class="o">}</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Output:
7 5 1 2 3 4 0 6
</code></pre></div></div>

<h2 id="references">References</h2>

<ul>
  <li><a href="https://www.techiedelight.com/kahn-topological-sort-algorithm/">Topological Sorting - Kahnâ€™s algorithm</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Topological_sorting">Topological Sorting</a></li>
</ul>
:ET