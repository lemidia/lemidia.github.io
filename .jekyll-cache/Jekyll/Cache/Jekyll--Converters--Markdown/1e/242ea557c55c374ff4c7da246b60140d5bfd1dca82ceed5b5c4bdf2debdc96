I"<h1 id="기본적인-컴퓨터-시스템">기본적인 컴퓨터 시스템</h1>

<hr />

<p>파이썬 개발환경을 준비하기에 앞서서 <strong>기본적인 컴퓨터 시스템</strong>을 알아봅니다. 그 중에서도 크게 <strong>운영체제, 파일 시스템 그리고 터미널 환경</strong>에 대해서 알아봅니다.</p>

<h2 id="운영체제">운영체제</h2>

<p>Operating System, 줄여서 OS 라고 하며, 컴퓨터에서 여러 프로그램들이 동작될 수 있는 환경을 제공하는 역할을 합니다. 우리가 사용하는 응용 프로그램과 물리적 하드웨어 사이에서 상호작용하는 소프트웨어라고 할 수 있습니다.</p>

<p>대표적으로 마이크로 소프트 사의 윈도우 10, 애플의 매킨토시, Linux가 운영체제의 한 종류들 입니다.</p>

<p>우리가 사용하는 응용 프로그램들은 운영체제에 의존적(dependent)입니다. 이는 특정 프로그램이 특정 운영체제에서만 실행이 가능한 것을 말합니다. 따라서 응용 프로그램은 특정 운영체제에 맞춰서 개발이 됩니다.</p>

<h2 id="파일-시스템">파일 시스템</h2>

<p>File system, 파일 시스템은 OS에서 파일을 저장하는 트리 구조 저장 체계 입니다.</p>

<p>크게 두 가지 요소인 디렉터리와 파일로 구성되어 있는 것을 볼 수 있습니다.</p>

<ul>
  <li>디렉터리(Directory) : 폴더라고도 하며, 파일 또는 또 다른 디렉터리를 포함 할 수 있는 단위입니다.</li>
  <li>파일(File) : 컴퓨터에서 정보를 저장하는 논리적인 단위입니다. 파일 이름은 파일명과 확장자로 구성되고 이 둘 사이에 .(dot)이 들어가게 됩니다. (main.py). 실행, 쓰기, 읽기 등을 할 수 있습니다.</li>
</ul>

<p>파일 시스템에서는 파일과 디렉터리들이 최상단의 루트(root)디렉터리 부터 위나 옆으로 가지가 뻗는 듯한 트리 구조로 구성이 되어집니다.</p>

<p>윈도우의 경우 <code class="highlighter-rouge">C:\user\...</code> 에서 user가 루트 디렉터리 입니다.</p>

<p>파일 시스템에서의 경로는 컴퓨터 내에서 파일이나 자원의 고유한 위치를 가르키는 주소와 같습니다. 트리 구조 상 노드간의 연결정도로 봐도 좋을 것 같습니다.</p>

<p>절대 경로와 상대경로</p>

<ul>
  <li>절대 경로 : 루트 디렉터리부터 파일 위치까지의 경로. ex) <code class="highlighter-rouge">C:\user\codebase\helloworld.py</code></li>
  <li>상대 경로 : 현재 시스템이 위치해 있는 디렉터리부터 우리가 찾고자하는 파일까지의 경로. ex) <code class="highlighter-rouge">../../index.html</code></li>
</ul>

<h2 id="터미널">터미널</h2>

<p>터미널은 보통 CLI(Command Line Interface)라고도 하며, Mouse가 아닌 키보드를 이용해서 명령어 입력을 통해 컴퓨터를 제어하기 위해 사용하는 툴이라고 볼 수 있습니다.</p>

<p>Graphic User Interface (GUI)와는 달리 키보드를 이용해 text로서 명령을 내리는 인터페이스 체계로서, Graphic User Interface (GUI)환경이 일반화 되기 전까지는 이 CLI가 주로 사용 되었습니다.
지금도 맥과 유닉스 계열 시스템에서는 프로그램을 설치하고 여러 라이브러리를 관리하는 데에 이 CLI를 주로 많이 사용하고 있고, github의 사용이 증가함에 따라 다른 환경에서도 CLI의 사용이 많아 지고 있습니다.</p>

<p>다음은 윈도우와 맥에서 터미널을 실행할 수 있는 방법입니다.</p>

<ul>
  <li>윈도우의 경우 : <code class="highlighter-rouge">윈도우 키 + terminal 또는 윈도우 키 + R -&gt; CMD 입력</code></li>
  <li>맥의 경우 : <code class="highlighter-rouge">빠른실행 terminal 입력</code></li>
</ul>

<p><strong>쉘</strong></p>

<p>쉘은 조개 껍데기라는 의미로서 터미널을 사용하고, 여러 프로그램을 작동시키기 위한 소프트웨어 환경을 말합니다.
쉘은 키보드 입력으로 시스템 전반에 걸쳐 필수적인 파일 구조에 대한 연산(폴더 이동, 복사, 생성, 삭제 등)과 스크립트 작성을 지원하는 등 여러 기능을 제공합니다.</p>

<p>윈도우에서는 cmd나 power shell을 사용하고, 맥에서는 bash나 zsh를 쉘로 사용합니다.</p>

<p>다음은 shell의 일부 명령어 리스트 입니다. (셀 별로 명령어가 상이하거나 같습니다.)</p>

<ul>
  <li>디렉터리 이동 : <code class="highlighter-rouge">window cmd - cd, bash - cd</code></li>
  <li>텍스트 전부를 지우기 : <code class="highlighter-rouge">window cmd - CLS, bash - clear</code></li>
  <li>파일을 다른 위치로 복사 : <code class="highlighter-rouge">window cmd - copy, bash - cp</code></li>
  <li>파일 지우기 : <code class="highlighter-rouge">window cmd - del, bash - rm</code></li>
  <li>하위 디렉터리와 파일 보기 : <code class="highlighter-rouge">window cmd - dir, bash - ls</code></li>
</ul>

<h1 id="파이썬">파이썬</h1>

<p>파이썬(Python)은 1991년 프로그래머인 귀도 반 로섬이 발표한 고급 프로그래밍 언어로, 플랫폼에 독립적이며 인터프리터식, 객체지향적, 동적 타이핑(dynamically typing) 대화형 언어입니다.</p>

<p>python은 그리스 신화속의 괴물 뱀을 뜻하고, 몬티 파이썬이라는 코메디 그룹의 이름에서 유래되었다고 합니다.</p>

<p>파이썬의 주요 특징은 특징은 다음과 같습니다.</p>

<ul>
  <li>동적 타이핑(dynamically typing) : 프로그램의 실행 시간(run time)에 자료형이 검사되고 결정됩니다.</li>
  <li>플랫폼에 독립적 : 여기서 플랫폼은 보통 OS를 일컽는데, 파이썬으로 작성된 프로그램은 OS의 종류에 관계없이 어디서나 실행이 될 수 있다는 것을 의미합니다.</li>
  <li>인터프리터식 : 소스코드를 바로 실행할 수 있게 지원하는 프로그램 실행 방법으로서, 별도 번역과정 없이 소스코드를 실행시점에 해석하여 컴퓨터가 처리할 수 있도록 하는 방법입니다.</li>
  <li>객체 지향적 언어 : 실행 순서가 아닌 단위 모듈(객체)을 중심으로 프로그램을 작성할 수 있도록 고안된 언어를 말합니다. 객체는 실세계에 존재하는 사물과 같은 개념을 컴퓨터에서 표현하는 것으로, 객체는 속성과 목적을 달성하기 위한 행동을 가지고 있습니다.</li>
</ul>

<p><strong>다음은 SPFA의 의사코드이다.</strong></p>

<p>Input: 그래프 G, 시작 정점 s</p>

<p>$Q$는 변 경감 연산이 되고 난 후의 후보자를 담을 Queue를 의미한다.<br />
$w(u,v)$는 간선 $(u,v)$의 간선 가중치를 의미한다.</p>

<p class="notice--warning"><strong>Notice:</strong> Q 안에 v의 존재 유무를 판단하기 위해 구현 시에는 이를 추적하기 위한 추가적인 자료구조가 요구된다.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="mi">0</span> <span class="n">procedure</span> <span class="n">Shortest</span><span class="o">-</span><span class="n">Path</span><span class="o">-</span><span class="n">Faster</span><span class="o">-</span><span class="n">Algorithm</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
 <span class="mi">1</span>    <span class="k">for</span> <span class="n">each</span> <span class="n">vertex</span> <span class="n">v</span> <span class="err">≠</span> <span class="n">s</span> <span class="n">in</span> <span class="n">V</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
 <span class="mi">2</span>        <span class="n">d</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">:=</span> <span class="err">∞</span>
 <span class="mi">3</span>    <span class="n">d</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">:=</span> <span class="mi">0</span>
 <span class="mi">4</span>    <span class="n">offer</span> <span class="n">s</span> <span class="n">into</span> <span class="n">Q</span>
 <span class="mi">5</span>    <span class="k">while</span> <span class="n">Q</span> <span class="n">is</span> <span class="n">not</span> <span class="n">empty</span>
 <span class="mi">6</span>        <span class="n">u</span> <span class="o">:=</span> <span class="n">poll</span> <span class="n">Q</span>
 <span class="mi">7</span>        <span class="k">for</span> <span class="n">each</span> <span class="n">edge</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="n">in</span> <span class="n">E</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
 <span class="mi">8</span>            <span class="k">if</span> <span class="n">d</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">+</span> <span class="n">w</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">d</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="n">then</span>
 <span class="mi">9</span>                <span class="n">d</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">:=</span> <span class="n">d</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">+</span> <span class="n">w</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
<span class="mi">10</span>                <span class="k">if</span> <span class="n">v</span> <span class="n">is</span> <span class="n">not</span> <span class="n">in</span> <span class="n">Q</span> <span class="n">then</span>
<span class="mi">11</span>                    <span class="n">offer</span> <span class="n">v</span> <span class="n">into</span> <span class="n">Q</span>
</code></pre></div></div>

<hr />

<p>하나씩 보자.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">1</span>    <span class="k">for</span> <span class="n">each</span> <span class="n">vertex</span> <span class="n">v</span> <span class="err">≠</span> <span class="n">s</span> <span class="n">in</span> <span class="n">V</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="mi">2</span>        <span class="n">d</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">:=</span> <span class="err">∞</span>
</code></pre></div></div>

<p>그래프 G의 출발 정점 s를 제외한 모든 정점 v에 대하여 s로부터 각 v에 대한 최단경로 거리 d(v)를 INF로 초기화 한다.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="mi">3</span>    <span class="n">d</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">:=</span> <span class="mi">0</span>
 <span class="mi">4</span>    <span class="n">offer</span> <span class="n">s</span> <span class="n">into</span> <span class="n">Q</span>
</code></pre></div></div>

<p>먼저 출발 정점 s의 최단경로 거리를 0으로 초기화하고 s를 Q에 넣는다.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">5</span>    <span class="k">while</span> <span class="n">Q</span> <span class="n">is</span> <span class="n">not</span> <span class="n">empty</span>
</code></pre></div></div>

<p>큐가 빌 때 까지 아래 연산들을 반복한다.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">6</span>    <span class="n">u</span> <span class="o">:=</span> <span class="n">poll</span> <span class="n">Q</span>
<span class="mi">7</span>    <span class="k">for</span> <span class="n">each</span> <span class="n">edge</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="n">in</span> <span class="n">E</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</code></pre></div></div>

<p>Q에서 정점하나를 꺼내 u라 하고, 그래프 G에서 u와 인접한 정점 v와의 간선 (u, v)에 대하여</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">8</span>    <span class="k">if</span> <span class="n">d</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">+</span> <span class="n">w</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">d</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="n">then</span>
<span class="mi">9</span>       <span class="n">d</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">:=</span> <span class="n">d</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">+</span> <span class="n">w</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
</code></pre></div></div>

<p>s로부터 u로의 최단경로 거리 d(u) + 간선 (u, v)의 값이 s로부터 v로의 최단경로 거리 d(v)보다 작다면 d(v)값을 d(u) + w(u, v)로 업데이트 한다. (Edge Relaxation)</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">10</span>      <span class="k">if</span> <span class="n">v</span> <span class="n">is</span> <span class="n">not</span> <span class="n">in</span> <span class="n">Q</span> <span class="n">then</span>
<span class="mi">11</span>          <span class="n">offer</span> <span class="n">v</span> <span class="n">into</span> <span class="n">Q</span>
</code></pre></div></div>

<p>변 경감 연산(Edge Relaxation)이 된 정점 v가 현재 Q에 없으면, v를 Q에 추가한다.</p>

<h2 id="step-by-step">Step by step</h2>

<p>실제 그래프를 예로 들어 SPFA가 어떻게 동작하는지 알아보자.</p>

<p>0번을 시작 정점으로 하여 5번 정점으로의 최단 경로를 구한다.</p>

<p>해당 정점에 연결된 인접 정점이 여러개 일 땐, 번호가 작은 것을 먼저 선택한다.</p>

<p><img src="/assets/images/SPFA-0.png" alt="Alt text" width="400px" height="300px" class="align-center" /></p>

<p>시작 정점으로 부터 모든 정점까지의 최단거리 d(v)를 무한대(INF)로 초기화 한다.<br />
d(s)는 0으로 초기화 한다.</p>

<p>Queue에 시작 정점 0을 넣는다.<br />
<code class="highlighter-rouge">Queue : [0]</code></p>

<p><img src="/assets/images/SPFA-1.png" alt="Alt text" width="400px" height="300px" class="align-center" /></p>

<p>Queue에서 원소 하나를 pop한다.<br />
0번 정점과 인접한 정점 1번에 대하여 <code class="highlighter-rouge">d(0) + w(0, 1) &lt; d(1): 0 + 4 &lt; INF</code>이므로
d(1)을 4로 업데이트 한다.</p>

<p>업데이트 되었으므로 1번 정점을 Queue에 넣는다.<br />
<code class="highlighter-rouge">Queue : [1]</code></p>

<p><img src="/assets/images/SPFA-2.png" alt="Alt text" width="400px" height="300px" class="align-center" /></p>

<p>0번 정점과 인접한 정점 2번에 대하여 <code class="highlighter-rouge">d(0) + w(0, 2) &lt; d(1): 0 + 2 &lt; INF</code>이므로
d(2)을 2로 업데이트 한다.</p>

<p>업데이트 되었으므로 2번 정점을 Queue에 넣는다.<br />
<code class="highlighter-rouge">Queue : [1 2]</code></p>

<p><img src="/assets/images/SPFA-3.png" alt="Alt text" width="400px" height="300px" class="align-center" /></p>

<p>Queue에서 원소 하나를 pop한다.<br />
1번 정점과 인접한 정점 2번에 대하여 <code class="highlighter-rouge">d(1) + w(1, 2) &lt; d(2): 4 + 5 &gt; 2</code>이므로
d(2)를 업데이트 하지 않는다.</p>

<p><code class="highlighter-rouge">Queue : [2]</code></p>

<p><img src="/assets/images/SPFA-4.png" alt="Alt text" width="400px" height="300px" class="align-center" /></p>

<p>1번 정점과 인접한 정점 3번에 대하여 <code class="highlighter-rouge">d(1) + w(1, 3) &lt; d(3): 4 + 10 &lt; INF</code>이므로
d(3)을 14로 업데이트 한다.</p>

<p>업데이트 되었으므로 3번 정점을 Queue에 넣는다.<br />
<code class="highlighter-rouge">Queue : [2, 3]</code></p>

<p><img src="/assets/images/SPFA-5.png" alt="Alt text" width="400px" height="300px" class="align-center" /></p>

<p>Queue에서 원소 하나를 pop한다.<br />
2번 정점과 인접한 정점 4번에 대하여 <code class="highlighter-rouge">d(2) + w(2, 4) &lt; d(4): 2 + 3 &lt; INF</code>이므로
d(4)을 5로 업데이트 한다.</p>

<p>업데이트 되었으므로 4번 정점을 Queue에 넣는다.<br />
<code class="highlighter-rouge">Queue : [3, 4]</code></p>

<p><img src="/assets/images/SPFA-6.png" alt="Alt text" width="400px" height="300px" class="align-center" /></p>

<p>Queue에서 원소 하나를 pop한다.<br />
3번 정점과 인접한 정점 5번에 대하여 <code class="highlighter-rouge">d(3) + w(3, 5) &lt; d(5): 14 + 11 &lt; INF</code>이므로
d(5)을 25로 업데이트 한다.</p>

<p>업데이트 되었으므로 5번 정점을 Queue에 넣는다.<br />
<code class="highlighter-rouge">Queue : [4, 5]</code></p>

<p><img src="/assets/images/SPFA-6-1.png" alt="Alt text" width="400px" height="300px" class="align-center" /></p>

<p>Queue에서 원소 하나를 pop한다.<br />
4번 정점과 인접한 정점 3번에 대하여 <code class="highlighter-rouge">d(4) + w(4, 3) &lt; d(3): 5 + 4 &lt; 14</code>이므로
d(3)을 9로 업데이트 한다.</p>

<p>업데이트 되었으므로 3번 정점을 Queue에 넣는다.<br />
<code class="highlighter-rouge">Queue : [5, 3]</code></p>

<p><img src="/assets/images/SPFA-7.png" alt="Alt text" width="400px" height="300px" class="align-center" /></p>

<p>Queue에서 원소 하나를 pop한다.<br />
5번 정점과 인접한 정점이 없다.</p>

<p><code class="highlighter-rouge">Queue : [3]</code></p>

<p><img src="/assets/images/SPFA-8.png" alt="Alt text" width="400px" height="300px" class="align-center" /></p>

<p>Queue에서 원소 하나를 pop한다.<br />
3번 정점과 인접한 정점 5번에 대하여 <code class="highlighter-rouge">d(3) + w(3, 5) &lt; d(5): 9 + 11 &lt; 25</code>이므로
d(5)을 20로 업데이트 한다.</p>

<p>업데이트 되었으므로 5번 정점을 Queue에 넣는다.<br />
<code class="highlighter-rouge">Queue : [5]</code></p>

<p><img src="/assets/images/SPFA-9.png" alt="Alt text" width="400px" height="300px" class="align-center" /></p>

<p>Queue에서 원소 하나를 pop한다.<br />
5번 정점과 인접한 정점이 없다.</p>

<p><code class="highlighter-rouge">Queue : [ ]</code></p>

<p><img src="/assets/images/SPFA-10.png" alt="Alt text" width="400px" height="300px" class="align-center" /></p>

<p>큐가 비었으므로 SPFA가 완료되었다.</p>

<p>0번 부터 5번으로의 최단경로는 <strong>빨간선</strong>을 따라간 경로이고 그 거리는 <strong>20</strong>이다.</p>

<p><img src="/assets/images/SPFA-11.png" alt="Alt text" width="400px" height="300px" class="align-center" /></p>

<h2 id="implementation">Implementation</h2>

<p>다음은 위 의사코드를 바탕으로 SPFA를 구현한 자바 메소드이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="kt">void</span> <span class="nf">shortestPathFasterAlgorithm</span><span class="o">(</span><span class="kt">int</span> <span class="n">s</span><span class="o">){</span>
    <span class="n">dist</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
    <span class="n">onQueue</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
    <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">dist</span><span class="o">,</span> <span class="no">INF</span><span class="o">);</span>
    <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
    <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
    <span class="n">dist</span><span class="o">[</span><span class="n">s</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="n">onQueue</span><span class="o">[</span><span class="n">s</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(!</span><span class="n">queue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
        <span class="kt">int</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
        <span class="n">onQueue</span><span class="o">[</span><span class="n">cur</span><span class="o">]</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">Edge</span> <span class="n">e</span> <span class="o">:</span> <span class="n">graph</span><span class="o">[</span><span class="n">cur</span><span class="o">]){</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">dist</span><span class="o">[</span><span class="n">cur</span><span class="o">]</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="na">cost</span> <span class="o">&lt;</span> <span class="n">dist</span><span class="o">[</span><span class="n">e</span><span class="o">.</span><span class="na">to</span><span class="o">]){</span>
                <span class="n">dist</span><span class="o">[</span><span class="n">e</span><span class="o">.</span><span class="na">to</span><span class="o">]</span> <span class="o">=</span> <span class="n">dist</span><span class="o">[</span><span class="n">cur</span><span class="o">]</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="na">cost</span><span class="o">;</span> <span class="c1">// Edge Relaxation</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>현재 Queue에서 정점 $v$의 존재 유무를 추적하기 위해 위 코드에서는 <code class="highlighter-rouge">onQueue[]</code> 를 사용한다.</p>

<hr />

<p>그래프의 가중치 간선 정보를 구성하기 위해 아래의 Edge 클래스를 사용한다.</p>

<p><code class="highlighter-rouge">to</code>는 다음 인접 정점의 번호, cost는 간선 비용(가중치)를 나타낸다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">...</span>
<span class="c1">// static ArrayList&lt;Edge&gt; [] graph;</span>
<span class="o">...</span>

<span class="kd">static</span> <span class="kd">class</span> <span class="nc">Edge</span><span class="o">{</span>
    <span class="kt">int</span> <span class="n">to</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">cost</span><span class="o">;</span>

    <span class="c1">// Constructor</span>
    <span class="kd">public</span> <span class="nf">Edge</span><span class="o">(</span><span class="kt">int</span> <span class="n">to</span><span class="o">,</span> <span class="kt">int</span> <span class="n">cost</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">to</span> <span class="o">=</span> <span class="n">to</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">cost</span> <span class="o">=</span> <span class="n">cost</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<hr />

<p><strong>다음은 SPFA를 구현한 자바 코드이다.</strong></p>

<p>그래프의 입력은 예제 그래프를 사용하였고, 최단경로를 추적하고 구성하기 위해 pred[]배열을 선언한 뒤 SPFA의 실행 중에 어느 한 포인트에서 정점 u, v가 있고(정점 v가 u에 의해 relaxation 되어지는 정점), relaxation 되어진 정점 v가 있으면, 그 정점을 relaxation하게 만든 정점 u가 최단경로 상의 이전 노드 이므로 <code class="highlighter-rouge">pred[e.to] = cur;</code>를 하여 경로를 구축한다. 그 다음 <code class="highlighter-rouge">printPathReconstruction</code>함수로 경로를 출력한다.</p>

<p>이 프로그램은 최단경로 거리와 그 경로를 출력한다.</p>

<ul>
  <li>Input: Graph G, start vertex</li>
  <li>Output: Distance of shortest path of Graph G, shortest path of Graph G</li>
</ul>

<p>시작 정점은 0번이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.LinkedList</span><span class="o">;</span>

<span class="cm">/**
 * This program is to find Shortest path in weighted graph using SPFA.
 * Time Complexity : Worst case : O(VE) same as Standard Bellman ford
 *                   Average case : O(E) - not proved
 *
 * @author Lemidia(Gyeong)
 */</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ShortestPathFasterAlgorithm</span><span class="o">{</span>

     <span class="c1">// the number of vertices in Graph G</span>
    <span class="kd">static</span> <span class="kt">int</span> <span class="n">n</span><span class="o">;</span>
    <span class="c1">// Shortest distance from s to each vertex v</span>
    <span class="kd">static</span> <span class="kt">int</span> <span class="n">dist</span><span class="o">[];</span>
    <span class="c1">// for construct shortest path</span>
    <span class="kd">static</span> <span class="kt">int</span> <span class="n">pred</span><span class="o">[];</span>
    <span class="kd">static</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Edge</span><span class="o">&gt;</span> <span class="o">[]</span> <span class="n">graph</span><span class="o">;</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">INF</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
    <span class="c1">// For check whether the vertex is on queue or not</span>
    <span class="kd">static</span> <span class="kt">boolean</span> <span class="n">onQueue</span><span class="o">[];</span>


    <span class="c1">// Init Graph G</span>
    <span class="kd">static</span> <span class="kt">void</span> <span class="nf">createGraph</span><span class="o">(){</span>
        <span class="n">graph</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
            <span class="n">graph</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// Add weighted direct edges.</span>
    <span class="kd">static</span> <span class="kt">void</span> <span class="nf">addEdge</span><span class="o">(</span><span class="kt">int</span> <span class="n">from</span><span class="o">,</span> <span class="kt">int</span> <span class="n">to</span><span class="o">,</span> <span class="kt">int</span> <span class="n">cost</span><span class="o">){</span>
        <span class="nc">Edge</span> <span class="n">e</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Edge</span><span class="o">(</span><span class="n">to</span><span class="o">,</span> <span class="n">cost</span><span class="o">);</span>
        <span class="n">graph</span><span class="o">[</span><span class="n">from</span><span class="o">].</span><span class="na">add</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">static</span> <span class="kt">void</span> <span class="nf">shortestPathFasterAlgorithm</span><span class="o">(</span><span class="kt">int</span> <span class="n">s</span><span class="o">){</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="n">pred</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="n">onQueue</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">dist</span><span class="o">,</span> <span class="no">INF</span><span class="o">);</span>
        <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
        <span class="n">dist</span><span class="o">[</span><span class="n">s</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="n">onQueue</span><span class="o">[</span><span class="n">s</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(!</span><span class="n">queue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
            <span class="kt">int</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
            <span class="n">onQueue</span><span class="o">[</span><span class="n">cur</span><span class="o">]</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
            <span class="k">for</span> <span class="o">(</span><span class="nc">Edge</span> <span class="n">e</span> <span class="o">:</span> <span class="n">graph</span><span class="o">[</span><span class="n">cur</span><span class="o">]){</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">dist</span><span class="o">[</span><span class="n">cur</span><span class="o">]</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="na">cost</span> <span class="o">&lt;</span> <span class="n">dist</span><span class="o">[</span><span class="n">e</span><span class="o">.</span><span class="na">to</span><span class="o">]){</span>
                    <span class="n">dist</span><span class="o">[</span><span class="n">e</span><span class="o">.</span><span class="na">to</span><span class="o">]</span> <span class="o">=</span> <span class="n">dist</span><span class="o">[</span><span class="n">cur</span><span class="o">]</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="na">cost</span><span class="o">;</span> <span class="c1">// Edge Relaxation</span>
                    <span class="n">pred</span><span class="o">[</span><span class="n">e</span><span class="o">.</span><span class="na">to</span><span class="o">]</span> <span class="o">=</span> <span class="n">cur</span><span class="o">;</span> <span class="c1">// store previous node</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">onQueue</span><span class="o">[</span><span class="n">e</span><span class="o">.</span><span class="na">to</span><span class="o">]</span> <span class="o">==</span> <span class="kc">false</span><span class="o">){</span> <span class="c1">// Node(e.to) is not in the queue</span>
                        <span class="n">onQueue</span><span class="o">[</span><span class="n">e</span><span class="o">.</span><span class="na">to</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                        <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">to</span><span class="o">);</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">static</span> <span class="kt">void</span> <span class="nf">printPathReconstruction</span><span class="o">(</span><span class="kt">int</span> <span class="n">start</span><span class="o">,</span> <span class="kt">int</span> <span class="n">end</span><span class="o">){</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">end</span> <span class="o">==</span> <span class="n">start</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">start</span><span class="o">);</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">pathReconstruction</span><span class="o">(</span><span class="n">start</span><span class="o">,</span> <span class="n">pred</span><span class="o">[</span><span class="n">end</span><span class="o">]);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">" -&gt; "</span> <span class="o">+</span> <span class="n">end</span> <span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>

        <span class="n">n</span> <span class="o">=</span> <span class="mi">6</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="n">createGraph</span><span class="o">();</span>
        <span class="n">addEdge</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">);</span>
        <span class="n">addEdge</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">);</span>
        <span class="n">addEdge</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">5</span><span class="o">);</span>
        <span class="n">addEdge</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">10</span><span class="o">);</span>
        <span class="n">addEdge</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">3</span><span class="o">);</span>
        <span class="n">addEdge</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">11</span><span class="o">);</span>
        <span class="n">addEdge</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">);</span>

        <span class="n">shortestPathFasterAlgorithm</span><span class="o">(</span><span class="n">start</span><span class="o">);</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Shortest path distance : "</span> <span class="o">+</span> <span class="n">dist</span><span class="o">[</span><span class="mi">5</span><span class="o">]);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"Shortest path : "</span><span class="o">);</span>
        <span class="n">printPathReconstruction</span><span class="o">(</span><span class="n">start</span><span class="o">,</span> <span class="mi">5</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Edge</span><span class="o">{</span>
        <span class="kt">int</span> <span class="n">to</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">cost</span><span class="o">;</span>

        <span class="kd">public</span> <span class="nf">Edge</span><span class="o">(</span><span class="kt">int</span> <span class="n">to</span><span class="o">,</span> <span class="kt">int</span> <span class="n">cost</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">to</span> <span class="o">=</span> <span class="n">to</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">cost</span> <span class="o">=</span> <span class="n">cost</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Output:

Shortest path distance : 20
Shortest path : 0 -&gt; 2 -&gt; 4 -&gt; 3 -&gt; 5
</code></pre></div></div>

<h2 id="optimization-techniques">Optimization techniques</h2>

<h3 id="small-label-first-slf-technique"><strong>Small Label First (SLF) technique.</strong></h3>

<p>변 경감(Edge relaxation) 되어진 정점 $v$를 항상 Queue 뒤에 추가하였지만 이 technique에서는 그 추가되어진 정점 $v$의 $d(v)$와 Queue의 맨 앞 정점의 거리 $d(front(Q))$를 비교하고 $d(v)$가 더 작다면 $d(v)$를 Queue의 맨 앞으로 보낸다. 이 technique은 front에 원소 추가를 요구하므로 front와 rear 전부 pop(), offer()연산을 지원하는 Deque(데크) 자료구조를 사용함으로써 구현할 수 있다.</p>

<p>위 SPFA 자바 메소드에서 <code class="highlighter-rouge">Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();</code>를 <code class="highlighter-rouge">Deque&lt;Integer&gt; queue = new LinkedList&lt;&gt;();</code>로 하여 Deque를 사용한다.</p>

<p><strong>다음은 이 technique의 의사코드이다.</strong></p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">procedure</span> <span class="n">Small</span><span class="o">-</span><span class="n">Label</span><span class="o">-</span><span class="n">First</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">Q</span><span class="p">)</span>
     <span class="k">if</span> <span class="n">d</span><span class="p">(</span><span class="n">back</span><span class="p">(</span><span class="n">Q</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">d</span><span class="p">(</span><span class="n">front</span><span class="p">(</span><span class="n">Q</span><span class="p">))</span> <span class="n">then</span>
         <span class="n">u</span> <span class="o">:=</span> <span class="n">pop</span> <span class="n">back</span> <span class="n">of</span> <span class="n">Q</span>
         <span class="n">push</span> <span class="n">u</span> <span class="n">into</span> <span class="n">front</span> <span class="n">of</span> <span class="n">Q</span>
</code></pre></div></div>

<p><strong>다음은 SPFA에 위 최적화를 적용한 코드이다.</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="kt">void</span> <span class="nf">shortestPathFasterAlgorithm</span><span class="o">(</span><span class="kt">int</span> <span class="n">s</span><span class="o">){</span>
    <span class="n">dist</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
    <span class="n">pred</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
    <span class="n">onQueue</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
    <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">dist</span><span class="o">,</span> <span class="no">INF</span><span class="o">);</span>
    <span class="nc">Deque</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
    <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
    <span class="n">dist</span><span class="o">[</span><span class="n">s</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="n">onQueue</span><span class="o">[</span><span class="n">s</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(!</span><span class="n">queue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
        <span class="kt">int</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
        <span class="n">onQueue</span><span class="o">[</span><span class="n">cur</span><span class="o">]</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">Edge</span> <span class="n">e</span> <span class="o">:</span> <span class="n">graph</span><span class="o">[</span><span class="n">cur</span><span class="o">]){</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">dist</span><span class="o">[</span><span class="n">cur</span><span class="o">]</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="na">cost</span> <span class="o">&lt;</span> <span class="n">dist</span><span class="o">[</span><span class="n">e</span><span class="o">.</span><span class="na">to</span><span class="o">]){</span>
                <span class="n">dist</span><span class="o">[</span><span class="n">e</span><span class="o">.</span><span class="na">to</span><span class="o">]</span> <span class="o">=</span> <span class="n">dist</span><span class="o">[</span><span class="n">cur</span><span class="o">]</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="na">cost</span><span class="o">;</span> <span class="c1">// Edge Relaxation</span>
                <span class="n">pred</span><span class="o">[</span><span class="n">e</span><span class="o">.</span><span class="na">to</span><span class="o">]</span> <span class="o">=</span> <span class="n">cur</span><span class="o">;</span> <span class="c1">// store previous node</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">onQueue</span><span class="o">[</span><span class="n">e</span><span class="o">.</span><span class="na">to</span><span class="o">]</span> <span class="o">==</span> <span class="kc">false</span><span class="o">){</span> <span class="c1">// Node(e.to) is not in the queue</span>
                    <span class="n">onQueue</span><span class="o">[</span><span class="n">e</span><span class="o">.</span><span class="na">to</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                    <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">to</span><span class="o">);</span>
                    <span class="c1">// Optimization &lt;Small Label First&gt;</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">dist</span><span class="o">[</span><span class="n">e</span><span class="o">.</span><span class="na">to</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">dist</span><span class="o">[</span><span class="n">queue</span><span class="o">.</span><span class="na">peekFirst</span><span class="o">()]){</span>
                        <span class="n">queue</span><span class="o">.</span><span class="na">offerFirst</span><span class="o">(</span><span class="n">queue</span><span class="o">.</span><span class="na">pollLast</span><span class="o">());</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<hr />

<h3 id="large-label-last-lll-technique"><strong>Large Label Last (LLL) technique.</strong></h3>

<p>Queue의 front 원소의 값이 현재 Queue에 들어있는 모든 정점의 평균보다 작게 하기 위해, Queue에 들어있는 모드 정점 $v$의 평균을 구하고, Queue 앞에서 부터 평균보다 큰 값을 가진 정점 $v$들을 Queue의 맨 뒤로 보내는 연산이다. 평균보다 작은 값을 가진 정점 $v$가 나오면 loop를 빠져나온다.</p>

<p><strong>다음은 이 technique의 의사코드이다.</strong></p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">procedure</span> <span class="n">Large</span><span class="o">-</span><span class="n">Label</span><span class="o">-</span><span class="n">Last</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">Q</span><span class="p">)</span>
     <span class="n">x</span> <span class="o">:=</span> <span class="n">average</span> <span class="n">of</span> <span class="n">d</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">all</span> <span class="n">v</span> <span class="n">in</span> <span class="n">Q</span>
     <span class="k">while</span> <span class="n">d</span><span class="p">(</span><span class="n">front</span><span class="p">(</span><span class="n">Q</span><span class="p">))</span> <span class="o">&gt;</span> <span class="n">x</span>
         <span class="n">u</span> <span class="o">:=</span> <span class="n">pop</span> <span class="n">front</span> <span class="n">of</span> <span class="n">Q</span>
         <span class="n">push</span> <span class="n">u</span> <span class="n">to</span> <span class="n">back</span> <span class="n">of</span> <span class="n">Q</span>
</code></pre></div></div>

<h2 id="running-time">Running time</h2>

<p>The worst-case running time : $O(|V|\cdot|E|)$</p>

<p>SPFA의 최악 실행 시간은 standard Bellman-Ford algorithm과 같은 $O(|V|\cdot|E|)$ 이다.</p>

<p>The average running time : $O(|E|)$</p>

<p>실험으로 보여지는 SPFA의 평균 실행 시간은 $O(|E|)$ 수준이다. 그러나 평균 실행 시간은 아직 증명 되지 않았다.</p>

<h2 id="references">References</h2>

<ul>
  <li><a href="https://en.wikipedia.org/wiki/Shortest_Path_Faster_Algorithm">Wikipedia - SPFA</a></li>
  <li><a href="https://wcipeg.com/wiki/Shortest_path#Relaxation">wcipeg - Shortest path</a></li>
</ul>
:ET