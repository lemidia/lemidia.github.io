I"§¿<h1 id="spfashortest-path-faster-algorithm">SPFA(Shortest Path Faster Algorithm)</h1>

<p>The Shortest Path Faster Algorithm (SPFA)ëŠ” Bellmanâ€“Ford algorithmë¥¼ ê°œì„ í•œ ì•Œê³ ë¦¬ì¦˜ ìœ¼ë¡œì„œ, ë°©í–¥ ê°€ì¤‘ì¹˜ ê·¸ë˜í”„ì—ì„œ ë‹¨ì¼ ì¶œë°œ ì •ì  ìµœë‹¨ ê±°ë¦¬ë¥¼ ê³„ì‚°í•œë‹¤. ì´ SPFAëŠ” ë¬´ì‘ìœ„ í¬ì†Œ ê·¸ë˜í”„ì—ì„œ ì˜ ë™ì‘í•œë‹¤ê³  ì•Œë ¤ì ¸ ìˆê³ , ìŒìˆ˜ ê°€ì¤‘ì¹˜ ê°„ì„ ì„ ê°€ì§„ ê·¸ë˜í”„ì—ì„œë„ ì í•©í•˜ë‹¤. ê·¸ëŸ¬ë‚˜ ìµœì•… ì‹œê°„ë³µì¡ë„ëŠ” Bellmanâ€“Ford algorithmê³¼ ê°™ê¸° ë•Œë¬¸ì—, ìŒìˆ˜ ê°€ì¤‘ì¹˜ ê°„ì„ ì´ ì—†ëŠ” ê·¸ë˜í”„ì˜ ê²½ìš°ì—ëŠ” ìµœì•… ì‹œê°„ë³µì¡ë„ë¥¼ ê³ ë ¤í•œë‹¤ë©´ Dijkstraâ€™s algorithmì´ ë” ì í•©í•˜ë‹¤ê³  ë³¼ ìˆ˜ ìˆë‹¤.</p>

<h2 id="approach---ìˆ˜ì •-ì˜ˆì •">Approach - ìˆ˜ì • ì˜ˆì •</h2>
<p>All the shortest paths algorithms discussed in this article have the same basic approach. At their core, they compute not the shortest paths themselves, but the distances. Using information computed in order to compute the distances, one can easily then reconstruct the paths themselves. They begin with the knowledge that the distance from any vertex to itself is zero, and they overestimate all other distances they need. (By this it is meant that they find a number d_{i,j} for each pair (i,j) under consideration such that the distance from i to j is less than or equal to d_{i,j}.) If (i,j) \in E, then the initial overestimate for the distance from i to j is the weight of the edge (i,j); otherwise it is infinite. At some point, all overestimates will be refined, perhaps gradually, perhaps at once, so that once the algorithm has terminated, they are exactly the correct distances.</p>

<p>Relaxation
There are theoretically many ways to refine overestimates but a specific way, known as relaxation, is used in all the algorithms discussed in this article. Relaxation can take place when three conditions are met:</p>

<p>The currently best overestimate for the distance from some vertex i to some vertex k is d_1;
The currently best overestimate for the distance from k to some vertex j is d_2,
The currently best overestimate for the distance from i to j is greater than d_1+d_2. (This includes the case in which it is infinite.)
Relaxation refines the best overestimate for the distance from i to j by setting it to d_1+d_2, which is better than its current value.</p>

<p>Theorem: When the distances from u to all other vertices are all overestimated, but no relaxations are possible, then those distances are all known correctly. Contrapositively, if at there exists v \in V such that the distance from u to v is not correctly known, then relaxation must be possible somewhere in the graph.</p>

<p>Proof: By induction on the number of edges in some shortest path from u to v (which we can take to be simple). It is vacuously true when this is zero or one, because all paths of length zero or one were accounted for in the initial overestimates. Assume the path has at least two edges, and denote by s the last vertex on the path before v. If the distance from u to s or from s to v is not known, then by the inductive hypothesis, we are done. Otherwise, notice that the path contains two subpaths, one from u to s and one from s to v (the latter is trivial as it consists of a single edge), and that each of these must itself be a shortest path, otherwise we could replace it with a shorter path to obtain a shorter path from u to v, a contradiction. Now, as the distances from u to s and s to v are correctly known, and the correct distance from u to v is exactly the sum of the distances from u to s and s to v (as these values equal the weights of the aforementioned subpaths), and our overestimate of the distance from u to v is incorrect, it must be strictly greater than the sum of the distances from u to s and s to v. Hence (u,v) can be relaxed. _\blacksquare</p>

<h2 id="algorithm">Algorithm</h2>

<p>ë°©í–¥ ê°€ì¤‘ì¹˜ ê·¸ë˜í”„ê°€ ì£¼ì–´ì§€ê³  $G = (V, E)$ ê·¸ë¦¬ê³  ì¶œë°œ ì •ì ì„ $s$ë¼ê³  í•˜ì. SPFAëŠ” ì¶œë°œ ì •ì  $s$ìœ¼ë¡œë¶€í„° ë‹¤ë¥¸ ëª¨ë“  ì •ì  $v$ë¡œì˜ ìµœë‹¨ ê²½ë¡œë¥¼ ì°¾ëŠ”ë‹¤. $s$ë¡œ ë¶€í„° $v$ë¡œì˜ ìµœë‹¨ ê²½ë¡œ ê±°ë¦¬ëŠ” ê° ì •ì  $v$ì— ëŒ€í•˜ì—¬ $d(v)$ì— ì €ì¥ëœë‹¤.</p>

<p>SPFAëŠ” ê° ì •ì ì˜ ì¸ì ‘ ì •ì ì„ í•„ìš”í•˜ë‹¤ë©´ ë³€ ê²½ê°(Edge relaxation)í•˜ê¸° ìœ„í•´ ê° ì •ì ì„ í›„ë³´ìë¡œ ì‚¬ìš©í•œë‹¤.
ì´ ì ì€ Bellmanâ€“Ford algorithmê³¼ ê°™ë‹¤. í•˜ì§€ë§Œ Bellmanâ€“Ford algorithmê³¼ ë¹„êµí–ˆì„ ë•Œì˜ ê°œì„ ì ì€ ëª¨ë“  ì •ì ë“¤ì„ ë¬´ì¡°ê±´ ì ìœ¼ë¡œ ì—°ì‚°ì„ ì‹œë„í•˜ê¸° ë³´ë‹¤ëŠ” SPFAëŠ” í›„ë³´ì ì •ì ì— ëŒ€í•œ Queueë¥¼ ê°€ì§€ê³ , ì–´ë–¤ ì •ì ì— ëŒ€í•´ ê·¸ ì •ì ì´ ë³€ ê²½ê° ì—°ì‚°ì´ ì´ë£¨ì–´ì¡Œì„ ë•Œë§Œ í›„ë³´ì ì •ì ìœ¼ë¡œì„œ Queueì— ì‚½ì…ì„ í•œë‹¤. ì´ëŸ° í–‰ë™ë“¤ì€ ë³€ ê²½ê° ì—°ì‚°ì´ ì‹¤í–‰ë  ì •ì ì´ ì—†ì„ ë•Œê¹Œì§€ ë°˜ë³µëœë‹¤.</p>

<hr />

<p><strong>ë‹¤ìŒì€ SPFAì˜ ì˜ì‚¬ì½”ë“œì´ë‹¤.</strong></p>

<p>$Q$ëŠ” ë³€ ê²½ê° ì—°ì‚°ì´ ë˜ê³  ë‚œ í›„ì˜ í›„ë³´ìë¥¼ ë‹´ì„ Queueë¥¼ ì˜ë¯¸í•œë‹¤.<br />
$w(u,v)$ëŠ” ê°„ì„  $(u,v)$ì˜ ê°„ì„  ê°€ì¤‘ì¹˜ë¥¼ ì˜ë¯¸í•œë‹¤.</p>

<p>Q ì•ˆì— vì˜ ì¡´ì¬ ìœ ë¬´ë¥¼ íŒë‹¨í•˜ê¸° ìœ„í•´ ì¶”ê°€ì ì¸ ë°°ì—´ì´ í•„ìš”í•˜ë‹¤. (ì´ ì˜ì‚¬ì½”ë“œì—ëŠ” ì—†ë‹¤.)</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="mi">0</span> <span class="n">procedure</span> <span class="n">Shortest</span><span class="o">-</span><span class="n">Path</span><span class="o">-</span><span class="n">Faster</span><span class="o">-</span><span class="n">Algorithm</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
 <span class="mi">1</span>    <span class="k">for</span> <span class="n">each</span> <span class="n">vertex</span> <span class="n">v</span> <span class="err">â‰ </span> <span class="n">s</span> <span class="n">in</span> <span class="n">V</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
 <span class="mi">2</span>        <span class="n">d</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">:=</span> <span class="err">âˆ</span>
 <span class="mi">3</span>    <span class="n">d</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">:=</span> <span class="mi">0</span>
 <span class="mi">4</span>    <span class="n">offer</span> <span class="n">s</span> <span class="n">into</span> <span class="n">Q</span>
 <span class="mi">5</span>    <span class="k">while</span> <span class="n">Q</span> <span class="n">is</span> <span class="n">not</span> <span class="n">empty</span>
 <span class="mi">6</span>        <span class="n">u</span> <span class="o">:=</span> <span class="n">poll</span> <span class="n">Q</span>
 <span class="mi">7</span>        <span class="k">for</span> <span class="n">each</span> <span class="n">edge</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="n">in</span> <span class="n">E</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
 <span class="mi">8</span>            <span class="k">if</span> <span class="n">d</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">+</span> <span class="n">w</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">d</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="n">then</span>
 <span class="mi">9</span>                <span class="n">d</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">:=</span> <span class="n">d</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">+</span> <span class="n">w</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
<span class="mi">10</span>                <span class="k">if</span> <span class="n">v</span> <span class="n">is</span> <span class="n">not</span> <span class="n">in</span> <span class="n">Q</span> <span class="n">then</span>
<span class="mi">11</span>                    <span class="n">offer</span> <span class="n">v</span> <span class="n">into</span> <span class="n">Q</span>
</code></pre></div></div>

<p>í•œ êµ¬ë¬¸ì”© ë³´ì.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">1</span>    <span class="k">for</span> <span class="n">each</span> <span class="n">vertex</span> <span class="n">v</span> <span class="err">â‰ </span> <span class="n">s</span> <span class="n">in</span> <span class="n">V</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="mi">2</span>        <span class="n">d</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">:=</span> <span class="err">âˆ</span>
</code></pre></div></div>
<p>ê·¸ë˜í”„ Gì˜ ì¶œë°œ ì •ì  së¥¼ ì œì™¸í•œ ëª¨ë“  ì •ì  vì— ëŒ€í•˜ì—¬ së¡œë¶€í„° ê° vì— ëŒ€í•œ ìµœë‹¨ê²½ë¡œ ê±°ë¦¬ d(v)ë¥¼ INFë¡œ ì´ˆê¸°í™” í•œë‹¤.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="mi">3</span>    <span class="n">d</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">:=</span> <span class="mi">0</span>
 <span class="mi">4</span>    <span class="n">offer</span> <span class="n">s</span> <span class="n">into</span> <span class="n">Q</span>
</code></pre></div></div>

<p>ë¨¼ì € ì¶œë°œ ì •ì  sì˜ ìµœë‹¨ê²½ë¡œ ê±°ë¦¬ë¥¼ 0ìœ¼ë¡œ ì´ˆê¸°í™”í•˜ê³  së¥¼ Qì— ë„£ëŠ”ë‹¤.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">5</span>    <span class="k">while</span> <span class="n">Q</span> <span class="n">is</span> <span class="n">not</span> <span class="n">empty</span>
</code></pre></div></div>

<p>íê°€ ë¹Œ ë•Œ ê¹Œì§€ ì•„ë˜ ì—°ì‚°ë“¤ì„ ë°˜ë³µí•œë‹¤.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">6</span>    <span class="n">u</span> <span class="o">:=</span> <span class="n">poll</span> <span class="n">Q</span>
<span class="mi">7</span>    <span class="k">for</span> <span class="n">each</span> <span class="n">edge</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="n">in</span> <span class="n">E</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</code></pre></div></div>

<p>Qì—ì„œ ì •ì í•˜ë‚˜ë¥¼ êº¼ë‚´ uë¼ í•˜ê³ , ê·¸ë˜í”„ Gì—ì„œ uì™€ ì¸ì ‘í•œ ì •ì  vì™€ì˜ ê°„ì„  (u, v)ì— ëŒ€í•˜ì—¬</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">8</span>    <span class="k">if</span> <span class="n">d</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">+</span> <span class="n">w</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">d</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="n">then</span>
<span class="mi">9</span>       <span class="n">d</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">:=</span> <span class="n">d</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">+</span> <span class="n">w</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
</code></pre></div></div>
<p>së¡œë¶€í„° uë¡œì˜ ìµœë‹¨ê²½ë¡œ ê±°ë¦¬ d(u) + ê°„ì„  (u, v)ì˜ ê°’ì´ së¡œë¶€í„° vë¡œì˜ ìµœë‹¨ê²½ë¡œ ê±°ë¦¬ d(v)ë³´ë‹¤ ì‘ë‹¤ë©´ d(v)ê°’ì„ d(u) + w(u, v)ë¡œ ì—…ë°ì´íŠ¸ í•œë‹¤. (Edge Relaxation)</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">10</span>      <span class="k">if</span> <span class="n">v</span> <span class="n">is</span> <span class="n">not</span> <span class="n">in</span> <span class="n">Q</span> <span class="n">then</span>
<span class="mi">11</span>          <span class="n">offer</span> <span class="n">v</span> <span class="n">into</span> <span class="n">Q</span>
</code></pre></div></div>
<p>ë³€ ê²½ê° ì—°ì‚°(Edge Relaxation)ì´ ëœ ì •ì  vê°€ í˜„ì¬ Qì— ì—†ìœ¼ë©´, vë¥¼ Qì— ì¶”ê°€í•œë‹¤.</p>

<h2 id="step-by-step">Step by step</h2>

<p>ì˜ˆë¥¼ ë“¤ì–´ SPFAê°€ ì–´ë–»ê²Œ ë™ì‘í•˜ëŠ”ì§€ ì•Œì•„ë³¸ë‹¤.</p>

<p>ì˜ˆì œ ê·¸ë˜í”„ëŠ” ë‹¤ìŒê³¼ ê°™ë‹¤.</p>

<p>0ë²ˆì„ ì‹œì‘ ì •ì ìœ¼ë¡œ í•˜ì—¬ 5ë²ˆ ì •ì ìœ¼ë¡œì˜ ìµœë‹¨ ê²½ë¡œë¥¼ êµ¬í•œë‹¤.</p>

<p>í•´ë‹¹ ì •ì ì— ì—°ê²°ëœ ì¸ì ‘ ì •ì ì´ ì—¬ëŸ¬ê°œ ì¼ ë•, ë²ˆí˜¸ê°€ ì‘ì€ ê²ƒì„ ë¨¼ì € ì„ íƒí•œë‹¤.</p>

<p><img src="/assets/images/SPFA-0.png" alt="Alt text" width="400px" height="300px" class="align-center" /></p>

<p>ì‹œì‘ ì •ì ìœ¼ë¡œ ë¶€í„° ëª¨ë“  ì •ì ê¹Œì§€ì˜ ìµœë‹¨ê±°ë¦¬ d(v)ë¥¼ ë¬´í•œëŒ€(INF)ë¡œ ì´ˆê¸°í™” í•œë‹¤.<br />
d(s)ëŠ” 0ìœ¼ë¡œ ì´ˆê¸°í™” í•œë‹¤.</p>

<p>Queueì— ì‹œì‘ ì •ì  0ì„ ë„£ëŠ”ë‹¤.<br />
<code class="highlighter-rouge">Queue : [0]</code></p>

<p><img src="/assets/images/SPFA-1.png" alt="Alt text" width="400px" height="300px" class="align-center" /></p>

<p>Queueì—ì„œ ì›ì†Œ í•˜ë‚˜ë¥¼ popí•œë‹¤.<br />
0ë²ˆ ì •ì ê³¼ ì¸ì ‘í•œ ì •ì  1ë²ˆì— ëŒ€í•˜ì—¬ <code class="highlighter-rouge">d(0) + w(0, 1) &lt; d(1): 0 + 4 &lt; INF</code>ì´ë¯€ë¡œ 
d(1)ì„ 4ë¡œ ì—…ë°ì´íŠ¸ í•œë‹¤.</p>

<p>ì—…ë°ì´íŠ¸ ë˜ì—ˆìœ¼ë¯€ë¡œ 1ë²ˆ ì •ì ì„ Queueì— ë„£ëŠ”ë‹¤.<br />
<code class="highlighter-rouge">Queue : [1]</code></p>

<p><img src="/assets/images/SPFA-2.png" alt="Alt text" width="400px" height="300px" class="align-center" /></p>

<p>0ë²ˆ ì •ì ê³¼ ì¸ì ‘í•œ ì •ì  2ë²ˆì— ëŒ€í•˜ì—¬ <code class="highlighter-rouge">d(0) + w(0, 2) &lt; d(1): 0 + 2 &lt; INF</code>ì´ë¯€ë¡œ 
d(2)ì„ 2ë¡œ ì—…ë°ì´íŠ¸ í•œë‹¤.</p>

<p>ì—…ë°ì´íŠ¸ ë˜ì—ˆìœ¼ë¯€ë¡œ 2ë²ˆ ì •ì ì„ Queueì— ë„£ëŠ”ë‹¤.<br />
<code class="highlighter-rouge">Queue : [1 2]</code></p>

<p><img src="/assets/images/SPFA-3.png" alt="Alt text" width="400px" height="300px" class="align-center" /></p>

<p>Queueì—ì„œ ì›ì†Œ í•˜ë‚˜ë¥¼ popí•œë‹¤.<br />
1ë²ˆ ì •ì ê³¼ ì¸ì ‘í•œ ì •ì  2ë²ˆì— ëŒ€í•˜ì—¬ <code class="highlighter-rouge">d(1) + w(1, 2) &lt; d(2): 4 + 5 &gt; 2</code>ì´ë¯€ë¡œ 
d(2)ë¥¼ ì—…ë°ì´íŠ¸ í•˜ì§€ ì•ŠëŠ”ë‹¤.</p>

<p><code class="highlighter-rouge">Queue : [2]</code></p>

<p><img src="/assets/images/SPFA-4.png" alt="Alt text" width="400px" height="300px" class="align-center" /></p>

<p>1ë²ˆ ì •ì ê³¼ ì¸ì ‘í•œ ì •ì  3ë²ˆì— ëŒ€í•˜ì—¬ <code class="highlighter-rouge">d(1) + w(1, 3) &lt; d(3): 4 + 10 &lt; INF</code>ì´ë¯€ë¡œ 
d(3)ì„ 14ë¡œ ì—…ë°ì´íŠ¸ í•œë‹¤.</p>

<p>ì—…ë°ì´íŠ¸ ë˜ì—ˆìœ¼ë¯€ë¡œ 3ë²ˆ ì •ì ì„ Queueì— ë„£ëŠ”ë‹¤.<br />
<code class="highlighter-rouge">Queue : [2, 3]</code></p>

<p><img src="/assets/images/SPFA-5.png" alt="Alt text" width="400px" height="300px" class="align-center" /></p>

<p>Queueì—ì„œ ì›ì†Œ í•˜ë‚˜ë¥¼ popí•œë‹¤.<br />
2ë²ˆ ì •ì ê³¼ ì¸ì ‘í•œ ì •ì  4ë²ˆì— ëŒ€í•˜ì—¬ <code class="highlighter-rouge">d(2) + w(2, 4) &lt; d(4): 2 + 3 &lt; INF</code>ì´ë¯€ë¡œ 
d(4)ì„ 5ë¡œ ì—…ë°ì´íŠ¸ í•œë‹¤.</p>

<p>ì—…ë°ì´íŠ¸ ë˜ì—ˆìœ¼ë¯€ë¡œ 4ë²ˆ ì •ì ì„ Queueì— ë„£ëŠ”ë‹¤.<br />
<code class="highlighter-rouge">Queue : [3, 4]</code></p>

<p><img src="/assets/images/SPFA-6.png" alt="Alt text" width="400px" height="300px" class="align-center" /></p>

<p>Queueì—ì„œ ì›ì†Œ í•˜ë‚˜ë¥¼ popí•œë‹¤.<br />
3ë²ˆ ì •ì ê³¼ ì¸ì ‘í•œ ì •ì  5ë²ˆì— ëŒ€í•˜ì—¬ <code class="highlighter-rouge">d(3) + w(3, 5) &lt; d(5): 14 + 11 &lt; INF</code>ì´ë¯€ë¡œ 
d(5)ì„ 25ë¡œ ì—…ë°ì´íŠ¸ í•œë‹¤.</p>

<p>ì—…ë°ì´íŠ¸ ë˜ì—ˆìœ¼ë¯€ë¡œ 5ë²ˆ ì •ì ì„ Queueì— ë„£ëŠ”ë‹¤.<br />
<code class="highlighter-rouge">Queue : [4, 5]</code></p>

<p><img src="/assets/images/SPFA-6-1.png" alt="Alt text" width="400px" height="300px" class="align-center" /></p>

<p>Queueì—ì„œ ì›ì†Œ í•˜ë‚˜ë¥¼ popí•œë‹¤.<br />
4ë²ˆ ì •ì ê³¼ ì¸ì ‘í•œ ì •ì  3ë²ˆì— ëŒ€í•˜ì—¬ <code class="highlighter-rouge">d(4) + w(4, 3) &lt; d(3): 5 + 4 &lt; 14</code>ì´ë¯€ë¡œ 
d(3)ì„ 9ë¡œ ì—…ë°ì´íŠ¸ í•œë‹¤.</p>

<p>ì—…ë°ì´íŠ¸ ë˜ì—ˆìœ¼ë¯€ë¡œ 3ë²ˆ ì •ì ì„ Queueì— ë„£ëŠ”ë‹¤.<br />
<code class="highlighter-rouge">Queue : [5, 3]</code></p>

<p><img src="/assets/images/SPFA-7.png" alt="Alt text" width="400px" height="300px" class="align-center" /></p>

<p>Queueì—ì„œ ì›ì†Œ í•˜ë‚˜ë¥¼ popí•œë‹¤.<br />
5ë²ˆ ì •ì ê³¼ ì¸ì ‘í•œ ì •ì ì´ ì—†ë‹¤.</p>

<p><code class="highlighter-rouge">Queue : [3]</code></p>

<p><img src="/assets/images/SPFA-8.png" alt="Alt text" width="400px" height="300px" class="align-center" /></p>

<p>Queueì—ì„œ ì›ì†Œ í•˜ë‚˜ë¥¼ popí•œë‹¤.<br />
3ë²ˆ ì •ì ê³¼ ì¸ì ‘í•œ ì •ì  5ë²ˆì— ëŒ€í•˜ì—¬ <code class="highlighter-rouge">d(3) + w(3, 5) &lt; d(5): 9 + 11 &lt; 25</code>ì´ë¯€ë¡œ 
d(5)ì„ 20ë¡œ ì—…ë°ì´íŠ¸ í•œë‹¤.</p>

<p>ì—…ë°ì´íŠ¸ ë˜ì—ˆìœ¼ë¯€ë¡œ 5ë²ˆ ì •ì ì„ Queueì— ë„£ëŠ”ë‹¤.<br />
<code class="highlighter-rouge">Queue : [5]</code></p>

<p><img src="/assets/images/SPFA-9.png" alt="Alt text" width="400px" height="300px" class="align-center" /></p>

<p>Queueì—ì„œ ì›ì†Œ í•˜ë‚˜ë¥¼ popí•œë‹¤.<br />
5ë²ˆ ì •ì ê³¼ ì¸ì ‘í•œ ì •ì ì´ ì—†ë‹¤.</p>

<p><code class="highlighter-rouge">Queue : [ ]</code></p>

<p><img src="/assets/images/SPFA-10.png" alt="Alt text" width="400px" height="300px" class="align-center" /></p>

<p>íê°€ ë¹„ì—ˆìœ¼ë¯€ë¡œ SPFAê°€ ì™„ë£Œë˜ì—ˆë‹¤.</p>

<p>0ë²ˆ ë¶€í„° 5ë²ˆìœ¼ë¡œì˜ ìµœë‹¨ê²½ë¡œëŠ” <strong>ë¹¨ê°„ì„ </strong>ì„ ë”°ë¼ê°„ ê²½ë¡œì´ê³  ê·¸ ê±°ë¦¬ëŠ” <strong>20</strong>ì´ë‹¤.</p>

<p><img src="/assets/images/SPFA-11.png" alt="Alt text" width="400px" height="300px" class="align-center" /></p>

<h2 id="implementation">Implementation</h2>

<p>ë‹¤ìŒì€ ìœ„ ì˜ì‚¬ì½”ë“œë¥¼ ë°”íƒ•ìœ¼ë¡œ SPFAë¥¼ êµ¬í˜„í•œ ìë°” ë©”ì†Œë“œì´ë‹¤.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="kt">void</span> <span class="nf">shortestPathFasterAlgorithm</span><span class="o">(</span><span class="kt">int</span> <span class="n">s</span><span class="o">){</span>
    <span class="n">dist</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
    <span class="n">onQueue</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
    <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">dist</span><span class="o">,</span> <span class="no">INF</span><span class="o">);</span>
    <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
    <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
    <span class="n">dist</span><span class="o">[</span><span class="n">s</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="n">onQueue</span><span class="o">[</span><span class="n">s</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(!</span><span class="n">queue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
        <span class="kt">int</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
        <span class="n">onQueue</span><span class="o">[</span><span class="n">cur</span><span class="o">]</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">Edge</span> <span class="n">e</span> <span class="o">:</span> <span class="n">graph</span><span class="o">[</span><span class="n">cur</span><span class="o">]){</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">dist</span><span class="o">[</span><span class="n">cur</span><span class="o">]</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="na">cost</span> <span class="o">&lt;</span> <span class="n">dist</span><span class="o">[</span><span class="n">e</span><span class="o">.</span><span class="na">to</span><span class="o">]){</span>
                <span class="n">dist</span><span class="o">[</span><span class="n">e</span><span class="o">.</span><span class="na">to</span><span class="o">]</span> <span class="o">=</span> <span class="n">dist</span><span class="o">[</span><span class="n">cur</span><span class="o">]</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="na">cost</span><span class="o">;</span> <span class="c1">// Edge Relaxation</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>í˜„ì¬ Queueì—ì„œ ì •ì  $v$ì˜ ì¡´ì¬ ìœ ë¬´ë¥¼ ì¶”ì í•˜ê¸° ìœ„í•´ ìœ„ ì½”ë“œì—ì„œëŠ” <code class="highlighter-rouge">onQueue[]</code> ë¥¼ ì‚¬ìš©í•œë‹¤.</p>

<p>ê·¸ë˜í”„ì˜ ê°€ì¤‘ì¹˜ ê°„ì„  ì •ë³´ë¥¼ êµ¬ì„±í•˜ê¸° ìœ„í•´ ì•„ë˜ì˜ Edge í´ë˜ìŠ¤ë¥¼ ì‚¬ìš©í•œë‹¤.</p>

<p><code class="highlighter-rouge">to</code>ëŠ” ë‹¤ìŒ ì¸ì ‘ ì •ì ì˜ ë²ˆí˜¸, costëŠ” ê°„ì„  ë¹„ìš©(ê°€ì¤‘ì¹˜)ë¥¼ ë‚˜íƒ€ë‚¸ë‹¤.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="kd">class</span> <span class="nc">Edge</span><span class="o">{</span>
        <span class="kt">int</span> <span class="n">to</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">cost</span><span class="o">;</span>

        <span class="kd">public</span> <span class="nf">Edge</span><span class="o">(</span><span class="kt">int</span> <span class="n">to</span><span class="o">,</span> <span class="kt">int</span> <span class="n">cost</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">to</span> <span class="o">=</span> <span class="n">to</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">cost</span> <span class="o">=</span> <span class="n">cost</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
</code></pre></div></div>
<p>ë‹¤ìŒì€ SPFAë¥¼ êµ¬í˜„í•œ ìë°” ì½”ë“œì´ë‹¤.</p>

<p>ê·¸ë˜í”„ì˜ ì…ë ¥ì€ ì˜ˆì œ ê·¸ë˜í”„ë¥¼ ì‚¬ìš©í•˜ì˜€ê³ , ìµœë‹¨ê²½ë¡œë¥¼ ì¶”ì í•˜ê³  êµ¬ì„±í•˜ê¸° ìœ„í•´ pred[]ë°°ì—´ì„ ì„ ì–¸í•œ ë’¤ SPFAì˜ ì‹¤í–‰ ì¤‘ì— ì–´ëŠ í•œ í¬ì¸íŠ¸ì—ì„œ ì •ì  u, vê°€ ìˆê³ (ì •ì  vê°€ uì— ì˜í•´ relaxation ë˜ì–´ì§€ëŠ” ì •ì ), relaxation ë˜ì–´ì§„ ì •ì  vê°€ ìˆìœ¼ë©´, ê·¸ ì •ì ì„ relaxationí•˜ê²Œ ë§Œë“  ì •ì  uê°€ ìµœë‹¨ê²½ë¡œ ìƒì˜ ì´ì „ ë…¸ë“œ ì´ë¯€ë¡œ <code class="highlighter-rouge">pred[e.to] = cur;</code>ë¥¼ í•˜ì—¬ ê²½ë¡œë¥¼ êµ¬ì¶•í•œë‹¤. ê·¸ ë‹¤ìŒ <code class="highlighter-rouge">printPathReconstruction</code>í•¨ìˆ˜ë¡œ ê²½ë¡œë¥¼ ì¶œë ¥í•œë‹¤.</p>

<p>ì´ í”„ë¡œê·¸ë¨ì€ ìµœë‹¨ê²½ë¡œ ê±°ë¦¬ì™€ ê·¸ ê²½ë¡œë¥¼ ì¶œë ¥í•œë‹¤.</p>

<ul>
  <li>Input: Graph G, start vertex</li>
  <li>Output: Distance of shortest path of Graph G, shortest path of Graph G</li>
</ul>

<p>ì‹œì‘ ì •ì ì€ 0ë²ˆì´ë‹¤.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.LinkedList</span><span class="o">;</span>

<span class="cm">/**
 * This program is to find Shortest path in weighted graph using SPFA.
 * Time Complexity : Worst case : O(VE) same as Standard Bellman ford
 *                   Average case : O(E) - not proved
 *
 * @author Lemidia(Gyeong)
 */</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ShortestPathFasterAlgorithm</span><span class="o">{</span>

     <span class="c1">// the number of vertices in Graph G</span>
    <span class="kd">static</span> <span class="kt">int</span> <span class="n">n</span><span class="o">;</span>
    <span class="c1">// Shortest distance from s to each vertex v</span>
    <span class="kd">static</span> <span class="kt">int</span> <span class="n">dist</span><span class="o">[];</span>
    <span class="c1">// for construct shortest path</span>
    <span class="kd">static</span> <span class="kt">int</span> <span class="n">pred</span><span class="o">[];</span>
    <span class="kd">static</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Edge</span><span class="o">&gt;</span> <span class="o">[]</span> <span class="n">graph</span><span class="o">;</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">INF</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
    <span class="c1">// For check whether the vertex is on queue or not</span>
    <span class="kd">static</span> <span class="kt">boolean</span> <span class="n">onQueue</span><span class="o">[];</span>


    <span class="c1">// Init Graph G</span>
    <span class="kd">static</span> <span class="kt">void</span> <span class="nf">createGraph</span><span class="o">(){</span>
        <span class="n">graph</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
            <span class="n">graph</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// Add weighted direct edges.</span>
    <span class="kd">static</span> <span class="kt">void</span> <span class="nf">addEdge</span><span class="o">(</span><span class="kt">int</span> <span class="n">from</span><span class="o">,</span> <span class="kt">int</span> <span class="n">to</span><span class="o">,</span> <span class="kt">int</span> <span class="n">cost</span><span class="o">){</span>
        <span class="nc">Edge</span> <span class="n">e</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Edge</span><span class="o">(</span><span class="n">to</span><span class="o">,</span> <span class="n">cost</span><span class="o">);</span>
        <span class="n">graph</span><span class="o">[</span><span class="n">from</span><span class="o">].</span><span class="na">add</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">static</span> <span class="kt">void</span> <span class="nf">shortestPathFasterAlgorithm</span><span class="o">(</span><span class="kt">int</span> <span class="n">s</span><span class="o">){</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="n">pred</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="n">onQueue</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">dist</span><span class="o">,</span> <span class="no">INF</span><span class="o">);</span>
        <span class="nc">Deque</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
        <span class="n">dist</span><span class="o">[</span><span class="n">s</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="n">onQueue</span><span class="o">[</span><span class="n">s</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(!</span><span class="n">queue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
            <span class="kt">int</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
            <span class="n">onQueue</span><span class="o">[</span><span class="n">cur</span><span class="o">]</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
            <span class="k">for</span> <span class="o">(</span><span class="nc">Edge</span> <span class="n">e</span> <span class="o">:</span> <span class="n">graph</span><span class="o">[</span><span class="n">cur</span><span class="o">]){</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">dist</span><span class="o">[</span><span class="n">cur</span><span class="o">]</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="na">cost</span> <span class="o">&lt;</span> <span class="n">dist</span><span class="o">[</span><span class="n">e</span><span class="o">.</span><span class="na">to</span><span class="o">]){</span>
                    <span class="n">dist</span><span class="o">[</span><span class="n">e</span><span class="o">.</span><span class="na">to</span><span class="o">]</span> <span class="o">=</span> <span class="n">dist</span><span class="o">[</span><span class="n">cur</span><span class="o">]</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="na">cost</span><span class="o">;</span> <span class="c1">// Edge Relaxation</span>
                    <span class="n">pred</span><span class="o">[</span><span class="n">e</span><span class="o">.</span><span class="na">to</span><span class="o">]</span> <span class="o">=</span> <span class="n">cur</span><span class="o">;</span> <span class="c1">// store previous node</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">onQueue</span><span class="o">[</span><span class="n">e</span><span class="o">.</span><span class="na">to</span><span class="o">]</span> <span class="o">==</span> <span class="kc">false</span><span class="o">){</span> <span class="c1">// Node(e.to) is not in the queue</span>
                        <span class="n">onQueue</span><span class="o">[</span><span class="n">e</span><span class="o">.</span><span class="na">to</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                        <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">to</span><span class="o">);</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">static</span> <span class="kt">void</span> <span class="nf">printPathReconstruction</span><span class="o">(</span><span class="kt">int</span> <span class="n">start</span><span class="o">,</span> <span class="kt">int</span> <span class="n">end</span><span class="o">){</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">end</span> <span class="o">==</span> <span class="n">start</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">start</span><span class="o">);</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">pathReconstruction</span><span class="o">(</span><span class="n">start</span><span class="o">,</span> <span class="n">pred</span><span class="o">[</span><span class="n">end</span><span class="o">]);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">" -&gt; "</span> <span class="o">+</span> <span class="n">end</span> <span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>

        <span class="n">n</span> <span class="o">=</span> <span class="mi">6</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="n">createGraph</span><span class="o">();</span>
        <span class="n">addEdge</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">);</span>
        <span class="n">addEdge</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">);</span>
        <span class="n">addEdge</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">5</span><span class="o">);</span>
        <span class="n">addEdge</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">10</span><span class="o">);</span>
        <span class="n">addEdge</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">3</span><span class="o">);</span>
        <span class="n">addEdge</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">11</span><span class="o">);</span>
        <span class="n">addEdge</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">);</span>

        <span class="n">shortestPathFasterAlgorithm</span><span class="o">(</span><span class="n">start</span><span class="o">);</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Shortest path distance : "</span> <span class="o">+</span> <span class="n">dist</span><span class="o">[</span><span class="mi">5</span><span class="o">]);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"Shortest path : "</span><span class="o">);</span>
        <span class="n">printPathReconstruction</span><span class="o">(</span><span class="n">start</span><span class="o">,</span> <span class="mi">5</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Edge</span><span class="o">{</span>
        <span class="kt">int</span> <span class="n">to</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">cost</span><span class="o">;</span>

        <span class="kd">public</span> <span class="nf">Edge</span><span class="o">(</span><span class="kt">int</span> <span class="n">to</span><span class="o">,</span> <span class="kt">int</span> <span class="n">cost</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">to</span> <span class="o">=</span> <span class="n">to</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">cost</span> <span class="o">=</span> <span class="n">cost</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Output:

Shortest path distance : 20
Shortest path : 0 -&gt; 2 -&gt; 4 -&gt; 3 -&gt; 5
</code></pre></div></div>

<h2 id="optimization-techniques">Optimization techniques</h2>

<p><strong>Small Label First (SLF) technique.</strong></p>

<p>ë³€ ê²½ê°(Edge relaxation) ë˜ì–´ì§„ ì •ì  $v$ë¥¼ í•­ìƒ Queue ë’¤ì— ì¶”ê°€í•˜ì˜€ì§€ë§Œ ì´ techniqueì—ì„œëŠ” ê·¸ ì¶”ê°€ë˜ì–´ì§„ ì •ì  $v$ì˜ $d(v)$ì™€ Queueì˜ ë§¨ ì• ì •ì ì˜ ê±°ë¦¬ $d(front(Q))$ë¥¼ ë¹„êµí•˜ê³  $d(v)$ê°€ ë” ì‘ë‹¤ë©´ $d(v)$ë¥¼ Queueì˜ ë§¨ ì•ìœ¼ë¡œ ë³´ë‚¸ë‹¤. ì´ techniqueì€ frontì— ì›ì†Œ ì¶”ê°€ë¥¼ ìš”êµ¬í•˜ë¯€ë¡œ frontì™€ rear ì „ë¶€ pop(), offer()ì—°ì‚°ì„ ì§€ì›í•˜ëŠ” Deque(ë°í¬) ìë£Œêµ¬ì¡°ë¥¼ ì‚¬ìš©í•¨ìœ¼ë¡œì¨ êµ¬í˜„í•  ìˆ˜ ìˆë‹¤.</p>

<p><strong>ë‹¤ìŒì€ ì´ techniqueì˜ ì˜ì‚¬ì½”ë“œì´ë‹¤.</strong></p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">procedure</span> <span class="n">Small</span><span class="o">-</span><span class="n">Label</span><span class="o">-</span><span class="n">First</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">Q</span><span class="p">)</span>
     <span class="k">if</span> <span class="n">d</span><span class="p">(</span><span class="n">back</span><span class="p">(</span><span class="n">Q</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">d</span><span class="p">(</span><span class="n">front</span><span class="p">(</span><span class="n">Q</span><span class="p">))</span> <span class="n">then</span>
         <span class="n">u</span> <span class="o">:=</span> <span class="n">pop</span> <span class="n">back</span> <span class="n">of</span> <span class="n">Q</span>
         <span class="n">push</span> <span class="n">u</span> <span class="n">into</span> <span class="n">front</span> <span class="n">of</span> <span class="n">Q</span>
</code></pre></div></div>
<hr />

<p><strong>ë‹¤ìŒì€ SPFAì— ìœ„ ìµœì í™”ë¥¼ ì ìš©í•œ ì½”ë“œì´ë‹¤.</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="kt">void</span> <span class="nf">shortestPathFasterAlgorithm</span><span class="o">(</span><span class="kt">int</span> <span class="n">s</span><span class="o">){</span>
    <span class="n">dist</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
    <span class="n">pred</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
    <span class="n">onQueue</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
    <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">dist</span><span class="o">,</span> <span class="no">INF</span><span class="o">);</span>
    <span class="nc">Deque</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
    <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
    <span class="n">dist</span><span class="o">[</span><span class="n">s</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="n">onQueue</span><span class="o">[</span><span class="n">s</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(!</span><span class="n">queue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
        <span class="kt">int</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
        <span class="n">onQueue</span><span class="o">[</span><span class="n">cur</span><span class="o">]</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">Edge</span> <span class="n">e</span> <span class="o">:</span> <span class="n">graph</span><span class="o">[</span><span class="n">cur</span><span class="o">]){</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">dist</span><span class="o">[</span><span class="n">cur</span><span class="o">]</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="na">cost</span> <span class="o">&lt;</span> <span class="n">dist</span><span class="o">[</span><span class="n">e</span><span class="o">.</span><span class="na">to</span><span class="o">]){</span>
                <span class="n">dist</span><span class="o">[</span><span class="n">e</span><span class="o">.</span><span class="na">to</span><span class="o">]</span> <span class="o">=</span> <span class="n">dist</span><span class="o">[</span><span class="n">cur</span><span class="o">]</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="na">cost</span><span class="o">;</span> <span class="c1">// Edge Relaxation</span>
                <span class="n">pred</span><span class="o">[</span><span class="n">e</span><span class="o">.</span><span class="na">to</span><span class="o">]</span> <span class="o">=</span> <span class="n">cur</span><span class="o">;</span> <span class="c1">// store previous node</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">onQueue</span><span class="o">[</span><span class="n">e</span><span class="o">.</span><span class="na">to</span><span class="o">]</span> <span class="o">==</span> <span class="kc">false</span><span class="o">){</span> <span class="c1">// Node(e.to) is not in the queue</span>
                    <span class="n">onQueue</span><span class="o">[</span><span class="n">e</span><span class="o">.</span><span class="na">to</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                    <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">to</span><span class="o">);</span>
                    <span class="c1">// Optimization &lt;Small Label First&gt;</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">dist</span><span class="o">[</span><span class="n">e</span><span class="o">.</span><span class="na">to</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">dist</span><span class="o">[</span><span class="n">queue</span><span class="o">.</span><span class="na">peekFirst</span><span class="o">()]){</span>
                        <span class="n">queue</span><span class="o">.</span><span class="na">offerFirst</span><span class="o">(</span><span class="n">queue</span><span class="o">.</span><span class="na">pollLast</span><span class="o">());</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<hr />

<p><strong>Large Label Last (LLL) technique.</strong></p>

<p>Queueì˜ front ì›ì†Œì˜ ê°’ì´ í˜„ì¬ Queueì— ë“¤ì–´ìˆëŠ” ëª¨ë“  ì •ì ì˜ í‰ê· ë³´ë‹¤ ì‘ê²Œ í•˜ê¸° ìœ„í•´, Queueì— ë“¤ì–´ìˆëŠ” ëª¨ë“œ ì •ì  $v$ì˜ í‰ê· ì„ êµ¬í•˜ê³ , Queue ì•ì—ì„œ ë¶€í„° í‰ê· ë³´ë‹¤ í° ê°’ì„ ê°€ì§„ ì •ì  $v$ë“¤ì„ Queueì˜ ë§¨ ë’¤ë¡œ ë³´ë‚´ëŠ” ì—°ì‚°ì´ë‹¤. í‰ê· ë³´ë‹¤ ì‘ì€ ê°’ì„ ê°€ì§„ ì •ì  $v$ê°€ ë‚˜ì˜¤ë©´ loopë¥¼ ë¹ ì ¸ë‚˜ì˜¨ë‹¤.</p>

<p><strong>ë‹¤ìŒì€ ì´ techniqueì˜ ì˜ì‚¬ì½”ë“œì´ë‹¤.</strong></p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">procedure</span> <span class="n">Large</span><span class="o">-</span><span class="n">Label</span><span class="o">-</span><span class="n">Last</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">Q</span><span class="p">)</span>
     <span class="n">x</span> <span class="o">:=</span> <span class="n">average</span> <span class="n">of</span> <span class="n">d</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">all</span> <span class="n">v</span> <span class="n">in</span> <span class="n">Q</span>
     <span class="k">while</span> <span class="n">d</span><span class="p">(</span><span class="n">front</span><span class="p">(</span><span class="n">Q</span><span class="p">))</span> <span class="o">&gt;</span> <span class="n">x</span>
         <span class="n">u</span> <span class="o">:=</span> <span class="n">pop</span> <span class="n">front</span> <span class="n">of</span> <span class="n">Q</span>
         <span class="n">push</span> <span class="n">u</span> <span class="n">to</span> <span class="n">back</span> <span class="n">of</span> <span class="n">Q</span>
</code></pre></div></div>

<h2 id="running-time">Running time</h2>

<p>The worst-case running time : $O(|V|\cdot|E|)$</p>

<p>SPFAì˜ ìµœì•… ì‹¤í–‰ ì‹œê°„ì€ standard Bellman-Ford algorithmê³¼ ê°™ì€ $O(|V|\cdot|E|)$ ì´ë‹¤.</p>

<p>The average running time : $O(|E|)$</p>

<p>ì‹¤í—˜ìœ¼ë¡œ ë³´ì—¬ì§€ëŠ” SPFAì˜ í‰ê·  ì‹¤í–‰ ì‹œê°„ì€ $O(|E|)$ ìˆ˜ì¤€ì´ë‹¤. ê·¸ëŸ¬ë‚˜ í‰ê·  ì‹¤í–‰ ì‹œê°„ì€ ì•„ì§ ì¦ëª… ë˜ì§€ ì•Šì•˜ë‹¤.</p>

<h2 id="references">References</h2>

<ul>
  <li><a href="https://en.wikipedia.org/wiki/Shortest_Path_Faster_Algorithm">Wikipedia - SPFA</a></li>
  <li><a href="https://wcipeg.com/wiki/Shortest_path#Relaxation">wcipeg - Shortest path</a></li>
</ul>
:ET