I"<h1 id="카운팅-소트counting-sort">카운팅 소트(Counting sort)</h1>

<p>계수 정렬이라고도 하며, <strong>점근적 복잡도 O(n+k)</strong>를 가지는 선형 정렬 알고리즘이다.</p>

<ul>
  <li><strong>n: 정렬될 입력 배열의 원소 개수.</strong></li>
  <li><strong>k: 정렬될 입력 배열의 가장 큰 키 값.</strong></li>
</ul>

<p>이 정렬 알고리즘은 <strong>특정한 조건하에 매우 효율적</strong>이며 같은 키값을 가진 원소에 대해 <strong>안정적</strong>이다. 버블소트와 머지소트와는 다르게, 이 알고리즘은 <strong>비교기반 정렬</strong>이 아니므로 원소 간에 비교를 하지 않고, <strong>리스트의 O(1)의 삽입 및 조회 연산</strong>을 사용해 동작한다.</p>

<p>카운팅 소트는 정수의 특정 범위 사이에서 동작하며, 특정 키 값의 개체의 수를 세아려 이 정보를 보조 배열에 기록한다. 이 정보와 산술계산을 사용하여 각 키 값을 정렬될 결과 리스트의 특정 위치에 배치시킨다.</p>

<p>이 정렬 알고리즘은 정렬될 수의 범위가 정렬될 원소의 개수보다 심하게 크지 않을 때 적합하다.<br />
그리고, 실행시간은 <strong>$O$(가장 큰 키 값 - 가장 작은 키 값)</strong>이 되므로 정렬될 수의 범위 또는 가장 큰 키 값(K)가 크지 않을 때 적합하다. 그렇지 않으면 보다 비효율적이다.</p>

<p>카운팅 소트는 <strong>안정 정렬</strong>에 속하고 <strong>제자리 정렬</strong>이 아니다. 이는 특정 원소의 키 값 개수를 추적할 추가적인 <strong>$O(K)$공간</strong>을 요구한게 된다.</p>

<p><strong>안정 정렬과 제자리 정렬 이란?</strong></p>

<p class="notice--warning"><strong>안정 정렬:</strong> 정렬되기 전에 같은 키 값을 가진 원소들의 <strong>상대적인 위치나 순서</strong>는 정렬이 끝나도 변하지 않고 <strong>그대로 유지</strong>되는 것을 의미.<br />
안정 정렬 알고리즘으로는 <strong>삽입 정렬, 머지소트, 카운팅 소트</strong> 등이 있다.</p>
<p class="notice--primary"><strong>제자리 정렬:</strong> 원소들의 개수에 비해서 충분히 무시할 만한 저장 공간만을 더 사용하는 정렬 알고리즘들을 의미.<br />
예를 들어 <strong>삽입 정렬</strong>은 이미 주어진 원소들을 옮긴 뒤 적절한 위치에 원소를 삽입하는 연산을 반복하는데, 이 과정에서 원소들을 담는 공간 외에 추가로 사용될 수 있는 공간은 옮겨지는 <strong>원소가 저장되는 공간과 루프 변수</strong> 정도에 불과하다.</p>

<p>카운팅 소트에 제약사항으로는 <strong>정수 같은 이산적인(Discrete)값들</strong>만 정렬 할 수 있고, 입력된 배열을 정렬하기 전에 <strong>가장 큰 값 K</strong>(범위)를 <strong>사전에 알고 있어야</strong> 한다.</p>

<h2 id="의사-코드">의사 코드</h2>

<p>다음은 카운팅 소트의 의사 코드이다.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">CountingSort</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="c1">// params A : 입력 배열, k : 가장 큰 키 값</span>
  <span class="c1">// 특정 키 값의 원소 개수를 추적할 C[], 결과 배열 B[]를 준비한다.</span>
  <span class="n">C</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">B</span><span class="p">[</span><span class="n">A</span><span class="p">.</span><span class="n">length</span><span class="p">]</span>
  <span class="c1">// C[]를 0으로 전부 초기화 한다.</span>
  <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="n">to</span> <span class="n">k</span> <span class="k">do</span> 
  <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="c1">//Storing Count of each element</span>
  <span class="c1">//Complexity: O(n)</span>
  <span class="k">for</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span> <span class="n">to</span> <span class="n">n</span> <span class="k">do</span>
  <span class="n">c</span><span class="p">[</span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="c1">// Change C[i] such that it contains actual</span>
  <span class="c1">//position of these elements in output array</span>
  <span class="c1">////Complexity: O(k)</span>
  <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span> <span class="n">to</span> <span class="n">k</span> <span class="k">do</span>
  <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
  <span class="c1">//Build Output array from C[i]</span>
  <span class="c1">//Complexity: O(n)</span>
  <span class="k">for</span> <span class="n">j</span> <span class="o">=</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span> <span class="n">downto</span> <span class="mi">0</span> <span class="k">do</span>
  <span class="n">B</span><span class="p">[</span> <span class="n">c</span><span class="p">[</span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span><span class="o">-</span><span class="mi">1</span> <span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
  <span class="n">c</span><span class="p">[</span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">-</span> <span class="mi">1</span>
<span class="n">end</span> <span class="n">func</span>
</code></pre></div></div>

<h2 id="카운팅-소트---예제">카운팅 소트 - 예제</h2>

<p><strong>예제로 카운팅 소트 알고리즘을 이해해 본다.</strong></p>

<p>먼저 정렬 될 입력 배열이다.</p>

<p><img src="/assets/images/Counting-Sort-1.png" alt="Alt" /></p>

<p>그 다음 특정 키 값의 원소 개수를 저장할 배열 Count[] 그리고 정렬 결과를 저장할 배열 Result[]를 준비한다.</p>

<p>입력 배열을 순회하면서 Count[]에 원소의 특정 키 값을 인덱스로 하여 개수를 기록한다.</p>

<p><img src="/assets/images/Counting-Sort-2.png" alt="Alt" /></p>

<p>Result[]에 저장될 특정 키 값의 실제 위치를 표현하기 위해 Count[]의 Prefix sum을 구한다.</p>

<p>다시 입력 배열을 순회하면서</p>

:ET