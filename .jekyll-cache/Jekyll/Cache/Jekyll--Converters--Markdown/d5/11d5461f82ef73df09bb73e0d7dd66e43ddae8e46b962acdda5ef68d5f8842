I"1<h2 id="비선형구조의-탐색">비선형구조의 탐색</h2>

<p>비선형구조란 i번째 원소를 탐색한 다음 그 원소와 연결된 다른 원소를 탐색하려고 할 때, 여러 개의 원소가 존재하는 탐색구조를 말한다.<br />
 일반적으로 자료가 트리나 그래프로 구성되어 있을 경우를 비선형구조라 하고 이러한 트리나 그래프의 모든 정점을 탐색하는 것을 비선형 탐색이라고 이해하면 된다.</p>

<p>비선형구조는 선형과 달리 자료가 순차적으로 구성되어 있지 않으므로 단순히 반복문을 이용하여 탐색하기에는 어려움이 있다. 그러므로 비선형구조는 스택이나 큐와 같은 자료구 조를 활용하여 탐색하는 것이 일반적이다.</p>

<p>비선형구조의 탐색은 크게 <strong>깊이우선탐색(depth first search, dfs)과 너비우선탐색 (breadth firth search, bfs)</strong>으로 나눌 수 있으며, 이 두 가지 탐색법에 대해서 알아본다.</p>

<h3 id="비선형구조">비선형구조</h3>

<p>비선형구조의 탐색을 다루기 전에 그래프와 트리에 대해서 간단히 알아보자.<br />
트리와 그래프를 이루는 기본 요소를 정점(vertex)과 간선(edge)이라고 한다.</p>

<p><img src="/assets/images/creativealgorithm1.png" alt="Alt text" width="500px" height="300px" /></p>

<p>원은 정점, 선분은 간선을 나타내며, a-b는 보통간선, a-&gt;b는 방향간선, b-d는 가중치가 15인 양방향통행 간선, d-&gt;e는 가중치가 7인 일방통행 간선(방향간선)을 나타낸다.<br />
정점은 점 또는 원으로 표현하며, 일반적으로 상태나 위치를 표현한다. 간선은 정점들을 연결하는 선으로 표현하며, 정점들 간의 관계를 표현한다.</p>

<h3 id="경로path와-회로cycle">경로(path)와 회로(cycle)</h3>

<p>그래프에서 임의의 정점 s에서 임의의 정점 t로 이동할 때, s에서 t로 이동하는데 사용한 정점들을 연결하고 있는 간선들의 순서로 된 집합을 경로라고 한다. 회로는 그래프에서 임 의의 정점 s에서 같은 정점 s로의 경로들을 말한다.</p>

<p><img src="/assets/images/creativealgorithm2.png" alt="Alt text" width="500px" height="300px" /></p>

<p class="notice--warning"><strong>Note:</strong> 7개의 원소가 들어있는 배열에 재귀적 병합 정렬을 적용했을 때 우리가 상상할 수 있는 그림입니다.<br />
배열의 원소가 1개가 될 때까지 원래 배열의 1/2씩 분할을 계속 진행합니다.<br />
배열의 원소가 1개가 되면 병합을 진행합니다.<br />
[38][27]<br />
38은 27보다 크므로 두 원소가 스왑되어 합병됩니다.<br />
[43][3]<br />
43은 3보다 크므로 두 원소가 스왑되어 합병됩니다.<br />
[27, 38] [3, 43]<br />
27과 3이 스왑되고 38과 43은 그대로 배열에 들어갑니다.<br />
이와 마찬가지로 다른 분할 배열들도 위와 같이 진행됩니다.</p>

<h2 id="java로-구현---재귀적top-down-recursive">Java로 구현 - 재귀적(Top-down, Recursive)</h2>
<p class="notice--warning"><strong>설명</strong>: 재귀적으로 서브배열의 크기가 1이 될 때까지 계속 분할을 진행합니다.<br />
분할된 배열들을 정렬하고 합병합니다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// @author lemidia</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MergeSort</span> <span class="o">{</span>
    <span class="kd">static</span> <span class="kt">void</span> <span class="nf">divide</span><span class="o">(</span><span class="kt">int</span> <span class="n">data</span><span class="o">[],</span> <span class="kt">int</span> <span class="n">p</span><span class="o">,</span> <span class="kt">int</span> <span class="n">r</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">p</span> <span class="o">&lt;</span> <span class="n">r</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">q</span> <span class="o">=</span> <span class="o">(</span><span class="n">p</span><span class="o">+</span><span class="n">r</span><span class="o">)/</span><span class="mi">2</span><span class="o">;</span> <span class="c1">// Middle</span>
            <span class="n">divide</span><span class="o">(</span><span class="n">data</span><span class="o">,</span> <span class="n">p</span><span class="o">,</span> <span class="n">q</span><span class="o">);</span> <span class="c1">// Left</span>
            <span class="n">divide</span><span class="o">(</span><span class="n">data</span><span class="o">,</span> <span class="n">q</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">r</span><span class="o">);</span> <span class="c1">// Right</span>
            <span class="n">merge</span><span class="o">(</span><span class="n">data</span><span class="o">,</span> <span class="n">p</span><span class="o">,</span> <span class="n">q</span><span class="o">,</span> <span class="n">r</span><span class="o">);</span> <span class="c1">// Merge</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">static</span> <span class="kt">void</span> <span class="nf">merge</span><span class="o">(</span><span class="kt">int</span> <span class="n">data</span><span class="o">[],</span> <span class="kt">int</span> <span class="n">p</span><span class="o">,</span> <span class="kt">int</span> <span class="n">q</span><span class="o">,</span> <span class="kt">int</span> <span class="n">r</span><span class="o">){</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span> <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">q</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span> <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">temp</span><span class="o">[]</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">data</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="n">r</span><span class="o">+</span><span class="mi">1</span> <span class="o">;</span> <span class="n">l</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">q</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">j</span> <span class="o">&gt;</span> <span class="n">r</span> <span class="o">||</span> <span class="n">data</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">data</span><span class="o">[</span><span class="n">j</span><span class="o">])){</span>
                <span class="n">temp</span><span class="o">[</span><span class="n">k</span><span class="o">++]</span> <span class="o">=</span> <span class="n">data</span><span class="o">[</span><span class="n">i</span><span class="o">++];</span>
            <span class="o">}</span><span class="k">else</span>
                <span class="n">temp</span><span class="o">[</span><span class="n">k</span><span class="o">++]</span> <span class="o">=</span> <span class="n">data</span><span class="o">[</span><span class="n">j</span><span class="o">++];</span>
        <span class="o">}</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span> <span class="n">l</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="o">;</span> <span class="n">l</span><span class="o">++){</span>
            <span class="n">data</span><span class="o">[</span><span class="n">l</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">[</span><span class="n">l</span><span class="o">];</span>
        <span class="o">}</span>

        <span class="cm">/*
        while (i&lt;=q &amp;&amp; j&lt;=r){
            if(data[i] &lt;= data[j]){
                temp[k++] = data[i++];
            }else{
                temp[k++] = data[j++];
            }
        }
        while (i&lt;=q)
            temp[k++] = data[i++];
        while (j&lt;=r)
            temp[k++] = data[j++];
        for(int l = p; l&lt;=r; l++){
            data[l] = temp[l];
        }
        */</span>

    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">limit</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">arr</span><span class="o">[]</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">limit</span><span class="o">];</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">limit</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="o">--</span><span class="n">i</span><span class="o">){</span>
            <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">limit</span><span class="o">-</span><span class="n">i</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">divide</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">limit</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="s">" "</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span> <span class="mi">10</span> 
</code></pre></div></div>

<h2 id="시간복잡도">시간복잡도</h2>
<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>최악 시간복잡도	O(n log n)
최선 시간복잡도	O(n log n)
평균 시간복잡도	일반적으로, O(n log n)
</code></pre></div></div>
<p class="notice--warning"><strong>쉬운 설명</strong>: 배열의 원소가 n개일 때 깊이는 log(n)만큼 진행 됩니다. (매번 2개씩 분할 되므로)<br />
각 깊이마다 n개의 원소들이 제자리를 찾아 스왑됩니다.<br />
그래서 시간복잡도는 깊이 * n개의 원소 즉, <strong>nlog(n)</strong>이 됩니다.</p>

<h2 id="references">References</h2>

<p><a href="https://en.wikipedia.org/wiki/Merge_sort">Merge Sort - wikipedia</a></p>
:ET