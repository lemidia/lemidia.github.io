I"ө<h1 id="linked-list">Linked List</h1>
<p>배열과 같이 선형 자료구조 이다.<br />
원소들이 메모리 공간상에 연속적으로 저장 되어있지 않고, 그림과 같이 각 원소들이 포인터로 링크되어 있는 자료 구조이다.</p>

<p>하나의 원소를 노드라고 표현하고, 데이터를 저장하는 Data 필드와 그 다음 노드를 가리키는 Next필드로 구성되어 있다.</p>

<p>추가적으로 연결 리스트의 맨 처음 노드를 가리키는 헤드라는 포인터를 두고 있다.</p>

<p>그림을 참고하자.</p>

<p><img src="/assets/images/Linkedlist1.png" alt="Alt text" width="600px" height="100px" class="align-center" /></p>

<h2 id="배열과-비교해-연결-리스트가-가지는-장점">배열과 비교해 연결 리스트가 가지는 장점</h2>

<p>베열은 유사한 타입의 선형 데이터를 저장하는데 사용될 수 있다.<br />
하지만 배열은 다음과 같은 제한을 가진다.</p>

<ol>
  <li>배열 크기가 고정되어 있다.<br />
그래서 우리는 배열의 상한크기를 미리 알고 있어야 한다.<br />
또한, 일반적으로, 할당된 메모리는 사용량에 관계없이 상한과 동일하다.</li>
  <li>배열에 원소를 삽입하는 연산은 연결 리스트와 비교해 다소 비용이 많이든다.<br />
원소를 저장할 공간이 만들어져야 하며, 특정 위치에 값을 삽입한다면 다른 원소를 한칸 씩 쉬프트 해야할 수도 있다.</li>
</ol>

<p><strong>연결 리스트가 배열과 비교해 가지는 장점</strong></p>

<ol>
  <li>동적 크기<br />
연결 리스트의 크기는 고정되어 있지 않고, 프로그램 실행중에 동적으로 변할 수 있다.<br />
운영체제가 프로그램상의 메모리 공간을 허용하는 한 연결 리스트의 크기를 신경 쓸 필요가 없다.</li>
  <li>원소의 삽입 및 삭제가 수월하다.<br />
배열과 비교해 연결 리스트의 삽입 삭제는 노드들 간에 포인터만 설정해주면 된다.<br />
새로운 원소를 위해 다른 원소를 위치를 쉬프트 한다든지의 수고를 할 필요가 없다.</li>
</ol>

<h2 id="배열과-비교해-연결-리스트가-가지는-단점">배열과 비교해 연결 리스트가 가지는 단점</h2>

<ol>
  <li>
    <p>임의 접근이 되지 않는다.<br />
배열은 각 원소를 index 번호로 바로 접근할 수 있는 반면(Random access), 연결 리스트에서는 처음 노드부터 순차적으로 탐색해야 한다.</p>
  </li>
  <li>
    <p>포인터로 인한 메모리상 추가적인 공간이 필요하다.<br />
배열과 달리 연결 리스트는 다른 노드를 가리키는 포인터(Next)공간을 추가로 요구한다.</p>
  </li>
  <li>
    <p>캐시 친화적이지 않다.<br />
배열 요소는 연속된 메모리 공간상에 위치하므로 참조 지역성이 좋은 반면, 연결 리스트는 요소들이 링크되어 있고 메모리 상에 흩어져 존재하므로 참조 지역성이 없다.</p>
  </li>
</ol>

<h2 id="representation">Representation</h2>

<p>연결 리스트는 첫번째 노드를 가리키는 헤드를 가지고 있다.<br />
연결 리스트에 노드가 없다면 헤드는 NULL이다.</p>

<p><img src="/assets/images/Linkedlist1-1.png" alt="Alt text" width="150px" height="100px" class="align-center" /></p>

<p>노드는 두개의 부분으로 구성되어 있다.</p>

<ol>
  <li>Data - 데이터를 저장하는 필드(Integer, Double, String, Object …)</li>
  <li>Next(Pointer Or Reference) - 다음 노드를 참조하는 필드</li>
</ol>

<p>다음은 자바로 구현한 연결 리스트 클래스이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">LinkedList</span> <span class="o">{</span> 
    <span class="nc">Node</span> <span class="n">head</span><span class="o">;</span> <span class="c1">// head of the list </span>
  
    <span class="cm">/* Linked list Node*/</span>
    <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Node</span> <span class="o">{</span> 
        <span class="kt">int</span> <span class="n">data</span><span class="o">;</span> 
        <span class="nc">Node</span> <span class="n">next</span><span class="o">;</span> 
        <span class="nc">Node</span><span class="o">(</span><span class="kt">int</span> <span class="n">d</span><span class="o">)</span> 
        <span class="o">{</span> 
            <span class="n">data</span> <span class="o">=</span> <span class="n">d</span><span class="o">;</span> 
            <span class="n">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> 
        <span class="o">}</span> <span class="c1">// Constructor </span>
    <span class="o">}</span> 
<span class="o">}</span>
</code></pre></div></div>

<p>연결 리스트는 하나의 클래스로 표현되고 있고, 노드는 그 안의 분리된 클래스로 표현되고 있다.</p>

<p>연결 리스트 클래스의 헤드는 노드를 참조하므로 노드 클래스 타입으로 선언 되어있다.</p>

<p>노드 클래스는 데이터를 저장하는 data필드와 다음 노드를 참조할 수 있는 next필드를 가지고 있다.
또한 생성자를 가지고 있는데, 이는 노드가 생성될 때 데이터를 d로 초기화하고, 포인터를 null로 초기화하는 역할을 한다.</p>

<hr />

<p>위 클래스를 이용하여 노드 3개를 가진 연결리스트를 자바로 구현해 보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// A simple Java program to introduce a linked list </span>
<span class="kd">class</span> <span class="nc">LinkedList</span> <span class="o">{</span> 
    <span class="nc">Node</span> <span class="n">head</span><span class="o">;</span> <span class="c1">// head of list </span>
  
    <span class="cm">/* Linked list Node.  This inner class is made static so that 
       main() can access it */</span>
    <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Node</span> <span class="o">{</span> 
        <span class="kt">int</span> <span class="n">data</span><span class="o">;</span> 
        <span class="nc">Node</span> <span class="n">next</span><span class="o">;</span> 
        <span class="nc">Node</span><span class="o">(</span><span class="kt">int</span> <span class="n">d</span><span class="o">)</span> 
        <span class="o">{</span> 
            <span class="n">data</span> <span class="o">=</span> <span class="n">d</span><span class="o">;</span> 
            <span class="n">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> 
        <span class="o">}</span> <span class="c1">// Constructor </span>
    <span class="o">}</span> 
  
    <span class="cm">/* method to create a simple linked list with 3 nodes*/</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> 
    <span class="o">{</span> 
        <span class="cm">/* 빈 연결 리스트 생성 */</span>
        <span class="nc">LinkedList</span> <span class="n">llist</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">();</span> 
  
        <span class="n">llist</span><span class="o">.</span><span class="na">head</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span> 
        <span class="nc">Node</span> <span class="n">second</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span> 
        <span class="nc">Node</span> <span class="n">third</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span> 
  
        <span class="cm">/* 3개의 노드가 메모리상에 할당된다. 
          head와 second, third가 각 노드를 참조한다.
  
          llist.head        second              third 
             |                |                  | 
             |                |                  | 
         +----+------+     +----+------+     +----+------+ 
         | 1  | null |     | 2  | null |     |  3 | null | 
         +----+------+     +----+------+     +----+------+ */</span>
  
        <span class="n">llist</span><span class="o">.</span><span class="na">head</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">second</span><span class="o">;</span> <span class="c1">// 첫번째 노드와 두번째 노드를 연결한다.</span>
  
        <span class="cm">/*  첫번째 노드의 next가 두번째 노드를 참조한다.
  
         llist.head        second              third 
            |                |                  | 
            |                |                  | 
        +----+------+     +----+------+     +----+------+ 
        | 1  |  o--------&gt;| 2  | null |     |  3 | null | 
        +----+------+     +----+------+     +----+------+ */</span>
  
        <span class="n">second</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">third</span><span class="o">;</span> <span class="c1">// 세번째 노드와 두번째 노드를 연결한다.</span>
  
        <span class="cm">/*  두번째 노드의 next가 세번째 노드를 참조한다.
  
         llist.head        second              third 
            |                |                  | 
            |                |                  | 
        +----+------+     +----+------+     +----+------+ 
        | 1  |  o--------&gt;| 2  |  o--------&gt;|  3 | null | 
        +----+------+     +----+------+     +----+------+ */</span>
    <span class="o">}</span> 
<span class="o">}</span> 
</code></pre></div></div>

<h2 id="inserting-a-node">Inserting a node</h2>

<p>연결 리스트에 노드를 추가 해보자.</p>

<p>노드를 추가하는 데에는 3 가지 케이스가 있다.</p>

<ol>
  <li>연결 리스트 맨 앞에 추가</li>
  <li>특정 노드 뒤에 추가</li>
  <li>연결 리스트 맨 뒤에 추가</li>
</ol>

<h3 id="연결-리스트-맨-앞에-추가">연결 리스트 맨 앞에 추가</h3>

<ol>
  <li>추가할 노드를 할당한다.</li>
  <li>노드에 데이터를 넣는다.</li>
  <li>추가할 노드의 next 포인터가 첫번째 노드를 참조하게 한다.</li>
  <li>헤드가 추가한 노드를 참조하게 함으로써 처음 노드임을 가리킨다.</li>
</ol>

<p><img src="/assets/images/Linkedlist2.png" alt="Alt text" width="600px" height="100px" class="align-center" /></p>

<p>다음은 위의 연산을 구현한 자바 메소드이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* This function is in LinkedList class. Inserts a 
   new Node at front of the list. */</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">push</span><span class="o">(</span><span class="kt">int</span> <span class="n">new_data</span><span class="o">)</span> 
<span class="o">{</span> 
    <span class="cm">/* 1 &amp; 2: Allocate the Node &amp; 
              Put in the data*/</span>
    <span class="nc">Node</span> <span class="n">new_node</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="n">new_data</span><span class="o">);</span> 
  
    <span class="cm">/* 3. Make next of new Node as head */</span>
    <span class="n">new_node</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span> 
  
    <span class="cm">/* 4. Move the head to point to new Node */</span>
    <span class="n">head</span> <span class="o">=</span> <span class="n">new_node</span><span class="o">;</span> 
<span class="o">}</span> 
</code></pre></div></div>

<p>이 연산의 시간복잡도는 O(1)이 된다.</p>

<h3 id="특정-노드-뒤에-추가">특정 노드 뒤에 추가</h3>

<ol>
  <li>특정 노드가 null인지 확인한다.<br />
null이면 아무런 작업이 수행되지 않는다.</li>
  <li>추가할 노드를 할당한다.</li>
  <li>추가할 노드에 데이터를 넣는다.</li>
  <li>추가할 노드가 특정노드가 참조하는 다음 노드를 참조하게 한다.</li>
  <li>특정 노드가 추가할 노드를 참조하게 한다.</li>
</ol>

<p><img src="/assets/images/Linkedlist3.png" alt="Alt text" width="600px" height="100px" class="align-center" /></p>

<p>다음은 위의 연산을 구현한 자바 메소드이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* This function is in LinkedList class. 
   Inserts a new node after the given prev_node. */</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">insertAfter</span><span class="o">(</span><span class="nc">Node</span> <span class="n">prev_node</span><span class="o">,</span> <span class="kt">int</span> <span class="n">new_data</span><span class="o">)</span> 
<span class="o">{</span> 
    <span class="cm">/* 1. Check if the given Node is null */</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">prev_node</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> 
    <span class="o">{</span> 
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"The given previous node cannot be null"</span><span class="o">);</span> 
        <span class="k">return</span><span class="o">;</span> 
    <span class="o">}</span> 
  
    <span class="cm">/* 2. Allocate the Node &amp; 
       3. Put in the data*/</span>
    <span class="nc">Node</span> <span class="n">new_node</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="n">new_data</span><span class="o">);</span> 
  
    <span class="cm">/* 4. Make next of new Node as next of prev_node */</span>
    <span class="n">new_node</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">prev_node</span><span class="o">.</span><span class="na">next</span><span class="o">;</span> 
  
    <span class="cm">/* 5. make next of prev_node as new_node */</span>
    <span class="n">prev_node</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">new_node</span><span class="o">;</span> 
<span class="o">}</span> 
</code></pre></div></div>

<p>이 연산의 시간복잡도는 O(1)이 된다.</p>

<h3 id="연결-리스트-맨-뒤에-추가">연결 리스트 맨 뒤에 추가</h3>

<ol>
  <li>추가할 노드를 할당한다.</li>
  <li>추가할 노드에 데이터를 넣는다.</li>
  <li>연결 리스트가 null이면, 헤드가 추가할 노드를 참조하게 함으로써 연산을 끝낸다.</li>
  <li>그렇지 않다면, 처음 노드부터 탐색을 시작하여 마지막 노드를 찾는다.</li>
  <li>마지막 노드가 추가할 노드를 참조하게 한다.</li>
</ol>

<p><img src="/assets/images/Linkedlist4.png" alt="Alt text" width="600px" height="300px" /></p>

<p>다음은 위의 연산을 구현한 자바 메소드이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1">// Appends a new node at the end. </span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">append</span><span class="o">(</span><span class="kt">int</span> <span class="n">new_data</span><span class="o">)</span> 
<span class="o">{</span> 
    <span class="cm">/* 1. Allocate the Node &amp; 
       2. Put in the data */</span>
    <span class="nc">Node</span> <span class="n">new_node</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="n">new_data</span><span class="o">);</span> 
  
    <span class="cm">/* 3. If the Linked List is empty, then make the 
           new node as head */</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> 
    <span class="o">{</span> 
        <span class="n">head</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="n">new_data</span><span class="o">);</span> 
        <span class="k">return</span><span class="o">;</span> 
    <span class="o">}</span> 
    <span class="cm">/* 4. Else traverse till the last node */</span>
    <span class="nc">Node</span> <span class="n">last</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>  
    <span class="k">while</span> <span class="o">(</span><span class="n">last</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> 
        <span class="n">last</span> <span class="o">=</span> <span class="n">last</span><span class="o">.</span><span class="na">next</span><span class="o">;</span> 
  
    <span class="cm">/* 5. Change the next of last node */</span>
    <span class="n">last</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">new_node</span><span class="o">;</span> 
    <span class="k">return</span><span class="o">;</span> 
<span class="o">}</span> 
</code></pre></div></div>

<p>이 연산의 시간복잡도는 탐색으로 인하여 O(n)이 된다.<br />
연결 리스트의 끝 노드의 정보를 가지고 있는 tail 포인터를 둔다면, 이 연산의 시간복잡도는 O(1)이 된다.</p>

<p>다음은 위 연산을 포한한 예제 자바 코드이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// A complete working Java program to demonstrate all insertion methods </span>
<span class="c1">// on linked list </span>
<span class="kd">class</span> <span class="nc">LinkedList</span> 
<span class="o">{</span> 
    <span class="nc">Node</span> <span class="n">head</span><span class="o">;</span>  <span class="c1">// head of list </span>
  
    <span class="cm">/* Linked list Node*/</span>
    <span class="kd">class</span> <span class="nc">Node</span> 
    <span class="o">{</span> 
        <span class="kt">int</span> <span class="n">data</span><span class="o">;</span> 
        <span class="nc">Node</span> <span class="n">next</span><span class="o">;</span> 
        <span class="nc">Node</span><span class="o">(</span><span class="kt">int</span> <span class="n">d</span><span class="o">)</span> <span class="o">{</span><span class="n">data</span> <span class="o">=</span> <span class="n">d</span><span class="o">;</span> <span class="n">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> <span class="o">}</span> 
    <span class="o">}</span> 
  
    <span class="cm">/* Inserts a new Node at front of the list. */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">push</span><span class="o">(</span><span class="kt">int</span> <span class="n">new_data</span><span class="o">)</span> 
    <span class="o">{</span> 
        <span class="cm">/* 1 &amp; 2: Allocate the Node &amp; 
                  Put in the data*/</span>
        <span class="nc">Node</span> <span class="n">new_node</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="n">new_data</span><span class="o">);</span> 
  
        <span class="cm">/* 3. Make next of new Node as head */</span>
        <span class="n">new_node</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span> 
  
        <span class="cm">/* 4. Move the head to point to new Node */</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">new_node</span><span class="o">;</span> 
    <span class="o">}</span> 
  
    <span class="cm">/* Inserts a new node after the given prev_node. */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">insertAfter</span><span class="o">(</span><span class="nc">Node</span> <span class="n">prev_node</span><span class="o">,</span> <span class="kt">int</span> <span class="n">new_data</span><span class="o">)</span> 
    <span class="o">{</span> 
        <span class="cm">/* 1. Check if the given Node is null */</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">prev_node</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> 
        <span class="o">{</span> 
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"The given previous node cannot be null"</span><span class="o">);</span> 
            <span class="k">return</span><span class="o">;</span> 
        <span class="o">}</span> 
  
        <span class="cm">/* 2 &amp; 3: Allocate the Node &amp; 
                  Put in the data*/</span>
        <span class="nc">Node</span> <span class="n">new_node</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="n">new_data</span><span class="o">);</span> 
  
        <span class="cm">/* 4. Make next of new Node as next of prev_node */</span>
        <span class="n">new_node</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">prev_node</span><span class="o">.</span><span class="na">next</span><span class="o">;</span> 
  
        <span class="cm">/* 5. make next of prev_node as new_node */</span>
        <span class="n">prev_node</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">new_node</span><span class="o">;</span> 
    <span class="o">}</span> 
     
    <span class="cm">/* Appends a new node at the end.  This method is  
       defined inside LinkedList class shown above */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">append</span><span class="o">(</span><span class="kt">int</span> <span class="n">new_data</span><span class="o">)</span> 
    <span class="o">{</span> 
        <span class="cm">/* 1. Allocate the Node &amp; 
           2. Put in the data */</span>
        <span class="nc">Node</span> <span class="n">new_node</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="n">new_data</span><span class="o">);</span> 
  
        <span class="cm">/* 3. If the Linked List is empty, then make the 
              new node as head */</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> 
        <span class="o">{</span> 
            <span class="n">head</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="n">new_data</span><span class="o">);</span> 
            <span class="k">return</span><span class="o">;</span> 
        <span class="o">}</span> 
  
        <span class="cm">/* 4. Else traverse till the last node */</span>
        <span class="nc">Node</span> <span class="n">last</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>  
        <span class="k">while</span> <span class="o">(</span><span class="n">last</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> 
            <span class="n">last</span> <span class="o">=</span> <span class="n">last</span><span class="o">.</span><span class="na">next</span><span class="o">;</span> 
  
        <span class="cm">/* 5. Change the next of last node */</span>
        <span class="n">last</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">new_node</span><span class="o">;</span> 
        <span class="k">return</span><span class="o">;</span> 
    <span class="o">}</span> 
  
    <span class="cm">/* This function prints contents of linked list starting from 
        the given node */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">printList</span><span class="o">()</span> 
    <span class="o">{</span> 
        <span class="nc">Node</span> <span class="n">tnode</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span> 
        <span class="k">while</span> <span class="o">(</span><span class="n">tnode</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> 
        <span class="o">{</span> 
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">tnode</span><span class="o">.</span><span class="na">data</span><span class="o">+</span><span class="s">" "</span><span class="o">);</span> 
            <span class="n">tnode</span> <span class="o">=</span> <span class="n">tnode</span><span class="o">.</span><span class="na">next</span><span class="o">;</span> 
        <span class="o">}</span> 
    <span class="o">}</span> 
  
    <span class="cm">/* Driver program to test above functions. Ideally this function 
       should be in a separate user class.  It is kept here to keep 
       code compact */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> 
    <span class="o">{</span> 
        <span class="cm">/* Start with the empty list */</span>
        <span class="nc">LinkedList</span> <span class="n">llist</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">();</span> 
  
        <span class="c1">// Insert 6.  So linked list becomes 6-&gt;NUllist </span>
        <span class="n">llist</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="mi">6</span><span class="o">);</span> 
  
        <span class="c1">// Insert 7 at the beginning. So linked list becomes </span>
        <span class="c1">// 7-&gt;6-&gt;NUllist </span>
        <span class="n">llist</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="mi">7</span><span class="o">);</span> 
  
        <span class="c1">// Insert 1 at the beginning. So linked list becomes </span>
        <span class="c1">// 1-&gt;7-&gt;6-&gt;NUllist </span>
        <span class="n">llist</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span> 
  
        <span class="c1">// Insert 4 at the end. So linked list becomes </span>
        <span class="c1">// 1-&gt;7-&gt;6-&gt;4-&gt;NUllist </span>
        <span class="n">llist</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="mi">4</span><span class="o">);</span> 
  
        <span class="c1">// Insert 8, after 7. So linked list becomes </span>
        <span class="c1">// 1-&gt;7-&gt;8-&gt;6-&gt;4-&gt;NUllist </span>
        <span class="n">llist</span><span class="o">.</span><span class="na">insertAfter</span><span class="o">(</span><span class="n">llist</span><span class="o">.</span><span class="na">head</span><span class="o">.</span><span class="na">next</span><span class="o">,</span> <span class="mi">8</span><span class="o">);</span> 
  
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"\nCreated Linked list is: "</span><span class="o">);</span> 
        <span class="n">llist</span><span class="o">.</span><span class="na">printList</span><span class="o">();</span> 
    <span class="o">}</span> 
<span class="o">}</span> 
<span class="c1">// This code is contributed by Rajat Mishra </span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Output:
Created Linked list is:  1  7  8  6  4
</code></pre></div></div>

<h2 id="deleting-a-node">Deleting a node</h2>

<p>이번에는 연결 리스트에서 특정 키 값을 갖고 있는 노드를 삭제 해보자.</p>

<ol>
  <li>삭제될 노드를 참조할 temp 포인터와 그 이전 노드를 참조하는 prev 포인터를 둔다.</li>
  <li>temp는 헤드를 참조하게 함으로써 처음 노드를 참조하게 한다.</li>
  <li>만약 삭제될 노드가 처음 노드라면, 헤드가 temp 다음 노드를 참조하게 하고 연산을 끝낸다.</li>
  <li>그렇지 않다면, 삭제할 키 값을 가지고 있는 노드를 탐색한다.</li>
  <li>탐색함에 따라 삭제될 노드와 그 이전 노드 정보를 가지고 있는 temp, prev 포인터들을 갱신한다.</li>
  <li>temp가 null이거나 삭제될 키 값을 가진 노드를 찾으면 반복문을 빠져나온다.</li>
  <li>temp가 null이면 원하는 키값을 가진 노드를 찾지 못한 것이므로 아무런 작업도 하지 않고 연산을 끝낸다.</li>
  <li>그렇지 않다면 찾은 것이므로, prev 포인터가 temp.next 참조하게 함으로써 작업을 끝낸다.</li>
</ol>

<p><img src="/assets/images/Linkedlist5.png" alt="Alt text" width="600px" height="300px" /></p>

<p>다음은 위의 연산을 구현한 자바 메소드이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="cm">/* Given a key, deletes the first occurrence of key in linked list */</span>
    <span class="kt">void</span> <span class="nf">deleteNode</span><span class="o">(</span><span class="kt">int</span> <span class="n">key</span><span class="o">)</span> 
    <span class="o">{</span> 
        <span class="c1">// 1 &amp; 2. Store head node to temp, prev</span>
        <span class="nc">Node</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">head</span><span class="o">,</span> <span class="n">prev</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> 
  
        <span class="c1">// 3. If head node itself holds the key to be deleted </span>
        <span class="k">if</span> <span class="o">(</span><span class="n">temp</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">temp</span><span class="o">.</span><span class="na">data</span> <span class="o">==</span> <span class="n">key</span><span class="o">)</span> 
        <span class="o">{</span> 
            <span class="n">head</span> <span class="o">=</span> <span class="n">temp</span><span class="o">.</span><span class="na">next</span><span class="o">;</span> <span class="c1">// Changed head </span>
            <span class="k">return</span><span class="o">;</span> 
        <span class="o">}</span> 
  
        <span class="c1">// 4. Search for the key to be deleted, keep track of the </span>
        <span class="c1">// previous node as we need to change temp.next </span>
        <span class="k">while</span> <span class="o">(</span><span class="n">temp</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">temp</span><span class="o">.</span><span class="na">data</span> <span class="o">!=</span> <span class="n">key</span><span class="o">)</span> <span class="c1">// 6.</span>
        <span class="o">{</span> 
            <span class="c1">// 5. keep track of the previous node</span>
            <span class="c1">//    as we need to change temp.next </span>
            <span class="n">prev</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>        
            <span class="n">temp</span> <span class="o">=</span> <span class="n">temp</span><span class="o">.</span><span class="na">next</span><span class="o">;</span> 
        <span class="o">}</span>     
  
        <span class="c1">// 7. If key was not present in linked list </span>
        <span class="k">if</span> <span class="o">(</span><span class="n">temp</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span> 
  
        <span class="c1">// 8. Unlink the node from linked list </span>
        <span class="n">prev</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">temp</span><span class="o">.</span><span class="na">next</span><span class="o">;</span> 
    <span class="o">}</span> 

</code></pre></div></div>

<p>이 연산의 시간복잡도는 O(n)이 된다.<br />
순수 삭제연산은 O(1)이지만, 삭제될 키 값을 찾아 탐색하는 연산이 추가되었으므로 O(n)이 된다.</p>

<h2 id="특정-키-값의-노드-찾기">특정 키 값의 노드 찾기</h2>

<p>연결 리스트에서 특정 키 값 x를 가진 노드를 찾아보자.</p>

<p><strong>search</strong> 메소드는 키 값 x를 가진 노드가 존재하면 true, 존재하지 않으면 false를 리턴한다.</p>

<ol>
  <li>리스트를 순회할 current를 헤드로 초기화한다.</li>
  <li>current가 null 아닐 때 까지 반복한다.<br />
null이면 while 빠져나와 false 리턴하고 연산을 끝낸다.</li>
  <li>current가 참조하는 노드의 데이터가 x라면 true 리턴하고 연산을 끝낸다.</li>
  <li>그렇지 않다면 다음 노드를 참조하고 2번으로 다시 간다.</li>
</ol>

<p>다음은 위의 연산을 구현한 자바 메소드이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//Checks whether the value x is present in linked list </span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">search</span><span class="o">(</span><span class="nc">Node</span> <span class="n">head</span><span class="o">,</span> <span class="kt">int</span> <span class="n">x</span><span class="o">)</span> 
    <span class="o">{</span> 
        <span class="nc">Node</span> <span class="n">current</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>    <span class="c1">// 1 포인터 초기화</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">current</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="c1">// 2. current가 null 아닐 때 까지 반복한다</span>
        <span class="o">{</span> 
            <span class="k">if</span> <span class="o">(</span><span class="n">current</span><span class="o">.</span><span class="na">data</span> <span class="o">==</span> <span class="n">x</span><span class="o">)</span> 
                <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>    <span class="c1">//3. 찾았다</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="na">next</span><span class="o">;</span> <span class="c1">// 4. 다음 노드를 참조한다</span>
        <span class="o">}</span> 
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>    <span class="c1">// 데이터를 찾지 못하였다</span>
    <span class="o">}</span> 
</code></pre></div></div>

<p>다음은 위 연산을 포한한 예제 자바 코드이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Iterative Java program to search an element </span>
<span class="c1">// in linked list </span>
  
<span class="c1">//Node class </span>
<span class="kd">class</span> <span class="nc">Node</span> 
<span class="o">{</span> 
    <span class="kt">int</span> <span class="n">data</span><span class="o">;</span> 
    <span class="nc">Node</span> <span class="n">next</span><span class="o">;</span> 
    <span class="nc">Node</span><span class="o">(</span><span class="kt">int</span> <span class="n">d</span><span class="o">)</span> 
    <span class="o">{</span> 
        <span class="n">data</span> <span class="o">=</span> <span class="n">d</span><span class="o">;</span> 
        <span class="n">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> 
    <span class="o">}</span> 
<span class="o">}</span> 
  
<span class="c1">//Linked list class </span>
<span class="kd">class</span> <span class="nc">LinkedList</span> 
<span class="o">{</span> 
    <span class="nc">Node</span> <span class="n">head</span><span class="o">;</span>    <span class="c1">//Head of list </span>
  
    <span class="c1">//Inserts a new node at the front of the list </span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">push</span><span class="o">(</span><span class="kt">int</span> <span class="n">new_data</span><span class="o">)</span> 
    <span class="o">{</span> 
        <span class="c1">//Allocate new node and putting data </span>
        <span class="nc">Node</span> <span class="n">new_node</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="n">new_data</span><span class="o">);</span> 
  
        <span class="c1">//Make next of new node as head </span>
        <span class="n">new_node</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span> 
  
        <span class="c1">//Move the head to point to new Node </span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">new_node</span><span class="o">;</span> 
    <span class="o">}</span> 
  
    <span class="c1">//Checks whether the value x is present in linked list </span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">search</span><span class="o">(</span><span class="nc">Node</span> <span class="n">head</span><span class="o">,</span> <span class="kt">int</span> <span class="n">x</span><span class="o">)</span> 
    <span class="o">{</span> 
        <span class="nc">Node</span> <span class="n">current</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>    <span class="c1">//Initialize current </span>
        <span class="k">while</span> <span class="o">(</span><span class="n">current</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> 
        <span class="o">{</span> 
            <span class="k">if</span> <span class="o">(</span><span class="n">current</span><span class="o">.</span><span class="na">data</span> <span class="o">==</span> <span class="n">x</span><span class="o">)</span> 
                <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>    <span class="c1">//data found </span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="na">next</span><span class="o">;</span> 
        <span class="o">}</span> 
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>    <span class="c1">//data not found </span>
    <span class="o">}</span> 
  
    <span class="c1">//Driver function to test the above functions </span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span> <span class="n">args</span><span class="o">[])</span> 
    <span class="o">{</span> 
  
        <span class="c1">//Start with the empty list </span>
        <span class="nc">LinkedList</span> <span class="n">llist</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">();</span> 
  
        <span class="cm">/*Use push() to construct below list 
        14-&gt;21-&gt;11-&gt;30-&gt;10  */</span>
        <span class="n">llist</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span> 
        <span class="n">llist</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="mi">30</span><span class="o">);</span> 
        <span class="n">llist</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="mi">11</span><span class="o">);</span> 
        <span class="n">llist</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="mi">21</span><span class="o">);</span> 
        <span class="n">llist</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="mi">14</span><span class="o">);</span> 
  
        <span class="k">if</span> <span class="o">(</span><span class="n">llist</span><span class="o">.</span><span class="na">search</span><span class="o">(</span><span class="n">llist</span><span class="o">.</span><span class="na">head</span><span class="o">,</span> <span class="mi">21</span><span class="o">))</span> 
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Yes"</span><span class="o">);</span> 
        <span class="k">else</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"No"</span><span class="o">);</span> 
    <span class="o">}</span> 
<span class="o">}</span> 
<span class="c1">// This code is contributed by Pratik Agarwal </span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Output:
Yes
</code></pre></div></div>
<h2 id="연결-리스트-연산들의-시간복잡도">연결 리스트 연산들의 시간복잡도</h2>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>시간복잡도 - 최악 기준      

접근     검색      삽입     삭제	
O(n)    O(n)	 O(1)	 O(1)	  
</code></pre></div></div>
<h2 id="references">References</h2>
<p><a href="https://www.geeksforgeeks.org/">GeeksforGeeks</a></p>
:ET