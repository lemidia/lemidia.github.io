I"+<h2 id="union-by-rank">Union by Rank</h2>

<p>트리의 깊이 또는 높이는 유니온 파인드 연산 실행시간에 영향을 주는데
트리를 합칠 때 높이가 작은 트리를 높이가 큰 트리의 루트에 붙이면 높이가 높아지지 않습니다.
이렇게 유니온 바이 랭크(union by rank)는 높이가 작은 트리를 큰 트리 루트에 붙이는 방법입니다.</p>

<p>※ 단, 높이가 같은 트리를 합칠 땐 높이가 +1 높아집니다.</p>

<p>우리는 여기서 랭크라는 표현을 쓰는데, 트리의 높이는 위에서 살펴본 path compresstion에 의해서 줄어들 수 있고 업데이트되지 않기 때문입니다. 그래서 랭크라는 표현을 씁니다.</p>

<p>원소마다 랭크 정보를 유지하기 위해서 Make set의 for loop에 rank [i] = 0을 추가해 줍니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="o">(</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
    <span class="n">parent</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
    <span class="n">rank</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// 처음에는 랭크가 전부 0</span>
<span class="o">}</span>
</code></pre></div></div>
<p>아래는 union by rank코드입니다.</p>

<p>두 원소의 루트를 구해서 서로 같다면 합치지 않고 유니온 연산을 종료합니다.<br />
그렇지 않다면, x의 루트랭크가 y의 루트랭크보다 크거나 같다면 y의 루트를 x의 루트 아래로 붙입니다. (else 서로 스왑해서 수행)
두 트리의 랭크가 서로 같다면 랭크+1을 해줍니다. (두 트리의 랭크가 같으니 합치면 랭크가 +1 됩니다.)</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">union</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span>
     <span class="n">xRoot</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
     <span class="n">yRoot</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">y</span><span class="o">);</span>
     <span class="k">if</span> <span class="n">xRoot</span> <span class="o">==</span> <span class="n">yRroot</span>
         <span class="k">return</span>
 
     <span class="nf">if</span> <span class="o">(</span><span class="n">rank</span><span class="o">[</span><span class="n">xRoot</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">rank</span><span class="o">[</span><span class="n">yRoot</span><span class="o">])</span>
         <span class="n">parent</span><span class="o">[</span><span class="n">yRoot</span><span class="o">]</span> <span class="o">=</span> <span class="n">xRoot</span><span class="o">;</span>
     <span class="k">else</span>
         <span class="n">parent</span><span class="o">[</span><span class="n">xRoot</span><span class="o">]</span> <span class="o">=</span> <span class="n">yRoot</span><span class="o">;</span>
 
     <span class="k">if</span> <span class="o">(</span><span class="n">rank</span><span class="o">[</span><span class="n">xRoot</span><span class="o">]</span> <span class="o">==</span> <span class="n">rank</span><span class="o">[</span><span class="n">yRoot</span><span class="o">])</span>
         <span class="n">rank</span><span class="o">[</span><span class="n">yRoot</span><span class="o">]</span> <span class="o">=</span> <span class="n">rank</span><span class="o">[</span><span class="n">xRroot</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1</span>
</code></pre></div></div>

<h2 id="application">Application</h2>

<p>유니온 파인드는 무향 그래프에서의 사이클 존재 유무를 판별할 때 사용될 수 있습니다. (단, 셀프 루프는 없어야 합니다.)</p>

<p>또, 크루스칼 알고리즘에서 최소 스패닝 트리를 찾는데에 사용됩니다.</p>

<p>최소 스패닝 트리는 노드의 수가 n개 일 때 n-1개의 최소 비용의 간선으로 이루어진 트리로서 그래프에서 최소비용의 간선을 선택함에 있어 만들어지는 트리에서 사이클이 존재하지 않아야 하기에 사이클을 형성 유무 판별에 유니온 파인드가 사용됩니다.</p>

<h3 id="union-by-lank-with-path-compression">Union by Lank with Path Compression</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">unionFind</span><span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">parent</span><span class="o">[];</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">rank</span><span class="o">[];</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">n</span><span class="o">;</span>
 
    <span class="n">unionFind</span><span class="o">(</span><span class="kt">int</span> <span class="n">cnt</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">n</span> <span class="o">=</span> <span class="n">cnt</span><span class="o">;</span>
        <span class="n">parent</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="n">rank</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
    <span class="o">}</span>
 
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">makeSet</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">parent</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
            <span class="n">rank</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
 
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">find</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">parent</span><span class="o">[</span><span class="n">x</span><span class="o">]</span> <span class="o">==</span> <span class="n">x</span><span class="o">)</span>
            <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
        <span class="k">else</span>
            <span class="k">return</span> <span class="n">parent</span><span class="o">[</span><span class="n">x</span><span class="o">]</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">parent</span><span class="o">[</span><span class="n">x</span><span class="o">]);</span> <span class="c1">// * 경로 압축</span>
    <span class="o">}</span>
 
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">union</span><span class="o">(</span><span class="kt">int</span> <span class="n">root1</span><span class="o">,</span> <span class="kt">int</span> <span class="n">root2</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">root1</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">root1</span><span class="o">);</span>
        <span class="n">root2</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">root2</span><span class="o">);</span>
 
        <span class="k">if</span> <span class="o">(</span><span class="n">root1</span> <span class="o">==</span> <span class="n">root2</span><span class="o">)</span> <span class="c1">// 루트가 같다면 수행하지 않는다.</span>
            <span class="k">return</span><span class="o">;</span>
 
        <span class="k">if</span> <span class="o">(</span><span class="n">rank</span><span class="o">[</span><span class="n">root1</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">rank</span><span class="o">[</span><span class="n">root2</span><span class="o">])</span> <span class="o">{</span> <span class="c1">// 루트1의 랭크가 루트2의 랭크보다 크다면</span>
            <span class="n">parent</span><span class="o">[</span><span class="n">root2</span><span class="o">]</span> <span class="o">=</span> <span class="n">parent</span><span class="o">[</span><span class="n">root1</span><span class="o">];</span> <span class="c1">//루트2가 루트1의 밑으로 합친다</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span> <span class="c1">// 위의 if문 과 반대</span>
            <span class="n">parent</span><span class="o">[</span><span class="n">root1</span><span class="o">]</span> <span class="o">=</span> <span class="n">parent</span><span class="o">[</span><span class="n">root2</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">rank</span><span class="o">[</span><span class="n">root1</span><span class="o">]</span> <span class="o">==</span> <span class="n">rank</span><span class="o">[</span><span class="n">root2</span><span class="o">])</span>
            <span class="n">rank</span><span class="o">[</span><span class="n">root1</span><span class="o">]+=</span><span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="references">References</h2>
<p><a href="https://en.wikipedia.org/wiki/Disjoint-set_data_structure#by_size">Wikipedi - Union Find</a></p>

<p><a href="https://algocoding.wordpress.com/2014/09/19/union-find-data-structure-disjoint-set-data-structure/">Algocoding - Union Find</a></p>
:ET