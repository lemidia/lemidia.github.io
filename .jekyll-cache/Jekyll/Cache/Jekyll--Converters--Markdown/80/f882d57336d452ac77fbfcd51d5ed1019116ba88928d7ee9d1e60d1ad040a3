I"^<h1 id="전체탐색법">전체탐색법</h1>

<p>전체탐색법은 모든 문제해결의 기초가 되는 가장 중요한 설계법 중 하나라고 할 수 있다. 주어진 문제에서 해가 될 수 있는 모든 가능성을 검사하여 해를 구하기 때문에 항상 정 확한 해를 구할 수 있다는 점이 장점이다. 하지만 탐색해야할 내용이 너무 많으면 문제에서 제시한 시간 이내에 해결할 수 없다는 점을 유의해야 한다.</p>

<p>하지만 전체탐색을 기반으로 한 다양한 응용들이 있으며, 이러한 응용들을 통하여 탐색 해야할 공간을 배제해 나가면서 시간을 줄일 수 있는 다양한 방법들이 존재하기 때문에 잘 응용하면 많은 문제를 해결할 수 있는 강력한 도구가 될 수 있다. 따라서 전체탐색법을 잘 익혀두면 다른 알고리즘 설계법을 학습하는데 많은 도움이 된다.</p>

<p>전체탐색법은 선형구조의 탐색, 비선형구조의 탐색을 기반으로 하여 문제를 해결한다.</p>

<h2 id="선형구조와-비선형구조의-전체탐색">선형구조와 비선형구조의 전체탐색</h2>

<p>선형구조의 전체탐색은 반복문을 이용하여 접근할 수 있다.<br />
1차 원 뿐만 아니라 2차원 이상의 다차원 구조에 대해서도 선형구조로 탐색할 수 있다.</p>

<p>비선형구조의 전체탐색은 문제해결의 가장 기본이 되는 알고리즘 설계법인 백트래킹을 이용한다.<br />
백트래킹 기법은 재귀함수를 이용하여 간단하게 구현할 수 있고, 다양한 문제를 해결하는데 많이 응용되는 방법이므로 반드시 익혀둘 필요가 있다.</p>

<p>주어진 문제들을 통하여 선형구조, 비선형구조의 전체탐색법을 익힐 수 있도록 하자.</p>

<hr />

<h3 id="선형-구조에서의-전체탐색">선형 구조에서의 전체탐색</h3>

<h4 id="약수의-합-구하기">약수의 합 구하기</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>한 정수 n을 입력받아서 n의 모든 약수의 합을 구하는 프로그램을 작성하시오.  

예를 들어 10의 약수는 1, 2, 5, 10이므로 이 값들의 합인 18이 10의 약수의 합이 된다.  

입력  
첫 번째 줄에 정수 n이 입력된다. (단, 1 &lt;= n &lt;= 100,000)  

출력  
n의 약수의 합을 출력한다.

입력 예
10

출력 예
18
</code></pre></div></div>

<p>이 문제는 기본적으로 수학적인 아이디어를 이용하여 해결할 수 있는 문제이지만 이 단 원에서는 전체탐색법을 다루는 단원이므로 전체탐색법으로 해결해보자.</p>

<p>일단 n을 입력받으면 1부터 n까지의 모든 수를 차례로 반복문을 이용하여 선형으로 탐색하면서 n의 약수들을 검사한다. 만약 현재 탐색 중인 수가 n의 약수라면 누적하여 구 할 수 있다. 이렇게 구한다면 계산량은 O(n)이 된다. 이 문제에서는 n의 최댓값이 100,000이므로 충분히 해결할 수 있는 문제가 된다.</p>

<p>어떤 수 x가 n의 약수라면 다음 조건을 이용해 구할 수 있다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>n % x == 0
</code></pre></div></div>

<p>이를 이용하여 문제를 해결한 소스코드는 다음과 같다.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
</span><span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">solve</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">ans</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span>
        <span class="k">if</span><span class="p">(</span><span class="n">n</span><span class="o">%</span><span class="n">i</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">ans</span><span class="o">+=</span><span class="n">i</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">solve</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이문제는 이와 같은 방법으로 쉽게 해결할 수 있으나, n이 10억 이상의 값으로 커질 때는 다른 방법을 생각해야 한다.<br />
아마 다른 포스트에서 다루게 될 것이므로 한 번 생각해보자.</p>

<h4 id="최댓값">최댓값</h4>
<p>&lt;그림 1&gt;과 같이 9×9 격자판에 쓰여진 81개의 자연수가 주어질 때, 이들 중 최댓 값을 찾고 그 최댓값이 몇 행 몇 열에 위치한 수인지 구하는 프로그램을 작성하시오.<br />
예를 들어, 다음과 같이 81개의 수가 주어질 경우에는 이들 중 최댓값은 90이고, 이 값은 5행 7열에 위치한다.</p>

<p>입력
첫째 줄부터 아홉째 줄까지 한 줄에 아홉 개씩 자연수가 주어진다. 주어지는 자연 수는 100보다 작다.</p>

<p>입력 예
3 23 85 34 17 74 25 52 65
10 7 39 42 88 52 14 72 63
87 42 18 78 53 45 18 84 53
34 28 64 85 12 16 75 36 55
21 77 45 35 28 75 90 76 1
25 87 65 15 28 11 37 28 74
65 27 75 41 7 89 78 64 39
47 47 70 45 23 65 3 41 44
87 13 82 38 31 12 29 29 80</p>

<p><img src="/assets/images/creativealgorithm1.png" alt="Alt text" width="500px" height="300px" /></p>

<p>원은 정점, 선분은 간선을 나타내며, a-b는 보통간선, a-&gt;b는 방향간선, b-d는 가중치가 15인 양방향통행 간선, d-&gt;e는 가중치가 7인 일방통행 간선(방향간선)을 나타낸다.<br />
정점은 점 또는 원으로 표현하며, 일반적으로 상태나 위치를 표현한다. 간선은 정점들을 연결하는 선으로 표현하며, 정점들 간의 관계를 표현한다.</p>

<h3 id="경로path와-회로cycle">경로(path)와 회로(cycle)</h3>

<p>그래프에서 임의의 정점 s에서 임의의 정점 t로 이동할 때, s에서 t로 이동하는데 사용한 정점들을 연결하고 있는 간선들의 순서로 된 집합을 경로라고 한다. 회로는 그래프에서 임 의의 정점 s에서 같은 정점 s로의 경로들을 말한다.</p>

<p><img src="/assets/images/creativealgorithm2.png" alt="Alt text" width="550px" height="300px" /></p>

<h3 id="자기간선loop과-다중간선multi-edge">자기간선(loop)과 다중간선(multi edge)</h3>

<p>임의의 정점에서 자기 자신으로 연결하고 있는 간선을 자기간선, 임의의 정점에서 다른 정점으로 연결된 간선의 수가 2개 이상일 경우를 다중간선이라고 한다.</p>

<p><img src="/assets/images/creativealgorithm3.png" alt="Alt text" width="550px" height="300px" /></p>

<h3 id="그래프의-차수degree">그래프의 차수(degree)</h3>
<p>그래프의 임의의 한 정점에서 다른 정점으로 연결된 간선의 수를 차수라고 한다.</p>

<p><img src="/assets/images/creativealgorithm4.png" alt="Alt text" width="550px" height="300px" /></p>

<h2 id="그래프의-구현">그래프의 구현</h2>

<p>그래프를 구현하는 방법은 인접행렬(adjacency matrix)과 인접리스트(adjacency list)로 크게 나눌 수 있다.</p>

<p class="notice--info">tip: 프로그래밍 대회에서 그래프는 보통 정점의 수, 간선의 수, 각 간선들이 연결하고 있는 정점 2개로 이루어진 정보가 주어진다.</p>

<p>다음과 같은 그래프가 주어질 때, 이를 표현하는 2가지 방법을 알아본다.</p>

<p><img src="/assets/images/creativealgorithm5.png" alt="Alt text" width="550px" height="300px" /></p>

<p><strong>위 그래프의 입력 형식과 입력 데이터의 예</strong></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>입력 형식:
첫 번째 줄에 정점의 수 n과 간선의 수 m 이 공백으로 구분되어 입력된다.
두 번째 줄부터 m개의 줄에 걸쳐서 간선으로 연결된 두 정점의 번호와 가중치가  
공백으로 구분되어 입력된다.

입력 데이터:
7 11
1 2 47 
1 3 69 
2 4 57 
2 5 124 
3 4 37 
3 5 59 
3 6 86 
4 6 27 
4 7 94 
5 7 21 
6 7 40
</code></pre></div></div>

<h3 id="인접행렬의-구현">인접행렬의 구현</h3>

<p>입력예시를 인접행렬로 받기 위해서는 2차원 배열을 이용한다.<br />
먼저 최대 정점의 수에 맞추어 2차원 배열을 선언하고 각 배열의 칸에 연결된 정보를 저장한다.<br />
앞 그래프를 2차원 행렬을 이용하여 다음과 같이 저장한다.</p>

<p><img src="/assets/images/creativealgorithm6.png" alt="Alt text" width="650px" height="500px" /></p>

<p>2차원 행렬을 이용하여 저장하는 소스코드는 다음과 같다. 단 최대 정점의 수는 100개 로 가정한다.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">C</span> <span class="n">language</span>
<span class="cp">#include &lt;stdio.h&gt; 
</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">G</span><span class="p">[</span><span class="mi">101</span><span class="p">][</span><span class="mi">101</span><span class="p">];</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">scanf</span><span class="p">(</span><span class="s">"%d %d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">n</span><span class="p">,</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">w</span><span class="p">;</span>
        <span class="n">scanf</span><span class="p">(</span><span class="s">"%d %d %d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">w</span><span class="p">);</span>
        <span class="n">G</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="n">b</span><span class="p">]</span><span class="o">=</span><span class="n">G</span><span class="p">[</span><span class="n">b</span><span class="p">][</span><span class="n">a</span><span class="p">]</span><span class="o">=</span><span class="n">w</span><span class="p">;</span>
    <span class="p">}</span> 
<span class="p">}</span>
</code></pre></div></div>

<h3 id="인접리스트의-구현">인접리스트의 구현</h3>

<p>인접행렬로 표현할 때에는 연결되지 않았던 부분까지 모두 표현이 된다. 즉, 각 칸에 0 이라고 기록된 부분은 연결이 되지 않은 부분을 의미한다. 사실 일반적인 그래프에서 행렬 상에서 0이라고 표현되는 부분이 많을 가능성이 크다.</p>

<p>알고리즘을 구현할 때에도 이 0이라고 표시된 부분까지 모두 조사를 해야 하므로 효율 이 떨어지는 경우가 많다. 이러한 단점을 극복하기 위하여 제안된 방법이 인접리스트이고 이 방법은 인접행렬에서 0으로 표시된 부분은 저장하지 않으므로 효율을 높이고 있다.</p>

<p><img src="/assets/images/creativealgorithm7.png" alt="Alt text" width="650px" height="300px" /></p>

<p><img src="/assets/images/creativealgorithm8.png" alt="Alt text" width="650px" height="300px" /></p>

<p>위의 입력 예시를 인접리스트로 구현하기 위해서는 [그림-10], [그림-11]과 같이 연결리스트로 구현할 수 있지만 STL에서 제공하는 C++의 std::vector()를 이용하면 보다 더 간단하게 구현할 수 있다. 위의 입력예시를 인접리스트로 구현하면 다음과 같은 그림이 된다.</p>

<p><img src="/assets/images/creativealgorithm9.png" alt="Alt text" width="650px" height="300px" /></p>

<p>C++의 std::vector()를 이용한다면 위와 같이 인접행렬로 구현하는 것보다 공간을 더 적게 사용한다. 따라서 전체탐색법을 구현할 때, 당연히 탐색시간도 줄일 수 있다. 계산량으로 표현하자면, 인접행렬로 모든 정점을 탐색하는데 O($n^2$)의 시간이 드는데 반해, 인접리스트로 표현하면 O(n+m)의 시간이 든다.</p>

<p class="notice--info">여러 가지 장점으로 인해 인접리스트를 이용한 방법을 활용하는 경우가 많으므로 반드시 익혀둘 수 있도록 하자.</p>

<h2 id="비선형-구조의-탐색">비선형 구조의 탐색</h2>

<h3 id="깊이우선탐색dfs">깊이우선탐색(dfs)</h3>

<p>그래프 중 회로(cycle)가 없는 그래프를 트리라고 한다. 다음 그림은 트리를 나타낸다. 이 트리의 가장 위에 있는 정점에서 출발하여 모든 정점들을 깊이우선으로 탐색하며, 탐색 하는 순서를 알아보자.</p>

<p><img src="/assets/images/creativealgorithm10.png" alt="Alt text" width="650px" height="300px" /></p>

<p>출발 정점을 트리의 가장 위에 있는 정점으로 하고, 한 정점에서 이동 가능한 정점이 여 러 개 있을 경우 왼쪽의 정점부터 방문한다고 가정하면, 단계별 탐색 과정은 다음과 같다.</p>

<p><img src="/assets/images/creativealgorithm11.png" alt="Alt text" width="650px" height="300px" /></p>

<p>깊이우선탐색과정에서 3단계 이후 더 이상 진행할 수 있는 정점이 없다. 그 이유는 간선 으로 연결된 정점들 중 아직 방문하지 않은 정점을 방문하기 때문이다.</p>

<p>이처럼 더 이상 진행할 수 없을 때는 다시 이전 정점으로 되돌아가는 과정이 필요하다. 일반적으로 이 과정을 백트랙(backtrack)이라고 한다. 백트랙은 비선형 구조의 탐색에서 매 우 중요하다. 백트랙은 스택(stack)이나 재귀함수(recursion)를 이용하면 쉽게 구현할 수 있다.</p>

<p><img src="/assets/images/creativealgorithm12.png" alt="Alt text" width="650px" height="300px" /></p>

<p>4, 5, 6단계는 연속으로 백트랙이 발생한다. 이는 더 이상 진행할 수 없는 정점까지 도달 했다는 것을 의미한다. 계속 해서 다음 단계로 진행하는 과정은 다음과 같다.</p>

<p><img src="/assets/images/creativealgorithm13.png" alt="Alt text" width="650px" height="300px" /></p>

<p>위 단계에서 마지막 정점을 방문하면 깊이우선탐색이 완료된다.</p>

<p><img src="/assets/images/creativealgorithm14.png" alt="Alt text" width="650px" height="300px" /></p>

<p>깊이우선탐색을 정리하여 설명하면 먼저 시작 정점에서 간선을 하나 선택하여 진행할 수 있을 때까지 진행하고 더 이상 진행할 수 없다면 백트랙하여 다시 다른 정점으로 진행 하여 더 이상 진행할 정점이 없을 때까지 이 과정을 반복하는 탐색법으로, 간선으로 연결 된 모든 정점을 방문할 수 있는 탐색법이다.</p>

<p>깊이우선탐색의 알고리즘은 다음과 같다. 이 탐색법은 백트래킹(backtracking)이라는 알 고리즘 설계 기법의 중심이 되며 백트래킹 기법은 모든 문제를 해결할 수 있는 가장 기본 적인 방법이므로 꼭 익혀둘 필요가 있다.</p>

<p>깊이우선탐색</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="n">visited</span><span class="p">[</span><span class="mi">101</span><span class="p">];</span> <span class="c1">//방문했는지 체크해 두는 배열</span>
<span class="kt">void</span> <span class="nf">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="p">){</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">G</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span> <span class="c1">// 정점 k와 연결된 모든 정점 방문</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">G</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">to</span><span class="p">]){</span> <span class="c1">// 만약 아직 방문하지 않았으면</span>
            <span class="n">visited</span><span class="p">[</span><span class="n">G</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">to</span><span class="p">]</span><span class="o">=</span><span class="nb">true</span><span class="p">;</span> <span class="c1">// 방문했다고 체크하고</span>
            <span class="c1">// 깊이우선탐색 진행</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">i</span><span class="p">]);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span><span class="p">;</span> <span class="c1">//더 이상 갈 길이 없으면 backtrack</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이 방법은 그래프를 인접리스트에 저장했을 경우에 활용할 수 있다. 전체를 탐색하는데 있어서 반복문의 실행횟수는 모두 m 번이 된다. 일반적으로 인접행렬 보다 속도가 더 빠르기 때문에 자주 활용된다.</p>

<hr />

<h3 id="너비우선탐색bfs">너비우선탐색(bfs)</h3>

<p>너비우선탐색은 깊이우선탐색과는 달리 현재 정점에서 깊이가 1인 정점을 모두 탐색한 뒤 깊이를 늘려가는 방식이다. 위에서 다룬 ‘10개의 정점과 9개의 간선을 가진 트리’를 통해서 너비우선탐색을 살펴보자.</p>

<p><img src="/assets/images/creativealgorithm15.png" alt="Alt text" width="650px" height="300px" /></p>

<p>먼저 1단계부터 4단계까지를 살펴보면 1에서 출발하여 깊이가 1인 세 정점을 모 두 순차적으로 방문한다. 계속해서 너비우선탐색의 결과를 살펴보면 다음과 같다.</p>

<p><img src="/assets/images/creativealgorithm16.png" alt="Alt text" width="650px" height="300px" /></p>

<p><img src="/assets/images/creativealgorithm17.png" alt="Alt text" width="650px" height="300px" /></p>

<p>너비우선탐색은 백트랙을 하지 않는다. 대신에 현재 정점에서 깊이가 1인 정점을 모두 방문해야 하므로 큐(queue)라는 선입선출(FIFO) 자료구조를 활용하여 현재 정점에서 깊이가 1 더 깊은 모든 정점을 순차적으로 큐에 저장하여 탐색에 활용한다.<br />
따라서 STL에서 제 공하는 std::queue()를 활용하는 방법을 익힐 필요가 있다.</p>

<p>너비우선탐색 알고리즘은 다음과 같다.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;queue&gt;
</span><span class="kt">bool</span> <span class="n">visited</span><span class="p">[</span><span class="mi">101</span><span class="p">];</span>
<span class="kt">void</span> <span class="nf">bfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="p">){</span>
    <span class="n">std</span><span class="o">::</span><span class="n">queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">Q</span><span class="p">;</span>
    <span class="n">Q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="n">visited</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">Q</span><span class="p">.</span><span class="n">empty</span><span class="p">()){</span>
        <span class="kt">int</span> <span class="n">current</span><span class="o">=</span><span class="n">Q</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
        <span class="n">Q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">G</span><span class="p">[</span><span class="n">current</span><span class="p">].</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">G</span><span class="p">[</span><span class="n">current</span><span class="p">][</span><span class="n">i</span><span class="p">]])</span> <span class="p">{</span>
                <span class="n">visited</span><span class="p">[</span><span class="n">G</span><span class="p">[</span><span class="n">current</span><span class="p">][</span><span class="n">i</span><span class="p">]]</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
                <span class="n">Q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">current</span><span class="p">][</span><span class="n">i</span><span class="p">]);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이 방법은 그래프를 인접리스트에 저장했을 경우에 활용할 수 있으며, 전체를 탐색하는 데 있어서 반복문의 실행횟수는 모두 m번이 된다. 따라서 일반적으로 속도가 인접행렬 보다 더 빠르기 때문에 자주 활용된다.</p>

<h3 id="references">References</h3>

<ul>
  <li>문제해결을 위한 창의적 알고리즘</li>
</ul>
:ET