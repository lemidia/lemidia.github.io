I"L<h1 id="트리의-순회tree-traversal">트리의 순회(Tree Traversal)</h1>

<p>트리를 순회하는데 여러가지 방법이 있지만 이번 포스트에서는 그 중 대표적인 3가지 방법을 알아본다.</p>

<p>다음은 트리를 순회하는 대표적인 3가지 방법이다.</p>

<ol>
  <li>Inorder - 중위 순회</li>
  <li>Preorder - 전위 순회</li>
  <li>Postorder - 후위 순회</li>
</ol>

<p>3가지 순회들은 다음의 공통된 패턴을 가지고 있다.</p>

<p>(L) 재귀적으로 현재 노드의 왼쪽 서브트리를 방문한다.<br />
(R) 재귀적으로 현재 노드의 오른쪽 서브트리를 방문한다.<br />
(N) 현재 노드를 방문한다.</p>

<p>모든 노드에 대해서, 이 패턴들이 실행되는 순서에 따라 3가지 순회 방법이 결정되게 된다.</p>

<p class="notice--info">여기서 <strong>‘재귀적으로’</strong>라는 말은 작업이 다른 <strong>서브루틴으로 분기</strong>된다는 뜻이다.<br />
서브루틴에서의 작업이 끝나게 되면 다시 현재의 작업으로 <strong>백트랙</strong>하게 된다.</p>

<h2 id="inorder---중위-순회">Inorder - 중위 순회</h2>

<p>트리의 중위 순회를 위해서 루트 노드 부터 모든 노드에 대해 다음의 작업을 수행한다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>현재 노드가 null인지 확인한다.  

아니라면 다음의 순서대로 순회를 한다.  

(L) 재귀적으로 현재 노드의 왼쪽 서브트리를 방문한다. 
(R) 재귀적으로 현재 노드의 오른쪽 서브트리를 방문한다. 
(N) 현재 노드를 방문한다.
</code></pre></div></div>

<p>위의 그림에서 볼 수 있듯이, 어떤 노드가 처리되기 전에 왼쪽 서브트리가 먼저 처리되고 그 다음 해당 노드가 처리되고 그 다음 오른쪽 서브트리 처리된다.</p>

<p>모든 노드에 대해서 연산들은 재귀적으로 수행이 된다.</p>

<p>다음은 위를 구현한 자바 코드이다.</p>

<p>다음의 그림은 Inorder의 예를 보여준다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Recursive function to perform in-order traversal of the tree</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">inorder</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span>
<span class="o">{</span>
	<span class="c1">// 현재 노드가 null이면 리턴</span>
	<span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">return</span><span class="o">;</span>
	<span class="o">}</span>

	<span class="c1">// 왼쪽 서브트리를 탐색한다.</span>
	<span class="n">inorder</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>

	<span class="c1">// Display the data part of the root (or current node)</span>
	<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">data</span> <span class="o">+</span> <span class="s">" "</span><span class="o">);</span>

	<span class="c1">// Traverse the right subtree</span>
	<span class="n">inorder</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="inorder---중위-순회-1">Inorder - 중위 순회</h2>

<p>트리의 중위 순회를 위해서 루트 노드 부터 모든 노드에 대해 다음의 작업을 수행한다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>현재 노드가 null인지 확인한다.  

아니라면 다음의 순서대로 순회를 한다.  

(L) 재귀적으로 현재 노드의 왼쪽 서브트리를 방문한다. 
(R) 재귀적으로 현재 노드의 오른쪽 서브트리를 방문한다. 
(N) 현재 노드를 방문한다.
</code></pre></div></div>

<p>다음의 그림은 Inorder의 예를 보여준다.</p>

<p><img src="/assets/images/treeTraversal1.png" alt="Alt text" width="350px" height="350px" /></p>

<h2 id="트리-용어">트리 용어</h2>
<p>트리에 쓰이는 용어들을 알아보자.</p>

<h3 id="루트root">루트(Root)</h3>
<p>트리의 계층적 구조상 가장 위에 위치한 노드를 지칭한다.<br />
위의 그림에서 A가 루트이다.</p>

<p class="notice--info">루트는 유일하게 부모 노드가 없는 노드이다.</p>

<h3 id="리프-노드reaf-node">리프 노드(Reaf Node)</h3>
<p>아무런 자식도 가지지 않는 노드를 리프 노드라고 한다.<br />
위의 그림에서 E, F, C, G, H가 리프 노드이다.</p>

<h3 id="조상-노드ancestor">조상 노드(Ancestor)</h3>
<p>특정 노드에서 루트로의 선행자가 이에 해당한다.<br />
노드 F의 조상 노드는 B, A가 된다.</p>

<h3 id="형제-노드sibling">형제 노드(Sibling)</h3>
<p>같은 부모를 가지는 노드들을 형제 노드라고 한다.<br />
위의 그림에서 B, C, D가 형제 노드이다.</p>

<h3 id="서브-트리sub-tree">서브 트리(Sub Tree)</h3>
<p>위의 그림에서 A가 null이 아니면, 그 밑의 자식 트리 T1, T2, T3를 노드 A의 서브 트리라고 한다.</p>

<h3 id="레벨level">레벨(Level)</h3>
<p>트리는 계층적 구조로서 레벨을 가지고 있다.<br />
루트는 0레벨이며, 밑 자식으로 갈수록 레벨이 1씩 커진다.</p>

<h1 id="이진-트리">이진 트리</h1>

<p>한 노드가 최대 2개의 자식 노드를 가질 수 있는 트리를 이진 트리라고 한다.<br />
한 노드의 왼쪽에 오는 자식을 왼쪽 자식 노드, 오른쪽에 오는 자식을 오른쪽 자식 노드라고 부른다.</p>

<p>다음은 전형적인 이진 트리를 나타내는 그림이다.</p>

<p><img src="/assets/images/tree2.png" alt="Alt text" width="500px" height="300px" /></p>

<h2 id="이진-트리의-종류">이진 트리의 종류</h2>

<p>이진 트리를 구성하는 노드의 형태에 따라 다음과 같이 분류된다.</p>

<h3 id="full-binary-tree">Full Binary Tree</h3>

<p>모든 노드가 자식을 0개 혹은 2개 가진 트리를 일컽는다.</p>

<p>다음은 전부 Full Binary Tree이다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>         18
       /    \  
      15      30  
     /  \     /  \
   40   50  100   40

            18
           /    \   
         15     20    
        /  \       
      40    50   
    /   \
   30   50

          18
         /   \  
        40   30  
            /  \
          100   40
</code></pre></div></div>

<p class="notice--info">Full Binary Tree에서 리프노드의 수는 내부노드의 수 + 1 이다.</p>

<h3 id="complete-binary-tree">Complete Binary Tree</h3>

<p>트리의 마지막 레벨을 제외한 모든 레벨에서 노드가 자식을 두개 가지고 있고, 마지막 레벨에서는 왼쪽 부터 자식이 빠짐없이 차 있는 트리를 일컽는다.</p>

<p>다음은 전부 Complete Binary Tree 이다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>             18
           /    \  
         15      30  
        /  \    /  \
      40   50 100   40


             18
           /    \  
         15      30  
        /  \    /  \
      40   50  100 40
     / \   /
    8  7  9 
</code></pre></div></div>

<p class="notice--info">Binary Heap은 Complete Binary 트리이다.</p>

<h3 id="perfect-binary-tree">Perfect Binary Tree</h3>

<p>리프노드를 제외한 모든 내부노드가 자식 노드를 2개 가지고, 모든 리프노드가 동일 레벨 선상에 있는 트리를 일컽는다.</p>

<p>다음은 전부 Perfect Binary Tree 이다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>              18
           /       \  --- 높이 h: 3
         15         30
        /  \        /  \
      40    50    100   40


             18
           /    \  -- 높이 h: 2
         15     30 
</code></pre></div></div>

<p class="notice--info">Perfect Binary Tree의 높이가 h일 때 <strong>$2^h-1$</strong>개의 노드를 가진다.<br />
(높이 h: 루트로부터 리프노드 까지의 경로에 있는 노드의 수)</p>

<h3 id="degenerate-or-pathological-tree">Degenerate (or pathological) tree</h3>

<p>트리의 내부노드가 오직 하나의 자식만을 갖는 트리를 일컽는다.</p>

<p>다음은 Degenerate tree 이다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    10
    /
   20
    \
     30
       \
       40    
</code></pre></div></div>

<p class="notice--info">연결 리스트와 성능면에서 동일하다.</p>

<h2 id="이진-트리-표현">이진 트리 표현</h2>

<p>이진 트리를 어떻게 표현하고 구현할 수 있을지 알아본다.</p>

<p>이진 트리 클래스는 최상위 노드를 가리키는 root 레퍼런스를 갖고 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">BinaryTree</span> 
<span class="o">{</span> 
    <span class="c1">// Root of Binary Tree </span>
    <span class="nc">Node</span> <span class="n">root</span><span class="o">;</span> 
  
    <span class="c1">// Constructors </span>
    <span class="nc">BinaryTree</span><span class="o">(</span><span class="kt">int</span> <span class="n">key</span><span class="o">)</span> 
    <span class="o">{</span> 
        <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="n">key</span><span class="o">);</span> 
    <span class="o">}</span> 
  
    <span class="nc">BinaryTree</span><span class="o">()</span> 
    <span class="o">{</span> 
        <span class="n">root</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> 
    <span class="o">}</span> 
<span class="o">}</span>
</code></pre></div></div>

<p>또한 이진 트리 클래스는 각 노드를 표현할 노드 클래스를 가지고 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Node</span> 
<span class="o">{</span> 
    <span class="kt">int</span> <span class="n">key</span><span class="o">;</span> 
    <span class="nc">Node</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">;</span> 
  
    <span class="kd">public</span> <span class="nf">Node</span><span class="o">(</span><span class="kt">int</span> <span class="n">item</span><span class="o">)</span> 
    <span class="o">{</span> 
        <span class="n">key</span> <span class="o">=</span> <span class="n">item</span><span class="o">;</span> 
        <span class="n">left</span> <span class="o">=</span> <span class="n">right</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> 
    <span class="o">}</span> 
<span class="o">}</span> 
</code></pre></div></div>

<p>노드는 다음과 같은 부분으로 구성된다.</p>

<ol>
  <li>Data - 데이터를 저장하는 필드</li>
  <li>왼쪽 자식에 대한 레퍼런스</li>
  <li>오른쪽 자식에 대한 레퍼런스</li>
</ol>

<h2 id="트리-예제-코드">트리 예제 코드</h2>

<p>위의 표현들을 이용하여 트리를 만들어보고 이해해보자.</p>

<p>먼저 전체 코드이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Class containing left and right child of current 
   node and key value*/</span>
  
<span class="c1">// A Java program to introduce Binary Tree </span>
<span class="kd">class</span> <span class="nc">BinaryTree</span> 
<span class="o">{</span> 
    <span class="c1">// Root of Binary Tree </span>
    <span class="nc">Node</span> <span class="n">root</span><span class="o">;</span> 
  
    <span class="c1">// Constructors </span>
    <span class="nc">BinaryTree</span><span class="o">(</span><span class="kt">int</span> <span class="n">key</span><span class="o">)</span> 
    <span class="o">{</span> 
        <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="n">key</span><span class="o">);</span> 
    <span class="o">}</span> 
  
    <span class="nc">BinaryTree</span><span class="o">()</span> 
    <span class="o">{</span> 
        <span class="n">root</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> 
    <span class="o">}</span> 

    <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Node</span> 
    <span class="o">{</span> 
        <span class="kt">int</span> <span class="n">key</span><span class="o">;</span> 
        <span class="nc">Node</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">;</span> 
  
        <span class="kd">public</span> <span class="nf">Node</span><span class="o">(</span><span class="kt">int</span> <span class="n">item</span><span class="o">)</span> 
        <span class="o">{</span> 
        <span class="n">key</span> <span class="o">=</span> <span class="n">item</span><span class="o">;</span> 
        <span class="n">left</span> <span class="o">=</span> <span class="n">right</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> 
        <span class="o">}</span> 
    <span class="o">}</span> 
  
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> 
    <span class="o">{</span> 
        <span class="nc">BinaryTree</span> <span class="n">tree</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BinaryTree</span><span class="o">();</span> 
  
        <span class="cm">/*create root*/</span>
        <span class="n">tree</span><span class="o">.</span><span class="na">root</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span> 
  
        <span class="n">tree</span><span class="o">.</span><span class="na">root</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span> 
        <span class="n">tree</span><span class="o">.</span><span class="na">root</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span> 
        <span class="n">tree</span><span class="o">.</span><span class="na">root</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="mi">4</span><span class="o">);</span> 
    <span class="o">}</span> 
<span class="o">}</span> 
</code></pre></div></div>
<hr />
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">BinaryTree</span> <span class="n">tree</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BinaryTree</span><span class="o">();</span> 
</code></pre></div></div>

<p>이진 트리를 생성하는 구문이다.<br />
아직은 아무런 노드가 없으므로 root 레퍼런스는 null이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">tree</span><span class="o">.</span><span class="na">root</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
</code></pre></div></div>
<p>노드를 할당하여 1을 넣고, 트리의 root 레퍼런스가 할당된 노드를 가리키게 한다.</p>

<p>그림으로 표현하면 다음처럼 도식화 된다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>              1 
            /   \ 
          null  null 
</code></pre></div></div>

<p>1번 노드는 루트가 되었다.<br />
1번 노드의 왼쪽, 오른쪽 자식노드는 없으므로 left, right 레퍼런스는 null이다.</p>

<p>그 다음을 보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">tree</span><span class="o">.</span><span class="na">root</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span> 
<span class="n">tree</span><span class="o">.</span><span class="na">root</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span> 
</code></pre></div></div>
<p>노드를 할당하여 2를 넣고, 트리의 root 왼쪽 자식 레퍼런스가 할당된 노드를 가리키게 한다.
노드를 할당하여 3을 넣고, 트리의 root 오른쪽 자식 레퍼런스가 할당된 노드를 가리키게 한다.
2, 3번 노드는 아직 자식들이 없으므로 left, right 레퍼런스는 null이다.</p>

<p>그림으로 표현하면 다음과 같다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                1 
             /    \ 
            2       3 
          /   \    /  \ 
        null null null null
</code></pre></div></div>

<p>계속해서 그 다음을 보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">tree</span><span class="o">.</span><span class="na">root</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="mi">4</span><span class="o">);</span> 
</code></pre></div></div>
<p>노드를 할당하여 4를 넣고, root의 왼쪽 노드의 왼쪽 자식 레퍼런스가 할당된 노드를 가리키게 한다.</p>

<p>그림으로 표현하면 다음과 같다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                    1 
                /       \ 
               2          3 
             /   \       /  \ 
            4    null  null  null 
           /   \ 
          null null 
</code></pre></div></div>

<p>4번 노드는 2번 노드의 자식이 되었다.</p>

<h2 id="references">References</h2>
<p><a href="https://www.geeksforgeeks.org/">GeeksforGeeks</a></p>
:ET