I"Õ<h1 id="spfa">SPFA</h1>

<p>The Shortest Path Faster Algorithm (SPFA)ëŠ” Bellmanâ€“Ford algorithmë¥¼ ê°œì„ í•œ ì•Œê³ ë¦¬ì¦˜ ìœ¼ë¡œì„œ, ë°©í–¥ ê°€ì¤‘ì¹˜ ê·¸ë˜í”„ì—ì„œ ë‹¨ì¼ ì¶œë°œ ì •ì  ìµœë‹¨ ê±°ë¦¬ë¥¼ ê³„ì‚°í•œë‹¤. ì´ SPFAëŠ” ë¬´ì‘ìœ„ í¬ì†Œ ê·¸ë˜í”„ì—ì„œ ì˜ ë™ì‘í•œë‹¤ê³  ì•Œë ¤ì ¸ ìˆê³ , ìŒìˆ˜ ê°€ì¤‘ì¹˜ ê°„ì„ ì„ ê°€ì§„ ê·¸ë˜í”„ì—ì„œë„ ì í•©í•˜ë‹¤. ê·¸ëŸ¬ë‚˜ ìµœì•… ì‹œê°„ë³µì¡ë„ëŠ” Bellmanâ€“Ford algorithmê³¼ ê°™ê¸° ë•Œë¬¸ì—, ìŒìˆ˜ ê°€ì¤‘ì¹˜ ê°„ì„ ì´ ì—†ëŠ” ê·¸ë˜í”„ì˜ ê²½ìš°ì—ëŠ” ìµœì•… ì‹œê°„ë³µì¡ë„ë¥¼ ê³ ë ¤í•œë‹¤ë©´ Dijkstraâ€™s algorithmì´ ë” ì í•©í•˜ë‹¤ê³  ë³¼ ìˆ˜ ìˆë‹¤.</p>

<h2 id="algorithm">Algorithm</h2>

<p>ë°©í–¥ ê°€ì¤‘ì¹˜ ê·¸ë˜í”„ê°€ ì£¼ì–´ì§€ê³  $G = (V, E)$ ê·¸ë¦¬ê³  ì¶œë°œ ì •ì ì„ $s$ë¼ê³  í•˜ì. SPFAëŠ” ì¶œë°œ ì •ì  $s$ìœ¼ë¡œë¶€í„° ë‹¤ë¥¸ ëª¨ë“  ì •ì  $v$ë¡œì˜ ìµœë‹¨ ê²½ë¡œë¥¼ ì°¾ëŠ”ë‹¤. $s$ë¡œ ë¶€í„° $v$ë¡œì˜ ìµœë‹¨ ê²½ë¡œ ê±°ë¦¬ëŠ” ê° ì •ì  $v$ì— ëŒ€í•˜ì—¬ $d(v)$ì— ì €ì¥ëœë‹¤.</p>

<p>SPFAì˜ ê¸°ë³¸ ì•„ì´ë””ì–´ëŠ” ë‹¤ìŒê³¼ ê°™ë‹¤.<br />
ê° ì •ì ì€ ì¸ì ‘ ì •ì ì„ ë³€ ê²½ê°(Edge relaxation)í•˜ê¸° ìœ„í•´ í›„ë³´ìë¡œ ì‚¬ìš©ì´ ëœë‹¤.
The basic idea of SPFA is the same as Bellmanâ€“Ford algorithm in that each vertex is used as a candidate to relax its adjacent vertices. The improvement over the latter is that instead of trying all vertices blindly, SPFA maintains a queue of candidate vertices and adds a vertex to the queue only if that vertex is relaxed. This process repeats until no more vertex can be relaxed.</p>

<p>Below is the pseudo-code of the algorithm.[4] Here {\displaystyle Q}Q is a first-in, first-out queue of candidate vertices, and {\displaystyle w(u,v)}{\displaystyle w(u,v)} is the edge weight of {\displaystyle (u,v)}(u,v).</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="mi">0</span> <span class="n">procedure</span> <span class="n">Shortest</span><span class="o">-</span><span class="n">Path</span><span class="o">-</span><span class="n">Faster</span><span class="o">-</span><span class="n">Algorithm</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
 <span class="mi">1</span>    <span class="k">for</span> <span class="n">each</span> <span class="n">vertex</span> <span class="n">v</span> <span class="err">â‰ </span> <span class="n">s</span> <span class="n">in</span> <span class="n">V</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
 <span class="mi">2</span>        <span class="n">d</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">:=</span> <span class="err">âˆ</span>
 <span class="mi">3</span>    <span class="n">d</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">:=</span> <span class="mi">0</span>
 <span class="mi">4</span>    <span class="n">offer</span> <span class="n">s</span> <span class="n">into</span> <span class="n">Q</span>
 <span class="mi">5</span>    <span class="k">while</span> <span class="n">Q</span> <span class="n">is</span> <span class="n">not</span> <span class="n">empty</span>
 <span class="mi">6</span>        <span class="n">u</span> <span class="o">:=</span> <span class="n">poll</span> <span class="n">Q</span>
 <span class="mi">7</span>        <span class="k">for</span> <span class="n">each</span> <span class="n">edge</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="n">in</span> <span class="n">E</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
 <span class="mi">8</span>            <span class="k">if</span> <span class="n">d</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">+</span> <span class="n">w</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">d</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="n">then</span>
 <span class="mi">9</span>                <span class="n">d</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">:=</span> <span class="n">d</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">+</span> <span class="n">w</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
<span class="mi">10</span>                <span class="k">if</span> <span class="n">v</span> <span class="n">is</span> <span class="n">not</span> <span class="n">in</span> <span class="n">Q</span> <span class="n">then</span>
<span class="mi">11</span>                    <span class="n">offer</span> <span class="n">v</span> <span class="n">into</span> <span class="n">Q</span>
</code></pre></div></div>

<p>The basic idea of SPFA is the same as Bellmanâ€“Ford algorithm in that each vertex is used as a candidate to relax its adjacent vertices. The improvement over the latter is that instead of trying all vertices blindly, SPFA maintains a queue of candidate vertices and adds a vertex to the queue only if that vertex is relaxed. This process repeats until no more vertex can be relaxed.</p>

<p><img src="/assets/images/SPFA-0.png" alt="Alt text" width="400px" height="300px" class="align-center" /></p>

<p>The performance of the algorithm is strongly determined by the order in which candidate vertices are used to relax other vertices. In fact, if {\displaystyle Q}Q is a priority queue, then the algorith</p>

<p><img src="/assets/images/SPFA-1.png" alt="Alt text" width="400px" height="300px" class="align-center" /></p>

<p>(and does not have to be in the queue anymore). However, the relaxation by {\displaystyle x}x might cause some other vertices to become capable of causing rel</p>

<p><img src="/assets/images/SPFA-2.png" alt="Alt text" width="400px" height="300px" class="align-center" /></p>

<p>axation. If there exists some {\displaystyle dist[x]&gt;dist[w]+wt(w,x)}{\displaystyle dist[x]&gt;dist[w]+wt(w,x)} such that before the current loop iteration, then {\displaystyle w}w is already in the queue. If this condition</p>

<p><img src="/assets/images/SPFA-3.png" alt="Alt text" width="400px" height="300px" class="align-center" /></p>

<p><img src="/assets/images/SPFA-4.png" alt="Alt text" width="400px" height="300px" class="align-center" /></p>

<p><img src="/assets/images/SPFA-5.png" alt="Alt text" width="400px" height="300px" class="align-center" /></p>

<p><img src="/assets/images/SPFA-6.png" alt="Alt text" width="400px" height="300px" class="align-center" /></p>

<p><img src="/assets/images/SPFA-7.png" alt="Alt text" width="400px" height="300px" class="align-center" /></p>

<p><img src="/assets/images/SPFA-8.png" alt="Alt text" width="400px" height="300px" class="align-center" /></p>

<p><img src="/assets/images/SPFA-9.png" alt="Alt text" width="400px" height="300px" class="align-center" /></p>

<p><img src="/assets/images/SPFA-10.png" alt="Alt text" width="400px" height="300px" class="align-center" /></p>

<p><img src="/assets/images/SPFA-11.png" alt="Alt text" width="400px" height="300px" class="align-center" /></p>

:ET