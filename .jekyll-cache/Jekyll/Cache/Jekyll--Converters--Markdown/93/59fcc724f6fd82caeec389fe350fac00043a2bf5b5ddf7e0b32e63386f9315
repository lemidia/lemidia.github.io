I"<<h1 id="bubble버블-정렬">Bubble(버블 정렬)</h1>

<p>비교 기반 정렬 알고리즘이다.</p>

<p>다른 O(nlongn)의 성능을 내는 정렬 알고리즘에 비해 성능이 좋지 않으므로 실무에서는 교육용 목적으로 사용 되어진다.</p>

<p class="notice--info">더 효율적인 정렬 알고리즘인 팀소트(Timsort)가 머지소트(Merge sort)는 인기있는 프로그래밍 언어(java, python)의 내장 정렬 라이브러리로 사용되고 있다.</p>
<hr />

<h2 id="algorithm">Algorithm</h2>

<p>밑의 애니메이션을 먼저 보시고 알고리즘을 읽으시면 이해가 빠를 수 있습니다.</p>

<ol>
  <li>처음 원소를 시작으로 n번째 원소까지 차례대로 옆 원소와 오른쪽으로 비교하며 스왑을 진행한다.</li>
  <li>n번째 원소와 비교가 끝이나면 n번째 원소는 정렬이 완료된 것이다.</li>
  <li>처음 원소부터 n-1번째 원소까지 1번과 같이 수행한다.</li>
  <li>n-1번째 원소와 비교가 끝이나면 n-1번째 원소는 정렬이 완료된 것이다.</li>
  <li>이를 반복하여 n-2..n-3..2번째 원소까지 정렬이 완료되면 정렬이 완료된 것이다.</li>
</ol>

<p><img src="/assets/images/bubblesort1.gif" alt="Alt text" width="400px&quot;, height=&quot;500px" /></p>

<h2 id="analysis">Analysis</h2>

<p>버블소트는 최악과 평균 시간복잡도가 $O(n^2)$인 정렬 알고리즘이다.</p>

<p>최악과 평균 시간복잡도가 $O(nlog_{2}n)$인 실용적인 정렬 알고리즘 보다 성능이 좋지않고<br />
시간복잡도가 $O(n^2)$인 삽입정렬도 버블소트보다는 빠르게 동작하기 때문에 버블소트는 다소 실용적인 정렬 알고리즘이 아니다.</p>

<p>다른 정렬들과 비교해(삽입정렬을 제외한) 버블소트의 최대 장점은 배열이 정렬되어 있는 것을 탐지해낼 수 있는 능력이다.<br />
리스트가 정렬이 완료되어 있을 때의 버블정렬은 O(n)이다.</p>

<h2 id="step-by-step-example">Step-by-step example</h2>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>First Pass
( 5 1 4 2 8 ) → ( 1 5 4 2 8 )
Here, algorithm compares the first two elements, and swaps since 5 &gt; 1.
( 1 5 4 2 8 ) → ( 1 4 5 2 8 )
Swap since 5 &gt; 4
( 1 4 5 2 8 ) → ( 1 4 2 5 8 )
Swap since 5 &gt; 2
( 1 4 2 5 8 ) → ( 1 4 2 5 8 )
Now, since these elements are already in order (8 &gt; 5)
algorithm does not swap them.


## Java로 구현 - 재귀적(Top-down, Recursive)
**설명**: 재귀적으로 서브배열의 크기가 1이 될 때까지 계속 분할을 진행합니다.  
분할된 배열들을 정렬하고 합병합니다.
{: .notice--warning}
```java
// @author lemidia
public class MergeSort {
    static void divide(int data[], int p, int r){
        if(p &lt; r){
            int q = (p+r)/2; // Middle
            divide(data, p, q); // Left
            divide(data, q+1, r); // Right
            merge(data, p, q, r); // Merge
        }
    }

    static void merge(int data[], int p, int q, int r){
        int i = p; int j = q+1; int k = p;
        int temp[] = new int[data.length];

        for (int l = p; l &lt; r+1 ; l++) {
            if (i &lt;= q &amp;&amp; (j &gt; r || data[i] &lt; data[j])){
                temp[k++] = data[i++];
            }else
                temp[k++] = data[j++];
        }
        for(int l = p; l &lt;= r; l++){
            data[l] = temp[l];
        }

        /*
        while (i&lt;=q &amp;&amp; j&lt;=r){
            if(data[i] &lt;= data[j]){
                temp[k++] = data[i++];
            }else{
                temp[k++] = data[j++];
            }
        }
        while (i&lt;=q)
            temp[k++] = data[i++];
        while (j&lt;=r)
            temp[k++] = data[j++];
        for(int l = p; l&lt;=r; l++){
            data[l] = temp[l];
        }
        */

    }

    public static void main(String[] args) {
        int limit = 10;
        int arr[] = new int[limit];

        for(int i = limit-1; i &gt;= 0; --i){
            arr[i] = limit-i;
        }
        divide(arr, 0, limit-1);
        for (int i = 0; i &lt; arr.length; i++) {
            System.out.print(arr[i] + " ");
        }
    }
}
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span> <span class="mi">10</span> 
</code></pre></div></div>

<h2 id="시간복잡도">시간복잡도</h2>
<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>최악 시간복잡도	O(n log n)
최선 시간복잡도	O(n log n)
평균 시간복잡도	일반적으로, O(n log n)
</code></pre></div></div>
<p class="notice--warning"><strong>쉬운 설명</strong>: 배열의 원소가 n개일 때 깊이는 log(n)만큼 진행 됩니다. (매번 2개씩 분할 되므로)<br />
각 깊이마다 n개의 원소들이 제자리를 찾아 스왑됩니다.<br />
그래서 시간복잡도는 깊이 * n개의 원소 즉, <strong>nlog(n)</strong>이 됩니다.</p>

<h2 id="references">References</h2>

<p><a href="https://en.wikipedia.org/wiki/Merge_sort">Merge Sort - wikipedia</a></p>
:ET